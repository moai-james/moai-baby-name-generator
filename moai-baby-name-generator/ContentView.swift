//
//  ContentView.swift
//  moai-baby-name-generator
//
//  Created by james hsiao on 2024/10/9.
//
import UIKit
import SwiftUI
import SwiftyGif
import SwiftOpenAI
import GoogleSignIn
import FirebaseCore
import FirebaseAuth
import FirebaseFirestore
import WebKit
import GoogleMobileAds
import StoreKit
import AuthenticationServices
import CryptoKit
import FirebaseAppCheck

// extension Color {
//     static let customBackground = Color("CustomBackground")
//     static let customText = Color("CustomText")
//     static let customAccent = Color("CustomAccent")
//     static let customSecondary = Color("CustomSecondary")
struct BannerView: UIViewControllerRepresentable {
    func makeUIViewController(context: Context) -> UIViewController {
        print("üì± [BannerAd] Starting to create banner view")
        let bannerView = GADBannerView(adSize: GADAdSizeBanner)
        let viewController = UIViewController()
        
        // Ê∏¨Ë©¶Áî®Âª£ÂëäÂñÆÂÖÉ ID,ÁôºÂ∏ÉÊôÇË¶ÅÊèõÊàêÁúüÂØ¶ÁöÑ
        print("üéØ [BannerAd] Setting ad unit ID")
        // bannerView.adUnitID = "ca-app-pub-3469743877050320/3645991765"
        bannerView.adUnitID = "ca-app-pub-3940256099942544/2934735716"
        bannerView.rootViewController = viewController
        
        
        print("üîÑ [BannerAd] Adding banner view to view controller")
        viewController.view.addSubview(bannerView)
        viewController.view.frame = CGRect(origin: .zero, size: GADAdSizeBanner.size)
        
        print("üì§ [BannerAd] Loading banner ad request")
        bannerView.load(GADRequest())
        print("‚úÖ [BannerAd] Banner view setup complete")
        return viewController
    }

    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {}
}

struct ContentView: View {
    @State private var navigationPath = NavigationPath()
    @State private var showSplash = true
    @StateObject private var authViewModel = AuthViewModel()
    @StateObject private var usageManager = UsageManager.shared
    @StateObject private var appStateManager = AppStateManager()
    
    
    var body: some View {
        ZStack {
            NavigationStack(path: $navigationPath) {
                MainView(navigationPath: $navigationPath, 
                        selectedTab: $authViewModel.selectedTab,
                        isLoggedIn: $authViewModel.isLoggedIn,
                        authViewModel: authViewModel)
            }
            .accentColor(.customAccent)

            if showSplash {
                SplashScreenView(showSplash: $showSplash)
                .zIndex(1)
            }
            
            if !showSplash && !authViewModel.isLoggedIn {
                LoginView(authViewModel: authViewModel)
            }
        }
        .onAppear {
            checkExistingAuth()
            
            // Êõ¥Êñ∞ÊèêÁ§∫Ë©ûÊ®°Êùø
            Task {
                await PromptManager.shared.updatePrompts()
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
            appStateManager.handleAppForeground()
        }
    }
    
    private func checkExistingAuth() {
        if let user = Auth.auth().currentUser {
            print("üë§ Found existing user: \(user.uid)")
            user.getIDTokenResult { tokenResult, error in
                if let error = error {
                    print("‚ùå Token È©óË≠âÈåØË™§: \(error.localizedDescription)")
                    self.authViewModel.isLoggedIn = false
                    return
                }
                
                guard let tokenResult = tokenResult else {
                    print("‚ùå No token result")
                    self.authViewModel.isLoggedIn = false
                    return
                }
                
                if tokenResult.expirationDate > Date() {
                    print("‚úÖ Token is valid")
                    authViewModel.handleSuccessfulLogin()
                } else {
                    print("üîÑ Token expired, refreshing...")
                    user.getIDTokenForcingRefresh(true) { _, error in
                        if let error = error {
                            print("‚ùå Token Âà∑Êñ∞ÈåØË™§: \(error.localizedDescription)")
                            self.authViewModel.isLoggedIn = false
                        } else {
                            print("‚úÖ Token refreshed successfully")
                            authViewModel.handleSuccessfulLogin()
                        }
                    }
                }
            }
        } else {
            print("üë§ No existing user found")
            self.authViewModel.isLoggedIn = false
        }
    }

}

struct LoginView: View {
    @ObservedObject var authViewModel: AuthViewModel
    @State private var errorMessage: String?
    @Environment(\.colorScheme) var colorScheme
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @State private var isLoading = false
    @State private var showPhoneVerification = false
    @State private var showVerificationCode = false
    @State private var mfaResolver: MultiFactorResolver?
    @State private var lastSMSRequestTime: Date?
    @State private var cooldownRemaining: Int = 0
    let smsCooldownDuration: Int = 60 // ÂÜ∑ÂçªÊôÇÈñìÔºàÁßíÔºâ
    
    let textColor = Color(hex: "#FF798C")
    
    var body: some View {
        ZStack {
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 20) {
                HStack(alignment: .center, spacing: 0) {
                    Image("login_mascot")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 180)
                        .offset(x:-15)
                        
                    Text("Ê≠°ËøéÂä†ÂÖ•")
                        .font(.custom("NotoSansTC-Black", size: 32))
                        .foregroundColor(textColor)
                        .offset(x:-20, y:10)
                        .bold()
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                
                
                
                // if let errorMessage = errorMessage {
                //     Text(errorMessage)
                //         .foregroundColor(.red)
                //         .font(.custom("NotoSansTC-Regular", size: 14))
                // }
                
                Button(action: signInWithGoogle) {
                    HStack {
                        Image("GoogleLogo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 17)
                        Text("‰ΩøÁî® Google Â∏≥ËôüÁôªÂÖ•")
                            .font(.custom("NotoSansTC-Black", size: 16))
                            .bold()
                    }
                    .foregroundColor(textColor)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(textColor, lineWidth: 1)
                    )
                }
                
                Button(action: signInWithApple) {
                    HStack {
                        Image(systemName: "apple.logo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 17)
                        Text("‰ΩøÁî® Apple Â∏≥ËôüÁôªÂÖ•")
                            .font(.custom("NotoSansTC-Black", size: 16))
                            .bold()
                    }
                    .foregroundColor(textColor)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(textColor, lineWidth: 1)
                    )
                }
                
                Button(action: signInAsGuest) {
                    HStack {
                        Image(systemName: "person.fill")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 17)
                        Text("‰ª•Ë®™ÂÆ¢Ë∫´‰ªΩ‰ΩøÁî®")
                            .font(.custom("NotoSansTC-Black", size: 16))
                            .bold()
                    }
                    .foregroundColor(textColor)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(textColor, lineWidth: 1)
                    )
                }
                
                // Spacer()
            
                // Version information
                if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String,
                let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
                    Text("Version \(version) (\(build))")
                        .font(.footnote)
                        .foregroundColor(.gray)
                        .padding(.bottom, 10)
                }

            }
            .padding(.horizontal, 30)
            
            // Phone Verification Sheet
            .sheet(isPresented: $authViewModel.showPhoneVerification, onDismiss: {
                authViewModel.resetVerificationState()
            }) {
                NavigationView {
                    VStack(spacing: 20) {
                        // Phone number input
                        CustomTextField(
                            placeholder: "Ë´ãËº∏ÂÖ•ÊâãÊ©üËôüÁ¢º",
                            text: $authViewModel.phoneNumber,
                            keyboardType: .phonePad
                        )
                        .padding(.horizontal)
                        
                        if authViewModel.canResetPhoneNumber {
                            // È°ØÁ§∫ÈáçË®≠ÊâãÊ©üËôüÁ¢ºÁöÑÈÅ∏È†Ö
                            HStack {
                                Text("ÊâãÊ©üËôüÁ¢ºËº∏ÂÖ•ÈåØË™§Ôºü")
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.gray)
                                
                                Button("ÈáçÊñ∞Ëº∏ÂÖ•ËôüÁ¢º") {
                                    authViewModel.resetPhoneNumberInput()
                                }
                                .font(.custom("NotoSansTC-Regular", size: 14))
                                .foregroundColor(.customAccent)
                            }
                            .padding(.horizontal)
                        }
                        
                        if authViewModel.verificationID != nil {
                            // Verification code input
                            CustomTextField(
                                placeholder: "Ë´ãËº∏ÂÖ•È©óË≠âÁ¢º",
                                text: $authViewModel.verificationCode,
                                keyboardType: .numberPad,
                                textContentType: .oneTimeCode  // Ê∑ªÂä†ÈÄôË°å‰æÜÊîØÊåÅËá™ÂãïÂ°´ÂÖÖÁ∞°Ë®äÈ©óË≠âÁ¢º
                            )
                            .padding(.horizontal)
                            .onChange(of: authViewModel.verificationCode) { newValue in
                                // Áï∂È©óË≠âÁ¢ºÊîπËÆäÊôÇÔºåÊ™¢Êü•ÊòØÂê¶ÁÇ∫ÂæûÂâ™Ë≤ºÁ∞øË≤º‰∏äÁöÑÂÖßÂÆπ
                                if let pasteboardString = UIPasteboard.general.string,
                                   pasteboardString.count == 6,  // ÂÅáË®≠È©óË≠âÁ¢ºÁÇ∫ 6 ‰ΩçÊï∏
                                   pasteboardString.allSatisfy({ $0.isNumber }) {
                                    authViewModel.verificationCode = pasteboardString
                                }
                            }
                            
                            // Countdown timer and resend button
                            HStack {
                                if let remainingTime = authViewModel.remainingTime {
                                    Text("È©óË≠âÁ¢ºÊúâÊïàÊôÇÈñìÔºö\(remainingTime)Áßí")
                                        .font(.custom("NotoSansTC-Regular", size: 14))
                                        .foregroundColor(.gray)
                                    
                                    if remainingTime == 0 {
                                        Button("ÈáçÊñ∞ÁôºÈÄÅ") {
                                            authViewModel.sendVerificationCode()
                                        }
                                        .font(.custom("NotoSansTC-Regular", size: 14))
                                        .foregroundColor(.customAccent)
                                    }
                                }
                            }
                            .padding(.horizontal)
                            
                            // Verify button with loading state
                            Button(action: {
                                authViewModel.verifyCode()
                            }) {
                                HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                    if authViewModel.isLoading {
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    } else {
                                        Text("È©óË≠â")
                                    }
                                }
                                .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                                .padding()
                                .background(authViewModel.isLoading ? Color.gray : Color.customAccent)
                                .foregroundColor(.white)
                                .cornerRadius(25)
                            }
                            .padding(.horizontal)
                            .disabled(authViewModel.isLoading)
                        } else {
                            // Send code button
                            Button(action: {
                                authViewModel.sendVerificationCode()
                            }) {
                                HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                    if authViewModel.isLoading {
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    } else {
                                        Text(authViewModel.displayCooldownTime > 0 
                                            ? "Ë´ãÁ≠âÂæÖ \(authViewModel.displayCooldownTime) Áßí"
                                            : "ÁôºÈÄÅÈ©óË≠âÁ¢º")
                                    }
                                }
                                .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                                .padding()
                                .background(
                                    authViewModel.displayCooldownTime > 0 || authViewModel.isLoading 
                                        ? Color.gray 
                                        : Color.customAccent
                                )
                                .foregroundColor(.white)
                                .cornerRadius(25)
                            }
                            .padding(.horizontal)
                            .disabled(authViewModel.displayCooldownTime > 0 || authViewModel.isLoading)
                        }
                        
                        if let error = authViewModel.errorMessage {
                            Text(error)
                                .font(.custom("NotoSansTC-Regular", size: 14))
                                .foregroundColor(.red)
                                .padding()
                        }
                        
                        Spacer()
                    }
                    .padding(.top)
                    .navigationTitle("ÈõôÈáçÈ©óË≠âË®≠ÂÆö")
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationBarItems(trailing: Button("ÂèñÊ∂à") {
                        authViewModel.showPhoneVerification = false
                    }
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    )
                    .onAppear {
                        authViewModel.resetVerificationState()
                    }
                }
            }
            
            // Loading overlay
            if isLoading {
                Color.black.opacity(0.5)
                    .edgesIgnoringSafeArea(.all)
                
                VStack {
                    ProgressView()
                        .scaleEffect(1.5)
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    Text("ÁôªÂÖ•‰∏≠...")
                        .foregroundColor(.white)
                        .padding(.top)
                }
            }
        }
        .sheet(isPresented: $showVerificationCode) {
            if let resolver = mfaResolver {
                VerificationCodeView(resolver: resolver)
            }
        }
    }

    private func signInWithGoogle() {
        guard let clientID = FirebaseApp.app()?.options.clientID else { 
            print("‚ùå ÁÑ°Ê≥ïÁç≤Âèñ clientID")
            return 
        }
        
        // Ë®≠ÁΩÆ loading ÁãÄÊÖã
        isLoading = true
        
        print("‚úÖ ÈñãÂßã Google ÁôªÂÖ•ÊµÅÁ®ã")
        print("ClientID: \(clientID)")
        
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.windows.first,
              let rootViewController = window.rootViewController else {
            isLoading = false  // Â¶ÇÊûúÂ§±ÊïóË¶ÅÈóúÈñâ loading
            print("‚ùå ÁÑ°Ê≥ïÁç≤Âèñ rootViewController")
            return
        }
        
        print("‚úÖ Ê∫ñÂÇôÈ°ØÁ§∫ Google ÁôªÂÖ•Ë¶ñÁ™ó")
        
        GIDSignIn.sharedInstance.signIn(withPresenting: rootViewController) { [self] result, error in
            if let error = error {
                print("‚ùå Google ÁôªÂÖ•ÈåØË™§: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                isLoading = false  // ÁôªÂÖ•Â§±ÊïóÈóúÈñâ loading
                return
            }
            
            print("‚úÖ Google ÁôªÂÖ•ÊàêÂäü")
            guard let user = result?.user,
                  let idToken = user.idToken?.tokenString else {
                isLoading = false  // Ë≥áÊñôÁÑ°ÊïàÈóúÈñâ loading
                return
            }
            
            let credential = GoogleAuthProvider.credential(withIDToken: idToken, accessToken: user.accessToken.tokenString)
            
            Auth.auth().signIn(with: credential) { [self] authResult, error in
                // ÂÆåÊàêÊôÇÈóúÈñâ loading
                defer { isLoading = false }
                
                if let error = error as NSError? {
                    if error.domain == AuthErrorDomain,
                       error.code == AuthErrorCode.secondFactorRequired.rawValue {
                        // Handle MFA
                        print(" Auth.auth().currentUser: \(String(describing: Auth.auth().currentUser))")
                        authViewModel.mfaResolver = error.userInfo[AuthErrorUserInfoMultiFactorResolverKey] as? MultiFactorResolver
                        authViewModel.showPhoneVerification = true
                    } else {
                        errorMessage = error.localizedDescription
                    }
                } else {
                    print(" Auth.auth().currentUser: \(String(describing: Auth.auth().currentUser))")
                    print("‚úÖ googleÁôªÂÖ•ÊàêÂäü")
                    authViewModel.handleSuccessfulLogin()
                }
            }           
        }
    }
    
    private func signInWithApple() {
        isLoading = true  // ÈñãÂßãËºâÂÖ•
        appleSignInCoordinator = AppleSignInCoordinator()
        appleSignInCoordinator?.startSignInWithAppleFlow { result in
            // ÂÆåÊàêÊôÇÈóúÈñâ loading
            defer { isLoading = false }
            
            switch result {
            case .success(_):
                authViewModel.handleSuccessfulLogin()
            case .failure(let error):
                errorMessage = error.localizedDescription
            }
        }
    }
    
    private func signInAsGuest() {
        isLoading = true  // ÈñãÂßãËºâÂÖ•
        
        // Ê∏ÖÁ©∫Êî∂ËóèÂàóË°®
        UserDefaults.standard.removeObject(forKey: "FavoriteNames")
        
        Auth.auth().signInAnonymously { [self] authResult, error in
            // ÂÆåÊàêÊôÇÈóúÈñâ loading
            defer { isLoading = false }
            
            if let error = error {
                print("‚ùå Ë®™ÂÆ¢ÁôªÂÖ•ÈåØË™§: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                return
            }
            
            guard let user = authResult?.user else {
                print("‚ùå ÁÑ°Ê≥ïÁç≤ÂèñÁî®Êà∂Ë≥áË®ä")
                return
            }
            
            print("‚úÖ ÂâµÂª∫Êñ∞ÁöÑÂåøÂêçÂ∏≥Ëôü")
            print("üë§ Áî®Êà∂ ID: \(user.uid)")
            print("üîë ÊòØÂê¶ÁÇ∫ÂåøÂêçÁî®Êà∂: \(user.isAnonymous)")
            
            // Âú® Firestore ‰∏≠ÂâµÂª∫Áî®Êà∂ÊñáÊ™î
            let db = Firestore.firestore()
            db.collection("users").document(user.uid).setData([
                "isAnonymous": true,
                "createdAt": FieldValue.serverTimestamp(),
                "lastLoginAt": FieldValue.serverTimestamp(),
                "favorites": [] // Á¢∫‰øùÊî∂ËóèÂàóË°®ÁÇ∫Á©∫
            ], merge: true) { error in
                if let error = error {
                    print("‚ùå ÂâµÂª∫Áî®Êà∂ÊñáÊ™îÂ§±Êïó: \(error.localizedDescription)")
                } else {
                    print("‚úÖ ÂâµÂª∫Áî®Êà∂ÊñáÊ™îÊàêÂäü")
                }
            }
            
            authViewModel.handleSuccessfulLogin()
        }
    }

    private func startCooldownTimer() {
        // Ë®≠ÁΩÆÊúÄÂæåÁôºÈÄÅÊôÇÈñì
        lastSMSRequestTime = Date()
        // ÈñãÂßãÂÄíÊï∏Ë®àÊôÇ
        cooldownRemaining = smsCooldownDuration
        
        // ÂâµÂª∫Ë®àÊôÇÂô®‰æÜÊõ¥Êñ∞Ââ©È§òÊôÇÈñì
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
            if cooldownRemaining > 0 {
                cooldownRemaining -= 1
            } else {
                timer.invalidate()
            }
        }
    }
    
    private func canSendSMS() -> Bool {
        guard let lastRequest = lastSMSRequestTime else { return true }
        let timeSinceLastRequest = Date().timeIntervalSince(lastRequest)
        return timeSinceLastRequest >= Double(smsCooldownDuration)
    }
}

struct CustomTextField: View {
    let placeholder: String
    @Binding var text: String
    var keyboardType: UIKeyboardType = .default
    var autocapitalization: TextInputAutocapitalization = .sentences
    var isSecure: Bool = false
    var validation: ((String) -> Bool)?
    var errorMessage: String?
    var textContentType: UITextContentType? = nil
    var returnKeyType: UIReturnKeyType = .done
    var cooldownRemaining: Int? = nil
    
    @State private var isValid: Bool = true
    @State private var showError: Bool = false
    @FocusState private var isFocused: Bool  // Êñ∞Â¢û FocusState
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            if isSecure {
                SecureField(placeholder, text: $text)
                    .textFieldStyle(CustomTextFieldStyle())
                    .keyboardType(keyboardType)
                    .textInputAutocapitalization(autocapitalization)
                    .textContentType(textContentType)
                    .submitLabel(.done)
                    .focused($isFocused)  // Ê∑ªÂä† focused ‰øÆÈ£æÁ¨¶
                    .onTapGesture {  // Ê∑ªÂä†ÈªûÊìäÊâãÂã¢
                        isFocused = true
                    }
                    .onChange(of: text) { newValue in
                        validateInput(newValue)
                    }
            } else {
                TextField(placeholder, text: $text)
                    .textFieldStyle(CustomTextFieldStyle())
                    .keyboardType(keyboardType)
                    .textInputAutocapitalization(autocapitalization)
                    .textContentType(textContentType)
                    .submitLabel(.done)
                    .focused($isFocused)  // Ê∑ªÂä† focused ‰øÆÈ£æÁ¨¶
                    .onTapGesture {  // Ê∑ªÂä†ÈªûÊìäÊâãÂã¢
                        isFocused = true
                    }
                    .onChange(of: text) { newValue in
                        validateInput(newValue)
                    }
            }
            
            if showError, let errorMessage = errorMessage {
                Text(errorMessage)
                    .font(.caption)
                    .foregroundColor(.red)
                    .padding(.leading, 4)
            }
            
            if let cooldown = cooldownRemaining, cooldown > 0 {
                Text("\(cooldown) ÁßíÂæåÂèØÈáçÊñ∞ÁôºÈÄÅ")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
        }
    }
    
    private func validateInput(_ value: String) {
        if let validation = validation {
            isValid = validation(value)
            showError = !isValid && !value.isEmpty
        }
    }
}

struct CustomTextFieldStyle: TextFieldStyle {
    func _body(configuration: TextField<Self._Label>) -> some View {
        configuration
            .padding()
            .background(Color.white)
            .cornerRadius(25)
            .overlay(
                RoundedRectangle(cornerRadius: 25)
                    .stroke(Color.customAccent, lineWidth: 1)
            )
    }
}

extension View {
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content) -> some View {

        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }

        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

struct MainView: View {
    // Navigation and tab state
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int
    @Binding var isLoggedIn: Bool
    
    // View models
    @ObservedObject var authViewModel: AuthViewModel
    @StateObject private var rewardedViewModel = RewardedViewModel()
    @StateObject private var usageManager = UsageManager.shared
    @StateObject private var interstitialAd = InterstitialAdViewModel()
    @StateObject private var iapManager = IAPManager.shared
    // @ObservedObject private var taskManager = TaskManager.shared
    
    // Environment and storage
    @Environment(\.colorScheme) var colorScheme
    @AppStorage("isDarkMode") private var isDarkMode = false
    @AppStorage("favoriteTabCount") private var favoriteTabCount = 0
    
    // Alert states
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var showPhoneVerification = false
    @State private var showDeleteAccountAlert = false
    @State private var showTwoFactorAlert = false
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @State private var upgradeErrorMessage: String? // Renamed to avoid conflict
    @State private var showUpgradeError = false
    @State private var isUpgrading = false
    
    // Add new state for showing account linking options
    @State private var showAccountLinkingOptions = false
    @State private var showSerialNumberInput = false

    var body: some View {
        ZStack {
            // Main content area
            ZStack {
                if selectedTab == 0 {
                    homeView
                } else if selectedTab == 1 {
                    VStack {
                        Text("Êî∂Ëóè")
                            .font(.custom("NotoSansTC-Black", size: 32))
                            .foregroundColor(.customText)
                            .padding(.top, 20)
                        FavoritesListView()
                    }
                } else if selectedTab == 2 {
                    StoreView()
                } else if selectedTab == 3 {
                    settingsView
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
                
            // Tab bar with banner ad
            VStack(spacing: 0) {
                Spacer()
                    
                // Add banner ad
                BannerView()
                    .frame(width: GADAdSizeBanner.size.width, height: GADAdSizeBanner.size.height)
                    
                // Tab bar
                HStack(spacing: 20) {
                    Spacer()
                    TabBarButton(imageName: "home_icon", isSelected: selectedTab == 0) { 
                        selectedTab = 0 
                    }
                    Spacer()
                    TabBarButton(imageName: "favs_icon", isSelected: selectedTab == 1) { 
                        // Show interstitial ad when switching to favorites tab
                        if selectedTab != 1 {
                            favoriteTabCount += 1
                            if favoriteTabCount >= 3 {
                                interstitialAd.showAd()
                                favoriteTabCount = 0  // Reset counter
                            }
                        }
                        selectedTab = 1
                    }
                    Spacer()
                    TabBarButton(imageName: "store_icon", isSelected: selectedTab == 2) { 
                        selectedTab = 2 
                    }
                    Spacer()
                    // TabBarButton(imageName: "setting_icon", isSelected: selectedTab == 3, badgeCount: taskManager.missions.filter { !$0.isRewardClaimed }.count) { 
                    //     selectedTab = 3 
                    // }
                    TabBarButton(imageName: "setting_icon", isSelected: selectedTab == 3, badgeCount: 0) { 
                        selectedTab = 3 
                    }
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.vertical , 10)
                .frame(maxWidth: .infinity)
                .background(Color.tabbar)
                .cornerRadius(25, corners: [.topLeft, .topRight])
            }
            .ignoresSafeArea(edges: .bottom)
        }
        .navigationDestination(for: String.self) { destination in
            if destination == "FormView" {
                FormView(navigationPath: $navigationPath, 
                        selectedTab: $selectedTab,
                        isLoggedIn: $authViewModel.isLoggedIn,
                        authViewModel: authViewModel)
                .background(Color.black.opacity(0.3))
                .transition(.identity)
            }
        }
        .navigationDestination(for: FormData.self) { formData in
            DialogView(
                navigationPath: $navigationPath,
                selectedTab: $selectedTab,  // ÂÇ≥ÈÅû selectedTab
                formData: formData)
            .transition(.identity)
        }
        .preferredColorScheme(isDarkMode ? .dark : .light)
        .onAppear {
            // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈ°ØÁ§∫ÈõôÈáçÈ©óË≠âÊèêÈÜí
            if UserDefaults.standard.bool(forKey: "shouldShowTwoFactorAlert") {
                showTwoFactorAlert = true
                UserDefaults.standard.set(false, forKey: "shouldShowTwoFactorAlert")
            }
        }
    }
   
    var homeView: some View {
        ZStack {
            GeometryReader { geometry in
                VStack() {
                    // Header ‰øùÊåÅÂú®Â§ñÂ±§
                    VStack(spacing: 0) {
                        Color.black.frame(height: 0)
                        HStack {
                            Spacer()
                            Text("ÂçÉÂ∞ãÂèñÂêç")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.white)
                            Spacer()
                        }
                        .padding(.vertical, 8)
                        .background(Color.black)
                        Color.pink.frame(height: 5)
                    }.zIndex(1)
                    
                    // Content area
                    VStack(spacing: 0) {
                        Spacer()
                            .frame(height: geometry.size.height * 0.03) // Ê∏õÂ∞ëÈ†ÇÈÉ®ÈñìË∑ùÔºåÂõ†ÁÇ∫Â∑≤Á∂ìÊúâ header
                        
                        // ‰∏ªË¶ÅÂúñÁ§∫ÂçÄÂüü
                        ZStack {
                            Circle()
                                .fill(Color.white)
                                .frame(
                                    width: min(geometry.size.width * 0.9, 380),
                                    height: min(geometry.size.width * 0.9, 375)
                                )
                                .opacity(0.5)
                            
                            Image("main_mascot")
                                .resizable()
                                .scaledToFit()
                                .frame(
                                    width: min(geometry.size.width * 0.6, 260),
                                    height: min(geometry.size.width * 0.6, 260)
                                )
                        }
                        .frame(width: geometry.size.width)
                        .frame(height: geometry.size.height * 0.35)
                        
                        // ÈñãÂßãÂèñÂêçÊåâÈàï
                        Button(action: {
                            if usageManager.remainingUses > 0 {
                                // Ë®òÈåÑÈñãÂßãÂ∞éËà™
                                // NavigationErrorTracker.shared.logNavigationError(
                                //     type: "navigation_start",
                                //     details: [
                                //         "remaining_uses": "\(usageManager.remainingUses)",
                                //         "button_action": "start_naming"
                                //     ],
                                //     navigationState: "main_to_form"
                                // )
                                
                                // Ë®òÈåÑÁï∂ÂâçË∑ØÂæë
                                let currentPath = navigationPath
                                
                                // ÂòóË©¶Â∞éËà™
                                DispatchQueue.main.async {
                                    navigationPath.append("FormView")
                                }
                                
                                // Ë®≠ÂÆöÊ™¢Êü•Ë®àÊôÇÂô®
                                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                    // Âè™Âú®Â∞éËà™Â§±ÊïóÊôÇË®òÈåÑÈåØË™§
                                    if navigationPath == currentPath {
                                        // Â∞éËà™Â§±ÊïóÔºåË®òÈåÑÈåØË™§
                                        NavigationErrorTracker.shared.logNavigationError(
                                            type: "navigation_failed",
                                            details: [
                                                "error": "Navigation timeout",
                                                "current_path": "\(currentPath)",
                                                "new_path": "\(navigationPath)",
                                                "remaining_uses": "\(usageManager.remainingUses)",
                                                "device_orientation": UIDevice.current.orientation.rawValue.description,
                                                "background_refresh_status": UIApplication.shared.backgroundRefreshStatus.rawValue.description
                                            ],
                                            navigationState: "stuck_at_main"
                                        )
                                        
                                        print("‚ö†Ô∏è Navigation failed, attempting recovery...")
                                        
                                        // ÂòóË©¶ÈáçÁΩÆÂ∞éËà™
                                        // DispatchQueue.main.async {
                                        //     navigationPath = NavigationPath()
                                        //     navigationPath.append("FormView")
                                        // }
                                    }
                                }
                            } else {
                                showAlert = true
                            }
                        }) {    
                            Text("ÈñãÂßãÂèñÂêç")
                                .font(.custom("NotoSansTC-Black", size: min(32, geometry.size.width * 0.08)))
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, geometry.size.height * 0.02)
                                .cornerRadius(25)
                                .tracking(20)
                        }
                        .background(
                            Image("naming_button")
                                .resizable()
                                .scaledToFill()
                        )
                        .frame(width: geometry.size.width * 0.8)
                        .padding(.horizontal, 20)
                        .padding(.vertical, geometry.size.height * 0.03)
                        
                        Spacer()
                            .frame(height: geometry.size.height * 0.05) // ÊåâÈàïÂíå‰ΩøÁî®Ê¨°Êï∏Âç°Áâá‰πãÈñìÁöÑÈñìË∑ù
                        
                        // ‰ΩøÁî®Ê¨°Êï∏ÂíåÂª£ÂëäÊåâÈàïÂç°Áâá
                        VStack(spacing: geometry.size.height * 0.015) {
                            VStack(spacing: geometry.size.height * 0.01) {
                                Text("\(usageManager.remainingUses)")
                                    .font(.custom("NotoSansTC-Black", size: min(36, geometry.size.width * 0.09)))
                                    .foregroundColor(.customText)
                                    .bold()
                                
                                Text("Ââ©È§ò‰ΩøÁî®Ê¨°Êï∏")
                                    .font(.custom("NotoSansTC-Regular", size: min(16, geometry.size.width * 0.04)))
                                    .foregroundColor(.customText)
                            }
                            
                            Button(action: {
                                rewardedViewModel.showAd()
                            }) {
                                HStack {
                                    Image(systemName: "play.circle.fill")
                                    Text(rewardedViewModel.remainingCooldown > 0 
                                        ? "Ë´ãÁ≠âÂæÖ \(rewardedViewModel.remainingCooldown) Áßí"
                                        : "ËßÄÁúãÂª£ÂëäÁç≤Âæó3Ê¨°‰ΩøÁî®Ê©üÊúÉ")
                                        .font(.custom("NotoSansTC-Regular", size: min(16, geometry.size.width * 0.04)))
                                }
                                .foregroundColor(.customText)
                                .padding(.vertical, geometry.size.height * 0.015)
                                .padding(.horizontal, geometry.size.width * 0.04)
                                .background(Color.white.opacity(0.8))
                                .cornerRadius(25)
                            }
                            .disabled(!rewardedViewModel.isAdLoaded || rewardedViewModel.remainingCooldown > 0)
                            .opacity(rewardedViewModel.isAdLoaded && rewardedViewModel.remainingCooldown == 0 ? 1 : 0.5)
                        }
                        .padding(.vertical, geometry.size.height * 0.02)
                        .padding(.horizontal, geometry.size.width * 0.04)
                        .background(
                            RoundedRectangle(cornerRadius: 20)
                                .fill(Color.white.opacity(0.5))
                        )
                        .padding(.horizontal, geometry.size.width * 0.04)
                        
                        Spacer()
                            .frame(height: geometry.size.height * 0.05) // Banner Âª£Âëä‰∏äÊñπÁöÑÈñìË∑ù
                    }
                }
            }
        }
        .background(
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
        )
        .onAppear {
            // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈ°ØÁ§∫ÈõôÈáçÈ©óË≠âÊèêÈÜí
            if UserDefaults.standard.bool(forKey: "shouldShowTwoFactorAlert") {
                showTwoFactorAlert = true
                UserDefaults.standard.set(false, forKey: "shouldShowTwoFactorAlert")
            }
        }
        .alert("ÊèêÂçáÂ∏≥ËôüÂÆâÂÖ®", isPresented: $showTwoFactorAlert) {
            Button("Á®çÂæåÂÜçË™™") { }
            Button("ÂâçÂæÄË®≠ÂÆö") {
                selectedTab = 3  // ÂàáÊèõÂà∞Ë®≠ÂÆöÈ†ÅÈù¢
                // Ëß∏ÁôºÈõôÈáçÈ©óË≠âÊåâÈàï
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                    authViewModel.showPhoneVerification = true
                }
            }
        } message: {
            Text("Âª∫Ë≠∞ÊÇ®ÈñãÂïüÈõôÈáçÈ©óË≠â‰ª•ÊèêÂçáÂ∏≥ËôüÂÆâÂÖ®ÊÄß")
        }
    }

    private var settingsView: some View {
        VStack(spacing: 0) {
            // È†ÇÈÉ®ÂçÄÂüüÔºöÈ†≠ÂÉèÂíåÊãõÂëºË™û
            HStack(alignment: .center, spacing: 12) {
                // Áî®Êà∂È†≠ÂÉè
                if let user = Auth.auth().currentUser, let photoURL = user.photoURL {
                    AsyncImage(url: photoURL) { image in
                        image
                            .resizable()
                            .scaledToFit()
                            .frame(width: 40, height: 40)
                            .clipShape(Circle())
                    } placeholder: {
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                    }
                } else {
                    Image(systemName: "person.circle.fill")
                        .resizable()
                        .frame(width: 40, height: 40)
                        .foregroundColor(.gray)
                }
                
                // ÊãõÂëºË™û
                VStack(alignment: .leading, spacing: 4) {
                    Text("Ê≠°ËøéÂõû‰æÜ")
                        .font(.custom("NotoSansTC-Regular", size: 16))
                        .foregroundColor(.gray)
                    if let user = Auth.auth().currentUser {
                        Text(user.displayName ?? "‰ΩøÁî®ËÄÖ")
                            .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                    }
                }
                
                Spacer()
                
                // ÁôªÂá∫ÊåâÈàï
                Button(action: logOut) {
                    Image(systemName: "rectangle.portrait.and.arrow.right")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 24, height: 24)
                        .foregroundColor(.red)
                }
            }
            .padding(.horizontal, 20)
            .padding(.top, 20)
            .padding(.bottom, 10)
            
            // Main content area
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Add Security section
                    if Auth.auth().currentUser?.isAnonymous == true {
                        VStack(alignment: .leading, spacing: 15) {
                            Text("Á∂ÅÂÆöÂ∏≥Ëôü")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.customText)
                            
                            Button(action: {
                                showAccountLinkingOptions = true
                            }) {
                                SettingRow(
                                    icon: "person.badge.plus", 
                                    title: "Á∂ÅÂÆöÂ∏≥Ëôü",
                                    isLoading: isUpgrading
                                )
                            }
                            .disabled(isUpgrading)
                            .actionSheet(isPresented: $showAccountLinkingOptions) {
                                ActionSheet(
                                    title: Text("ÈÅ∏ÊìáÁ∂ÅÂÆöÊñπÂºè"),
                                    buttons: [
                                        .default(Text("‰ΩøÁî® Google Â∏≥Ëôü")) {
                                            isUpgrading = true
                                            upgradeWithGoogle()
                                        },
                                        .default(Text("‰ΩøÁî® Apple Â∏≥Ëôü")) {
                                            isUpgrading = true
                                            upgradeWithApple()
                                        },
                                        .cancel(Text("ÂèñÊ∂à"))
                                    ]
                                )
                            }
                            .tint(.customAccent) // ‰ΩøÁî® tint modifier ‰æÜË®≠ÁΩÆÊï¥ÂÄã ActionSheet ÁöÑ‰∏ªÈ°åËâ≤
                        }
                        .padding(.horizontal)
                    }

                    else {
                        VStack(alignment: .leading, spacing: 15) {
                            Text("ÂÆâÂÖ®")
                                .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                        
                            Button(action: {
                                authViewModel.showPhoneVerification = true
                            }) {
                                SettingRow(icon: "lock.shield.fill", title: authViewModel.isTwoFactorAuthenticated ? "Â∑≤ÈõôÈáçÈ©óË≠â" : "ÈõôÈáçÈ©óË≠â")
                            }
                                .opacity(authViewModel.isTwoFactorAuthenticated ? 0.6 : 1) // Â¶ÇÊûúÂ∑≤È©óË≠âÂâáÈôç‰ΩéÈÄèÊòéÂ∫¶
                                .disabled(authViewModel.isTwoFactorAuthenticated)
                        }
                        .padding(.horizontal)

                        // Êñ∞Â¢û‰ªªÂãô‰∏≠ÂøÉÂçÄÂ°ä
                        // VStack(alignment: .leading, spacing: 15) {
                        //     Text("‰ªªÂãô")
                        //         .font(.custom("NotoSansTC-Black", size: 20))
                        //         .foregroundColor(.customText)
                            
                        //     NavigationLink(destination: TaskListView()) {
                        //         SettingRow(
                        //             icon: "list.star",
                        //             title: "‰ªªÂãô‰∏≠ÂøÉ",
                        //             textColor: .customText,
                        //             badge: taskManager.tabBadgeCount > 0 ? "\(taskManager.tabBadgeCount)" : nil
                        //         )
                        //     }
                        // }
                        // .padding(.horizontal)
                    }
                    
                    
                    
                    // Ë≥áË®äÂçÄÂüü
                    VStack(alignment: .leading, spacing: 15) {
                        Text("Ë≥áË®ä")
                            .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                        
                        Button(action: {
                            if let url = URL(string: "https://moai.tw") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            SettingRow(icon: "info.circle.fill", title: "ÈóúÊñºÂçÉÂ∞ã")
                        }
                        
                        NavigationLink(destination: TermsAndPrivacyView()) {
                            SettingRow(icon: "doc.text.fill", title: "ÊúçÂãôÊ¢ùÊ¨æËàáÈö±ÁßÅÊ¨ä")
                        }
                        
                        Button(action: {
                            if let url = URL(string: "https://moai.tw") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            SettingRow(icon: "envelope.fill", title: "ËÅØÁµ°ÊàëÂÄë")
                        }
                    }
                    .padding(.horizontal)
                    
                    // Âú® settingsView ÁöÑ VStack ‰∏≠ÔºåÂú®ÊúÄÂæå‰∏ÄÂÄãÂçÄÂ°äÂæåÊ∑ªÂä†Ôºö
                    VStack(alignment: .leading, spacing: 15) {
                        Text("Â∏≥Ëôü")
                            .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                        
                        Button(action: {
                            showDeleteAccountAlert = true
                        }) {
                            SettingRow(
                                icon: "person.crop.circle.badge.minus",
                                title: "Âà™Èô§Â∏≥Ëôü",
                                textColor: .red
                            )
                        }
                    }
                    .padding(.horizontal)
                    .alert("Á¢∫Ë™çÂà™Èô§Â∏≥Ëôü", isPresented: $showDeleteAccountAlert) {
                        Button("ÂèñÊ∂à", role: .cancel) { }
                        Button("Âà™Èô§", role: .destructive) {
                            deleteAccount()
                        }
                    } message: {
                        Text("Ê≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©ÂéüÔºåÊÇ®Á¢∫ÂÆöË¶ÅÊ∞∏‰πÖÂà™Èô§ÊÇ®ÁöÑÂ∏≥ËôüÂóéÔºü")
                    }

                    
                }
                .padding(.horizontal)
                .padding(.bottom, GADAdSizeBanner.size.height + 45)
            }
        }
        // Add this sheet presentation after other .sheet modifiers in the settingsView
        .sheet(isPresented: $showSerialNumberInput) {
            SerialNumberInputView(isPresented: $showSerialNumberInput)
        }
        // Add sheet for phone verification
        .sheet(isPresented: $authViewModel.showPhoneVerification, onDismiss: {
            authViewModel.resetVerificationState()
        }) {
            NavigationView {
                VStack(spacing: 20) {
                    // Phone number input
                    CustomTextField(
                        placeholder: "Ë´ãËº∏ÂÖ•ÊâãÊ©üËôüÁ¢º",
                        text: $authViewModel.phoneNumber,
                        keyboardType: .phonePad
                    )
                    .padding(.horizontal)
                    
                    if authViewModel.canResetPhoneNumber {
                        // È°ØÁ§∫ÈáçË®≠ÊâãÊ©üËôüÁ¢ºÁöÑÈÅ∏È†Ö
                        HStack {
                            Text("ÊâãÊ©üËôüÁ¢ºËº∏ÂÖ•ÈåØË™§Ôºü")
                                .font(.custom("NotoSansTC-Regular", size: 14))
                                .foregroundColor(.gray)
                            
                            Button("ÈáçÊñ∞Ëº∏ÂÖ•ËôüÁ¢º") {
                                authViewModel.resetPhoneNumberInput()
                            }
                            .font(.custom("NotoSansTC-Regular", size: 14))
                            .foregroundColor(.customAccent)
                        }
                        .padding(.horizontal)
                    }
                    
                    if authViewModel.verificationID != nil {
                        // Verification code input
                        CustomTextField(
                            placeholder: "Ë´ãËº∏ÂÖ•È©óË≠âÁ¢º",
                            text: $authViewModel.verificationCode,
                            keyboardType: .numberPad,
                            textContentType: .oneTimeCode  // Ê∑ªÂä†ÈÄôË°å‰æÜÊîØÊåÅËá™ÂãïÂ°´ÂÖÖÁ∞°Ë®äÈ©óË≠âÁ¢º
                        )
                        .padding(.horizontal)
                        .onChange(of: authViewModel.verificationCode) { newValue in
                            // Áï∂È©óË≠âÁ¢ºÊîπËÆäÊôÇÔºåÊ™¢Êü•ÊòØÂê¶ÁÇ∫ÂæûÂâ™Ë≤ºÁ∞øË≤º‰∏äÁöÑÂÖßÂÆπ
                            if let pasteboardString = UIPasteboard.general.string,
                               pasteboardString.count == 6,  // ÂÅáË®≠È©óË≠âÁ¢ºÁÇ∫ 6 ‰ΩçÊï∏
                               pasteboardString.allSatisfy({ $0.isNumber }) {
                                authViewModel.verificationCode = pasteboardString
                            }
                        }
                        
                        // Countdown timer and resend button
                        HStack {
                            if let remainingTime = authViewModel.remainingTime {
                                Text("È©óË≠âÁ¢ºÊúâÊïàÊôÇÈñìÔºö\(remainingTime)Áßí")
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.gray)
                                
                                if remainingTime == 0 {
                                    Button("ÈáçÊñ∞ÁôºÈÄÅ") {
                                        authViewModel.sendVerificationCode()
                                    }
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.customAccent)
                                }
                            }
                        }
                        .padding(.horizontal)
                        
                        // Verify button with loading state
                        Button(action: {
                            authViewModel.verifyCode()
                        }) {
                            HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                if authViewModel.isLoading {
                                    ProgressView()
                                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                } else {
                                    Text("È©óË≠â")
                                }
                            }
                            .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                            .padding()
                            .background(authViewModel.isLoading ? Color.gray : Color.customAccent)
                            .foregroundColor(.white)
                            .cornerRadius(25)
                        }
                        .padding(.horizontal)
                        .disabled(authViewModel.isLoading)
                    } else {
                        // Send code button
                        Button(action: {
                            authViewModel.sendVerificationCode()
                        }) {
                            HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                if authViewModel.isLoading {
                                    ProgressView()
                                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                } else {
                                    Text(authViewModel.displayCooldownTime > 0 
                                        ? "Ë´ãÁ≠âÂæÖ \(authViewModel.displayCooldownTime) Áßí"
                                        : "ÁôºÈÄÅÈ©óË≠âÁ¢º")
                                }
                            }
                            .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                            .padding()
                            .background(
                                authViewModel.displayCooldownTime > 0 || authViewModel.isLoading 
                                    ? Color.gray 
                                    : Color.customAccent
                            )
                            .foregroundColor(.white)
                            .cornerRadius(25)
                        }
                        .padding(.horizontal)
                        .disabled(authViewModel.displayCooldownTime > 0 || authViewModel.isLoading)
                    }
                    
                    if let error = authViewModel.errorMessage {
                        Text(error)
                            .font(.custom("NotoSansTC-Regular", size: 14))
                            .foregroundColor(.red)
                            .padding()
                    }
                    
                    Spacer()
                }
                .padding(.top)
                .navigationTitle("ÈõôÈáçÈ©óË≠âË®≠ÂÆö")
                .navigationBarTitleDisplayMode(.inline)
                .navigationBarItems(trailing: Button("ÂèñÊ∂à") {
                    authViewModel.showPhoneVerification = false
                }
                .font(.custom("NotoSansTC-Regular", size: 16))
                )
                .onAppear {
                    authViewModel.resetVerificationState()
                }
            }
        }
        .overlay(
            Group {
                if showUpgradeError {
                    CustomAlertView(
                        title: "Á∂ÅÂÆöÂ§±Êïó",
                        message: upgradeErrorMessage ?? "",
                        isPresented: $showUpgradeError
                    )
                }
            }
        )
        // Add this sheet presentation after other .sheet modifiers in the settingsView
        .sheet(isPresented: $showSerialNumberInput) {
            SerialNumberInputView(isPresented: $showSerialNumberInput)
        }
    }
    
    

    // ‰øùÊåÅ SettingRow ÁµêÊßãÈ´î‰∏çËÆä
    struct SettingRow: View {
        let icon: String
        let title: String
        var price: String? = nil
        var textColor: Color = .customText
        var isPurchasing: Bool = false
        var isLoading: Bool = false
        var badge: String? // Êñ∞Â¢û badge ÂèÉÊï∏
        
        var body: some View {
            HStack {
                if isLoading {
                    ProgressView()
                        .scaleEffect(0.8)
                        .frame(width: 24, height: 24)
                } else {
                    Image(systemName: icon)
                        .resizable()
                        .scaledToFit()
                        .frame(width: 24, height: 24)
                        .foregroundColor(.customAccent)
                }
                
                Text(isLoading ? "Á∂ÅÂÆö‰∏≠..." : title)
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(textColor)
                
                Spacer()
                
                if isPurchasing {
                    ProgressView()
                } else if let price = price {
                    Text(price)
                        .foregroundColor(.customAccent)
                }
                
                if let badge = badge {
                    Text(badge)
                        .font(.system(size: 14))
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.customAccent)
                        .clipShape(Capsule())
                }
                
                Image(systemName: "chevron.right")
                    .font(.system(size: 14))
                    .foregroundColor(.gray)
            }
            .padding()
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
        }
    }

    // Êñ∞Â¢û Terms and Privacy View
    struct TermsAndPrivacyView: View {
        var body: some View {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    Text("ÊúçÂãôÊ¢ùÊ¨æËàáÈö±ÁßÅÊ¨äÊîøÁ≠ñ")
                        .font(.custom("NotoSansTC-Black", size: 24))
                        .padding(.bottom, 10)
                    
                    Group {
                        Text("Êë©ËâæÁßëÊäÄÊúâÈôêÂÖ¨Âè∏Èö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñ")
                            .font(.custom("NotoSansTC-Regular", size: 20))
                            .padding(.bottom, 5)
                        
                        Text("Èö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñÁöÑÂÖßÂÆπ")
                            .font(.custom("NotoSansTC-Regular", size: 18))
                        
                        Text("Êú¨Èö±ÁßÅÊ¨äÊîøÁ≠ñË™™ÊòéÊë©ËâæÁßëÊäÄÊúâÈôêÂÖ¨Âè∏(‰ª•‰∏ãË™™ÊòéÂ∞á‰ª•ÂìÅÁâåÂêçÁ®±-„ÄéÂçÉÂ∞ãÂëΩÂêç„Äè„ÄÅ„ÄéÊàëÂÄë„ÄèÊàñ„ÄéÊàëÂÄëÁöÑ„ÄèÁ∞°Á®±)ÈÄöÈÅéÊàëÂÄëÁöÑÊáâÁî®Á®ãÂºèÂèäÁ∂≤Á´ôÊî∂ÈõÜÂà∞ÁöÑË≥áË®äÔºå‰ª•ÂèäÊàëÂÄëÂ∞áÂ¶Ç‰Ωï‰ΩøÁî®ÈÄô‰∫õË≥áË®ä„ÄÇÊàëÂÄëÈùûÂ∏∏ÈáçË¶ñÊÇ®ÁöÑÈö±ÁßÅÊ¨ä„ÄÇË´ãÊÇ®Èñ±ËÆÄ‰ª•‰∏ãÊúâÈóúÈö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñÁöÑÊõ¥Â§öÂÖßÂÆπ„ÄÇ")
                            .padding(.bottom, 10)
                        
                        Group {
                            Text("ÊàëÂÄë‰ΩøÁî®ÊÇ®ÂÄã‰∫∫Ë≥áÊñôÁöÑÊñπÂºè")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("Êú¨ÊîøÁ≠ñÊ∂µËìãÁöÑÂÖßÂÆπÂåÖÊã¨ÔºöÊë©ËâæÁßëÊäÄÂ¶Ç‰ΩïËôïÁêÜËíêÈõÜÊàñÊî∂Âà∞ÁöÑÂÄã‰∫∫Ë≥áÊñô (ÂåÖÊã¨ËàáÊÇ®ÈÅéÂéª‰ΩøÁî®ÊàëÂÄëÁöÑÁî¢ÂìÅÂèäÊúçÂãôÁõ∏ÈóúÁöÑË≥áÊñôÔºâ„ÄÇÂÄã‰∫∫Ë≥áÊñôÊòØÊåáÂæó‰ª•Ë≠òÂà•ÊÇ®ÁöÑË∫´ÂàÜ‰∏îÊú™ÂÖ¨ÈñãÁöÑË≥áÊñôÔºåÂ¶ÇÂßìÂêç„ÄÅÂú∞ÂùÄ„ÄÅÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄÊàñÈõªË©±ËôüÁ¢º„ÄÇ\nÊú¨Èö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñÂè™ÈÅ©Áî®ÊñºÊë©ËâæÁßëÊäÄ")
                        }
                        
                        Group {
                            Text("Ë≥áÊñôËíêÈõÜÂèä‰ΩøÁî®ÂéüÂâá")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("Âú®ÊÇ®Ë®ªÂÜäÊë©ËâæÁßëÊäÄÊâÄÂ±¨ÁöÑÂÆòÁ∂≤„ÄÅ‰ΩøÁî®AppÁõ∏ÈóúÁî¢ÂìÅ„ÄÅÁÄèË¶ΩÊàëÂÄëÁöÑÁî¢ÂìÅÂÆòÁ∂≤ÊàñÊüê‰∫õÂêà‰ΩúÂ§•‰º¥ÁöÑÁ∂≤È†ÅÔºå‰ª•ÂèäÂèÉÂä†ÂÆ£ÂÇ≥Ê¥ªÂãïÊàñË¥àÁçéÊ¥ªÂãïÊôÇÔºåÊë©ËâæÁßëÊäÄÊúÉËíêÈõÜÊÇ®ÁöÑÂÄã‰∫∫Ë≥áÊñô„ÄÇÊë©ËâæÁßëÊäÄ‰πüÂèØËÉΩÂ∞áÂïÜÊ•≠Â§•‰º¥ÊàñÂÖ∂‰ªñ‰ºÅÊ•≠ÊâÄÊèê‰æõÁöÑÈóúÊñºÊÇ®ÁöÑË≥áË®äËàáÊë©ËâæÁßëÊäÄÊâÄÊìÅÊúâÁöÑÊÇ®ÁöÑÂÄã‰∫∫Ë≥áÊñôÁõ∏ÁµêÂêà„ÄÇ\n\nÁï∂ÊÇ®Âú®‰ΩøÁî®Êë©ËâæÁßëÊäÄÊâÄÊèê‰æõÁöÑÊúçÂãôÈÄ≤ÊúÉÂì°Ë®ªÂÜäÊôÇÔºåÊàëÂÄëÊúÉË©¢ÂïèÊÇ®ÁöÑÂßìÂêç„ÄÅÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄ„ÄÅÂá∫ÁîüÊó•Êúü„ÄÅÊÄßÂà•ÂèäÈÉµÈÅûÂçÄËôüÁ≠âË≥áÊñô„ÄÇÂú®ÊÇ®Ë®ªÂÜäÊë©ËâæÁßëÊäÄÁöÑÊúÉÂì°Â∏≥Ëôü‰∏¶ÁôªÂÖ•ÊàëÂÄëÁöÑÊúçÂãôÂæåÔºåÊàëÂÄëÂ∞±ËÉΩËæ®Âà•ÊÇ®ÁöÑË∫´ÂàÜ„ÄÇÊÇ®ÂæóËá™Áî±ÈÅ∏ÊìáÊòØÂê¶Êèê‰æõÂÄã‰∫∫Ë≥áÊñôÁµ¶ÊàëÂÄëÔºå‰ΩÜËã•ÁâπÂÆöË≥áÊñôÊ¨Ñ‰Ωç‰øÇÂ±¨ÂøÖÂ°´Ê¨Ñ‰ΩçËÄÖÔºåÊÇ®Ëã•‰∏çÊèê‰æõË©≤Á≠âË≥áÊñôÂâáÁÑ°Ê≥ï‰ΩøÁî®Áõ∏ÈóúÁöÑÊë©ËâæÁßëÊäÄÊâÄÊèê‰æõÁî¢ÂìÅÂèäÊúçÂãô„ÄÇ")
                        }
                        
                        Group {
                            Text("ÂÖ∂‰ªñÊäÄË°ìÊî∂ÈõÜË≥áË®äÁ¥∞ÁØÄ")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("‚û§ ËªüÁ°¨È´îÁõ∏ÈóúË≥áË®ä\nÊàëÂÄëÊúÉÊî∂ÈõÜË£ùÁΩÆÂ∞àÂ±¨Ë≥áË®ä (‰æãÂ¶ÇÊÇ®ÁöÑÁ°¨È´îÂûãËôü„ÄÅ‰ΩúÊ•≠Á≥ªÁµ±ÁâàÊú¨„ÄÅË£ùÁΩÆÂîØ‰∏ÄÁöÑË≠òÂà•Á¢ºÔºå‰ª•ÂèäÂåÖÊã¨ÈõªË©±ËôüÁ¢ºÂú®ÂÖßÁöÑË°åÂãïÁ∂≤Ë∑ØË≥áË®ä)„ÄÇ\n\n‚û§ Âú∞ÁêÜ‰ΩçÁΩÆË≥áË®ä\nÁï∂ÊÇ®‰ΩøÁî®APPÊúçÂãôÊôÇÔºåÊàëÂÄëÊúÉÊî∂ÈõÜ‰∏¶ËôïÁêÜÊÇ®ÂØ¶ÈöõÊâÄÂú®‰ΩçÁΩÆÁöÑÁõ∏ÈóúË≥áË®ä„ÄÇÊàëÂÄëÊúÉ‰ΩøÁî®ÂêÑÁ®ÆÊäÄË°ìÂà§Êñ∑ÊÇ®ÁöÑÊâÄÂú®‰ΩçÁΩÆÔºåÂåÖÊã¨ IP ‰ΩçÂùÄ„ÄÅGPS ÂíåÂÖ∂‰ªñÊÑüÊáâÂô®„ÄÇ\n\n‚û§ Â∞àÂ±¨ÊáâÁî®Á®ãÂºèÁ∑®Ëôü\nÊüê‰∫õÊúçÂãôÊâÄÈôÑÁöÑÂ∞àÂ±¨ÊáâÁî®Á®ãÂºèÁ∑®ËôüÔºõÁï∂ÊÇ®ÂÆâË£ùÊàñËß£Èô§ÂÆâË£ùÈÄôÈ°ûÊúçÂãôÔºåÊàñÊòØÈÄôÈ°ûÊúçÂãôÂÆöÊúüËàáÊàëÂÄëÁöÑ‰º∫ÊúçÂô®ÈÄ£Á∑öÊôÇÔºåÁ≥ªÁµ±Â∞±ÊúÉÂ∞áÈÄôÂÄãÁ∑®Ëôü‰ª•ÂèäÂÆâË£ùË≥áË®äÂÇ≥ÈÄÅÁµ¶Êë©ËâæÁßëÊäÄ„ÄÇ")
                        }
                        
                        Group {
                            Text("ÂÖíÁ´•Á∑ö‰∏äÈö±ÁßÅ‰øùË≠∑Ê≥ïÊ°à")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("ÊàëÂÄëÁöÑÊâÄÊúâÂÖíÁ´•È°ûAPPÂèäÁ∂≤Á´ôÁî¢ÂìÅÁöÜÈÅµÂÆàÂÖíÁ´•Á∑ö‰∏äÈö±ÁßÅ‰øùË≠∑Ê¢ùÊ¨æthe Children's Online Privacy Protection Act („ÄéCOPPA„Äè)ÔºåÊàëÂÄë‰∏çÊúÉÊî∂ÈõÜ‰ªª‰ΩïÊú™Êªø13Ê≠≤ÂÖíÁ´•ÁöÑÂÄã‰∫∫Ë≥áË®äÔºåÂ¶ÇÊ™¢Ê∏¨Âà∞Âπ¥ÈΩ°Â∞èÊñº13Ê≠≤ÁöÑÁõ∏ÈóúË≥áË®äÔºåÊàëÂÄëÂ∞áÂèäÊôÇÂà™Èô§Ôºå‰∏çÊúÉ‰∫à‰ª•‰øùÁïôÊàñÂÑ≤Â≠ò„ÄÇ")
                        }
                        
                        Group {
                            Text("ËÅØÁπ´ÊàëÂÄë")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("Â¶ÇÊûúÊÇ®ÊúâÈóúÊñºÊú¨Èö±ÁßÅÊ¨äÁöÑ‰ªª‰ΩïÂïèÈ°åÊàñÁñëÊÖÆÔºåË´ãËÅØÁπ´ÊàëÂÄëÔºõÊàëÂÄëÊúÉÁõ°Âø´ÂõûË¶ÜÊÇ®Ôºömoai@moai.tw")
                                .padding(.bottom, 20)
                        }
                    }
                }
                .padding()
            }
            .navigationBarTitle("ÊúçÂãôÊ¢ùÊ¨æËàáÈö±ÁßÅÊ¨ä", displayMode: .inline)
        }
    }

    private func logOut() {
        do {
            // Check if current user is anonymous
            if let user = Auth.auth().currentUser {
                if user.isAnonymous {
                    print("üë§ Deleting anonymous user account")
                    // Delete user data from Firestore first
                    let db = Firestore.firestore()
                    db.collection("users").document(user.uid).delete { error in
                        if let error = error {
                            print("‚ùå Error deleting Firestore data: \(error.localizedDescription)")
                        } else {
                            print("‚úÖ Firestore data deleted successfully")
                        }
                        
                        // Then delete the anonymous user account
                        user.delete { error in
                            if let error = error {
                                print("‚ùå Error deleting anonymous user: \(error.localizedDescription)")
                            } else {
                                print("‚úÖ Anonymous user deleted successfully")
                            }
                        }
                    }
                }
            }

            try Auth.auth().signOut()
            // Reset UI state after logout
            authViewModel.isLoggedIn = false
            authViewModel.isTwoFactorAuthenticated = false
            selectedTab = 0
            navigationPath = NavigationPath()
            
        } catch let signOutError as NSError {
            print("‚ùå Error signing out: \(signOutError)")
        }
    }

    private func deleteAccount() {
        guard let user = Auth.auth().currentUser else { return }
        
        // Âà™Èô§ Firestore ‰∏≠ÁöÑÁî®Êà∂Ë≥áÊñô
        let db = Firestore.firestore()
        db.collection("users").document(user.uid).delete { error in
            if let error = error {
                print("‚ùå Âà™Èô§ Firestore Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
            }
        }
        
        // Âà™Èô§ Authentication ‰∏≠ÁöÑÁî®Êà∂
        user.delete { error in
            if let error = error as NSError? {
                // ËôïÁêÜÈúÄË¶ÅÈáçÊñ∞È©óË≠âÁöÑÊÉÖÊ≥Å
                if error.code == AuthErrorCode.requiresRecentLogin.rawValue {
                    print("‚ö†Ô∏è ÈúÄË¶ÅÈáçÊñ∞È©óË≠âÂæåÊâçËÉΩÂà™Èô§Â∏≥Ëôü")
                    // ÂèØ‰ª•Âú®ÈÄôË£°Ê∑ªÂä†ÈáçÊñ∞È©óË≠âÁöÑÈÇèËºØ
                    // Âà™Èô§ÊàêÂäüÔºåÊõ¥Êñ∞ UI
                    authViewModel.isLoggedIn = false
                    selectedTab = 0
                    navigationPath = NavigationPath()
                    return
                }
                print("‚ùå Âà™Èô§Â∏≥ËôüÂ§±Êïó: \(error.localizedDescription)")
                return
            }
            
            // Âà™Èô§ÊàêÂäüÔºåÊõ¥Êñ∞ UI
            authViewModel.isLoggedIn = false
            selectedTab = 0
            navigationPath = NavigationPath()
        }
    }
    
    private func upgradeWithGoogle() {
        guard let clientID = FirebaseApp.app()?.options.clientID else { 
            isUpgrading = false
            return 
        }
        
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.windows.first,
              let rootViewController = window.rootViewController else {
            return
        }
        
        GIDSignIn.sharedInstance.signIn(withPresenting: rootViewController) { result, error in
            if let error = error {
                print("‚ùå Google Á∂ÅÂÆöÈåØË™§: \(error.localizedDescription)")
                isUpgrading = false
                return
            }
            
            guard let user = result?.user,
                  let idToken = user.idToken?.tokenString else {
                return
            }
            
            let credential = GoogleAuthProvider.credential(withIDToken: idToken, accessToken: user.accessToken.tokenString)
            
            Auth.auth().currentUser?.link(with: credential) { [self] authResult, error in
                if let error = error as NSError? {
                    // ËôïÁêÜÁâπÂÆöÈåØË™§È°ûÂûã
                    let errorMessage: String
                    switch error.code {
                    case AuthErrorCode.emailAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.credentialAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.providerAlreadyLinked.rawValue:
                        errorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Google Â∏≥Ëôü"
                    default:
                        errorMessage = error.localizedDescription
                    }
                    DispatchQueue.main.async {
                        isUpgrading = false
                        upgradeErrorMessage = errorMessage
                        showUpgradeError = true
                    }
                    return
                }
                
                // Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñô
                let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest()
                changeRequest?.displayName = user.profile?.name
                changeRequest?.photoURL = user.profile?.imageURL(withDimension: 200)
                
                changeRequest?.commitChanges { error in
                    if let error = error {
                        print("‚ùå Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
                    } else {
                        print("‚úÖ Áî®Êà∂Ë≥áÊñôÊõ¥Êñ∞ÊàêÂäü")
                    }
                    
                    print("‚úÖ Â∏≥ËôüÂçáÁ¥öÊàêÂäü")
                    isUpgrading = false
                    // Ëß∏Áôº UI Êõ¥Êñ∞
                    authViewModel.handleSuccessfulLogin()
                }
            }
        }
    }
    
    private func upgradeWithApple() {
        isUpgrading = true
        appleSignInCoordinator = AppleSignInCoordinator()
        
        appleSignInCoordinator?.startSignInWithAppleFlow { result in
            defer {
                DispatchQueue.main.async {
                    isUpgrading = false
                }
            }
            
            switch result {
            case .success(_):
                self.handleSuccessfulUpgrade()
                
            case .failure(let error):
                DispatchQueue.main.async {
                    if let authError = error as? NSError {
                        // Firebase Auth errors
                        switch authError.code {
                        case AuthErrorCode.emailAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.credentialAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.providerAlreadyLinked.rawValue:
                            upgradeErrorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Apple Â∏≥Ëôü"
                        case AuthErrorCode.invalidCredential.rawValue:
                            upgradeErrorMessage = "ÁÑ°ÊïàÁöÑÊÜëË≠â"
                        case AuthErrorCode.operationNotAllowed.rawValue:
                            upgradeErrorMessage = "Ê≠§Êìç‰Ωú‰∏çË¢´ÂÖÅË®±"
                        case AuthErrorCode.tooManyRequests.rawValue:
                            upgradeErrorMessage = "Ë´ãÊ±ÇÊ¨°Êï∏ÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶"
                        case AuthErrorCode.networkError.rawValue:
                            upgradeErrorMessage = "Á∂≤Ë∑ØÈÄ£Á∑öÈåØË™§ÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÁãÄÊÖã"
                        case AuthErrorCode.userDisabled.rawValue:
                            upgradeErrorMessage = "Ê≠§Â∏≥ËôüÂ∑≤Ë¢´ÂÅúÁî®"
                        case AuthErrorCode.requiresRecentLogin.rawValue:
                            upgradeErrorMessage = "ÈúÄË¶ÅÈáçÊñ∞ÁôªÂÖ•ÊâçËÉΩÂü∑Ë°åÊ≠§Êìç‰Ωú"
                        default:
                            // Â¶ÇÊûúÊòØ Apple Sign In ÁöÑÈåØË™§
                            if let asError = error as? ASAuthorizationError {
                                switch asError.code {
                                case .canceled:
                                    upgradeErrorMessage = "‰ΩøÁî®ËÄÖÂèñÊ∂àÁ∂ÅÂÆö"
                                case .invalidResponse:
                                    upgradeErrorMessage = "‰º∫ÊúçÂô®ÂõûÊáâÁÑ°Êïà"
                                case .notHandled:
                                    upgradeErrorMessage = "ÁÑ°Ê≥ïËôïÁêÜÊ≠§Ë´ãÊ±Ç"
                                case .failed:
                                    upgradeErrorMessage = "Á∂ÅÂÆöÂ§±Êïó"
                                default:
                                    upgradeErrorMessage = error.localizedDescription
                                }
                            } else {
                                upgradeErrorMessage = error.localizedDescription
                            }
                        }
                        self.showUpgradeError = true
                    }
                }
            }
        }
    }
    
    // Â¶ÇÊûúÈúÄË¶ÅÈÄ£ÁµêÂ∏≥ËôüÁöÑË©±ÔºåÂèØ‰ª•Ê∑ªÂä†ÈÄôÂÄãËºîÂä©ÊñπÊ≥ï
    private func linkAccount(with credential: AuthCredential) {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå ÁÑ°Ê≥ïÈÄ£ÁµêÂ∏≥ËôüÔºöÊú™ÊâæÂà∞Áï∂ÂâçÁî®Êà∂")
            return
        }
        
        user.link(with: credential) { authResult, error in
            if let error = error {
                print("‚ùå Â∏≥ËôüÈÄ£ÁµêÂ§±Êïó: \(error.localizedDescription)")
                DispatchQueue.main.async {
                    self.upgradeErrorMessage = error.localizedDescription
                }
                return
            }
            
            print("‚úÖ Â∏≥ËôüÈÄ£ÁµêÊàêÂäü")
            // ÂèØ‰ª•Âú®ÈÄôË£°Ê∑ªÂä†ÂÖ∂‰ªñÊàêÂäüÂêéÁöÑËôïÁêÜÈÇèËºØ
        }
    }

    // Âú® upgradeWithGoogle Âíå upgradeWithApple ÊñπÊ≥ïÊàêÂäüÂêéÊ∑ªÂä†
    private func handleSuccessfulUpgrade() {
        isUpgrading = false
        
        // ËΩâÁßªÂåøÂêçÁî®Êà∂ÁöÑ‰ΩøÁî®Ê¨°Êï∏
        UsageManager.shared.transferAnonymousUses()
        
        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await UsageManager.shared.updateCloudData()
        }
        
        // Ëß¶Âèë UI Êõ¥Êñ∞
        authViewModel.handleSuccessfulLogin()
        
        // ‰øùÂ≠òÊñ∞ÁöÑËÆ§ËØÅÁä∂ÊÄÅ
        UserDefaults.standard.set(false, forKey: "isAnonymousUser")
    }
}

// authViewModel.isLoggedIn = false
// selectedTab = 0
// navigationPath = NavigationPath()

// Updated TabBarButton view
struct TabBarButton: View {
    let imageName: String
    let isSelected: Bool
    let action: () -> Void
    var badgeCount: Int? // Êñ∞Â¢û badge Êï∏ÈáèÂèÉÊï∏
    
    var body: some View {
        Button(action: action) {
            ZStack {
                Image(imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 40, height: 40)
                .foregroundColor(isSelected ? .customAccent : .gray)
                
                // Badge View
                if let count = badgeCount, count > 0 {
                    Text("\(count)")
                        .font(.system(size: 12))
                        .foregroundColor(.white)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.customAccent)
                        .clipShape(Capsule())
                        .offset(x: 12, y: -12)
                }
            }
        }
        .frame(width: 40, height: 40)
    }
}


struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

struct FormView: View {
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int
    @Binding var isLoggedIn: Bool
    @ObservedObject var authViewModel: AuthViewModel
    @State private var surname = ""
    @State private var middleName = ""
    @State private var numberOfNames = 2
    @State private var isBorn = false
    @State private var birthDate = Date()
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var gender = "Êú™Áü•"
    @Environment(\.colorScheme) var colorScheme
    
    // 2. ‰øÆÊîπÂàùÂßãÂåñÊñπÊ≥ï‰ª•ÂåπÈÖçË™øÁî®
    init(navigationPath: Binding<NavigationPath>,
         selectedTab: Binding<Int>,
         isLoggedIn: Binding<Bool>,
         authViewModel: AuthViewModel) {
        self._navigationPath = navigationPath
        self._selectedTab = selectedTab
        self._isLoggedIn = isLoggedIn
        self.authViewModel = authViewModel
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Add tap gesture to the background
                Color.clear
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .contentShape(Rectangle())
                    .onTapGesture {
                        hideKeyboard()
                    }
                
                VStack(spacing: 0) {
                    ScrollView {
                        VStack(spacing: -10) {
                            FormHeaderView()
                            FormFieldsView(
                                surname: $surname,
                                middleName: $middleName,
                                numberOfNames: $numberOfNames,
                                gender: $gender,
                                isBorn: $isBorn,
                                birthDate: $birthDate
                            )
                        }
                    }
                    
                    BottomButtonView(action: validateAndProceed)
                }
            }
            .background(
                Image("background")
                    .resizable()
                    .scaledToFill()
                    .edgesIgnoringSafeArea(.all)
            )
            .navigationBarSetup(navigationPath: $navigationPath)
            .alert("ÊèêÁ§∫", isPresented: $showAlert) {
                Button("Á¢∫ÂÆö", role: .cancel) { }
            } message: {
                Text(alertMessage)
            }
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                      to: nil, from: nil, for: nil)
    }
    
    private func validateAndProceed() {
        // Validate all required fields
        if surname.isEmpty {
            alertMessage = "Ë´ãËº∏ÂÖ•ÂßìÊ∞è"
            showAlert = true
        } else if surname.count > 2 {
            alertMessage = "ÂßìÊ∞è‰∏çËÉΩË∂ÖÈÅéÂÖ©ÂÄãÂ≠ó"
            showAlert = true
        } else if middleName.count > 1 {
            alertMessage = "‰∏≠ÈñìÂ≠ó‰∏çËÉΩË∂ÖÈÅé‰∏ÄÂÄãÂ≠ó"
            showAlert = true
        } else {
            let formData = FormData(surname: surname, middleName: middleName, numberOfNames: numberOfNames, isBorn: isBorn, birthDate: birthDate, gender: gender)
            withAnimation(nil) {
                navigationPath.append(formData)
            }
        }
    }
}

// Header View
private struct FormHeaderView: View {
    var body: some View {
        HStack(alignment: .top, spacing: 10) {
            Image("login_mascot")
                .resizable()
                .scaledToFit()
                .frame(width: 100, height: 100)
            
            VStack(alignment: .leading) {
                Text("ÈÄÅÁµ¶Â≠©Â≠êÁöÑÁ¨¨‰∏Ä‰ªΩÁ¶ÆÁâ©\nÂ∞±ÊòØÁÇ∫Â≠©Â≠êÂèñÂêçÂ≠óÔºÅ")
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(.black)
                    .padding(12)
                    .background(Color.white)
                    .cornerRadius(15)
                    .overlay(
                        Triangle()
                            .fill(Color.white)
                            .frame(width: 20, height: 20)
                            .rotationEffect(.degrees(-90))
                            .offset(x: -15, y: 10)
                        , alignment: .topLeading
                    )
            }
        }
        .padding()
    }
}

// Form Fields View
private struct FormFieldsView: View {
    @Binding var surname: String
    @Binding var middleName: String
    @Binding var numberOfNames: Int
    @Binding var gender: String
    @Binding var isBorn: Bool
    @Binding var birthDate: Date
    @State private var showMiddleNameAlert = false
    
    var body: some View {
        VStack(spacing: 15) {
            // Add required field indicator for surname
            VStack(alignment: .leading, spacing: 5) {
                CustomTextField(
                    placeholder: "ÂßìÊ∞èÔºàÂøÖÂ°´Ôºâ", 
                    text: $surname
                )
            }
            
            // Add optional field indicator for middle name
            CustomTextField(
                placeholder: numberOfNames == 1 ? "ÂñÆÂêç‰∏çÂæóË®≠ÂÆö‰∏≠ÈñìÂ≠ó" : "ÊåáÂÆö‰∏≠ÈñìÂ≠óÔºàÈÅ∏Â°´Ôºâ", 
                text: $middleName
            )
            .disabled(numberOfNames == 1)
            .onChange(of: numberOfNames) { newValue in
                if newValue == 1 && !middleName.isEmpty {
                    showMiddleNameAlert = true
                    middleName = ""  // Ê∏ÖÁ©∫‰∏≠ÈñìÂ≠ó
                }
            }
            .alert(isPresented: $showMiddleNameAlert) {
                Alert(
                    title: Text("ÊèêÁ§∫"),
                    message: Text("ÂñÆÂêç‰∏çÂæóË®≠ÂÆö‰∏≠ÈñìÂ≠ó"),
                    dismissButton: .default(Text("Á¢∫ÂÆö"))
                )
            }
            
            NameCountSelector(numberOfNames: $numberOfNames)
            GenderSelector(gender: $gender)
            BirthInfoView(isBorn: $isBorn, birthDate: $birthDate)
        }
        .padding()
    }
}

// Name Count Selector
private struct NameCountSelector: View {
    @Binding var numberOfNames: Int
    
    var body: some View {
        HStack(spacing: 0) {
            Button(action: { 
                hideKeyboard()
                numberOfNames = 1 
            }) {
                Text("ÂñÆÂêç")
                    .foregroundColor(numberOfNames == 1 ? .white : Color(hex: "#FF798C"))
                    .frame(width: 100)
                    .padding(.vertical, 10)
                    .background(numberOfNames == 1 ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
            }
            Button(action: { 
                hideKeyboard()
                numberOfNames = 2 
            }) {
                Text("ÈõôÂêç")
                    .foregroundColor(numberOfNames == 2 ? .white : Color(hex: "#FF798C"))
                    .frame(width: 100)
                    .padding(.vertical, 10)
                    .background(numberOfNames == 2 ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
            }
        }
        .background(Color(hex: "#FFE5E9"))
        .cornerRadius(20)
        .overlay(
            RoundedRectangle(cornerRadius: 20)
                .stroke(Color(hex: "#FF798C"), lineWidth: 1)
        )
    }
}

// Gender Selector
private struct GenderSelector: View {
    @Binding var gender: String
    
    var body: some View {
        HStack(spacing: 0) {
            ForEach(["Áî∑", "Â•≥", "Êú™Áü•"], id: \.self) { option in
                Button(action: { 
                    hideKeyboard()
                    gender = option 
                }) {
                    Text(option)
                        .foregroundColor(gender == option ? .white : Color(hex: "#FF798C"))
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 10)
                        .background(gender == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                }
            }
        }
        .background(Color(hex: "#FFE5E9"))
        .cornerRadius(20)
        .overlay(
            RoundedRectangle(cornerRadius: 20)
                .stroke(Color(hex: "#FF798C"), lineWidth: 1)
        )
    }
}

// Birth Info View
private struct BirthInfoView: View {
    @Binding var isBorn: Bool
    @Binding var birthDate: Date
    
    var body: some View {
        VStack(spacing: 15) {
            Toggle("Êú™/Â∑≤Âá∫Áîü", isOn: $isBorn)
                .padding()
                .background(Color.white)
                .foregroundColor(.black)
                .cornerRadius(25)
                .toggleStyle(CustomToggleStyle(onColor: Color(hex: "#FF798C")))
                .onTapGesture {
                    hideKeyboard()
                }
            
            if isBorn {
                DatePicker(
                    "Âá∫ÁîüÊó•Êúü",
                    selection: $birthDate,
                    in: ...Date(),
                    displayedComponents: [.date]
                )
                .datePickerStyle(.compact)
                .padding()
                .background(Color.white)
                .cornerRadius(25)
                .overlay(
                    RoundedRectangle(cornerRadius: 25)
                        .stroke(Color(hex: "#FF798C"), lineWidth: 1)
                )
                .onTapGesture {
                    hideKeyboard()
                }
            }
        }
    }
}

// Bottom Button View
private struct BottomButtonView: View {
    let action: () -> Void
    
    var body: some View {
        VStack {
            Button(action: {
                hideKeyboard()
                action()
            }) {
                Text("‰∏ã‰∏ÄÊ≠•")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color(hex: "#FF798C"))
                    .cornerRadius(25)
            }
            .padding()
        }
        .background(Color.clear) // ÊîπÁÇ∫ÈÄèÊòéËÉåÊôØ
        .ignoresSafeArea(.keyboard)
    }
}

// Navigation Bar Setup
extension View {
    func navigationBarSetup(navigationPath: Binding<NavigationPath>) -> some View {
        self
            .navigationBarTitle("Ë≥áÊñôÂ°´ÂØ´", displayMode: .inline)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        navigationPath.wrappedValue.removeLast()
                    }) {
                        Image(systemName: "chevron.left")
                            .foregroundColor(.white)
                    }
                }
                ToolbarItem(placement: .principal) {
                    Text("Ë≥áÊñôÂ°´ÂØ´")
                        .font(.custom("NotoSansTC-Black", size: 20))
                        .foregroundColor(.white)
                }
            }
            .toolbarBackground(.visible, for: .navigationBar)
            .toolbarBackground(Color.black, for: .navigationBar)
            .toolbarColorScheme(.dark, for: .navigationBar)
            .navigationBarBackButtonHidden(true)
            .navigationBarTitleDisplayMode(.inline)
            .overlay(
                Color.pink.frame(height: 5)
                    .edgesIgnoringSafeArea(.horizontal)
                    .offset(y: 0)
                , alignment: .top
            )
    }
}

struct FormData: Hashable {
    let surname: String
    let middleName: String
    let numberOfNames: Int
    let isBorn: Bool
    let birthDate: Date
    let gender: String
}

struct DialogView: View {
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int  // Êñ∞Â¢ûÈÄôË°å
    let formData: FormData
    @State private var questions: [Question] = []
    @State private var currentQuestionIndex = 0
    @State private var answers: [String] = []
    @State private var isGeneratingName = false
    @State private var generatedName: String?
    @State private var nameAnalysis: [String: String]?
    @State private var wuxing: [String]?
    @Environment(\.colorScheme) var colorScheme
    @State private var errorMessage: String?
    // Add state variable
    @State private var shouldDismissOnTap = false
    
    private let usageManager = UsageManager.shared
    
    // Add a state to track if generation is in progress
    @State private var isGenerating = false
    
    // ‰øÆÊîπÂàùÂßãÂåñÊñπÊ≥ï
    init(navigationPath: Binding<NavigationPath>,
         selectedTab: Binding<Int>,  // Êñ∞Â¢ûÈÄôË°å
         formData: FormData) {
        self._navigationPath = navigationPath
        self._selectedTab = selectedTab  // Êñ∞Â¢ûÈÄôË°å
        self.formData = formData
    }
    
    var body: some View {
        ZStack {
            // Color(hex: "#FFF0F5") // Light pink background
            //     .edgesIgnoringSafeArea(.all)

            if isGeneratingName {
                // LoadingView()
                VStack {
                    ProgressView("ÁîüÊàêÊôÇÈñìÁ¥Ñ‰∏âÂçÅÁßí")
                        .scaleEffect(1.5)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let errorMessage = errorMessage {
                VStack {
                    Text("ÁîüÊàêÂêçÂ≠óÂ§±Êïó")
                        .font(.custom("NotoSansTC-Black", size: 24))
                        .foregroundColor(.red)
                        .padding()
                
                    Text(errorMessage)
                        .font(.custom("NotoSansTC-Regular", size: 18))
                        .foregroundColor(.customText)
                        .multilineTextAlignment(.center)
                        .padding()
                    
                    // Only show retry button if user has remaining uses
                    if usageManager.remainingUses > 0 {
                        Button("ÈáçË©¶") {
                            self.errorMessage = nil
                            generateName()  // This will deduct another point
                        }
                        .font(.custom("NotoSansTC-Regular", size: 18))
                        .foregroundColor(.white)
                        .padding()
                        .background(.customAccent)
                        .cornerRadius(10)
                        .onAppear { shouldDismissOnTap = false }
                    } else {
                        Text("ÊÇ®ÁöÑ‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆåÔºåË´ãËßÄÁúãÂª£ÂëäÁç≤ÂèñÊõ¥Â§öÊ¨°Êï∏„ÄÇ")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                            .padding()
                        
                        Button(action: {
                            navigationPath.removeLast(navigationPath.count)
                        }) {
                            Text("ÂõûÂà∞È¶ñÈ†Å")
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.white)
                                .padding(.horizontal, 20)
                                .padding(.vertical, 10)
                        }
                        .background(.customAccent)
                        .cornerRadius(10)
                        .padding(.top, 10)
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .contentShape(Rectangle())
                .onTapGesture {
                    if shouldDismissOnTap {
                        navigationPath.removeLast(navigationPath.count)
                    }
                }
            } else if let generatedName = generatedName, let nameAnalysis = nameAnalysis, let wuxing = wuxing {
                NameAnalysisView(
                    name: generatedName,
                    analysis: nameAnalysis,
                    wuxing: wuxing,
                    navigationPath: $navigationPath,
                    selectedTab: $selectedTab,  // ‰ΩøÁî®ÂÇ≥ÂÖ•ÁöÑ selectedTab
                    regenerateAction: generateName,
                    showButtons: true
                )
            } else {
                VStack(spacing: -10) {
                    if !questions.isEmpty {
                        VStack(spacing: 10) {
                            HStack(alignment: .center, spacing: 10) {
                                Image("main_mascot")
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: 120, height: 120)
                                    
                                // Question progress indicators
                                HStack(spacing: 8) {
                                    ForEach(0..<questions.count, id: \.self) { index in
                                        Button(action: {
                                            currentQuestionIndex = index
                                        }) {
                                            Text("\(index + 1)")
                                                .font(.custom("NotoSansTC-Black", size: 16))
                                                .foregroundColor(index == currentQuestionIndex ? .white : .customAccent)
                                                .frame(width: 30, height: 30)
                                                .background(
                                                    Circle()
                                                        .fill(index == currentQuestionIndex ? Color.customAccent : Color.white)
                                                )
                                                .overlay(
                                                    Circle()
                                                        .stroke(Color.customAccent, lineWidth: 1)
                                                )
                                        }
                                        .disabled(index > answers.count) // Âè™ËÉΩÈÅ∏ÊìáÂ∑≤ÂõûÁ≠îÈÅéÁöÑÈ°åÁõÆÊàñ‰∏ã‰∏ÄÈ°å
                                    }
                                }
                                .padding()
                                .background(Color.white.opacity(0.7))
                                .cornerRadius(10)

                                Spacer()
                            }

                            Text(questions[currentQuestionIndex].question)
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.customText)
                                .multilineTextAlignment(.leading)
                                .padding()
                                .background(Color.white.opacity(0.7))
                                .cornerRadius(10)
                        }
                        .padding()

                        Spacer()

                        // Choices
                        VStack(spacing: 15) {
                            ForEach(questions[currentQuestionIndex].choices, id: \.self) { choice in
                                Button(action: {
                                    handleAnswer(choice.text)
                                }) {
                                    Text(choice.text)
                                        .font(.custom("NotoSansTC-Black", size: 16))
                                        .foregroundColor(.customText)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                        .multilineTextAlignment(.leading)
                                        .padding()
                                        .background(
                                            answers.count > currentQuestionIndex && 
                                            answers[currentQuestionIndex] == choice.text ? 
                                                Color.customAccent.opacity(0.2) : Color.white
                                        )
                                        .cornerRadius(20)
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 20)
                                                .stroke(Color.customAccent, lineWidth: 1)
                                        )
                                }
                            }
                        }
                        .padding()

                        Spacer()
                        
                        // Navigation buttons
                        HStack {
                            if currentQuestionIndex > 0 {
                                Button("‰∏ä‰∏ÄÈ°å") {
                                    currentQuestionIndex -= 1
                                }
                                .buttonStyle(NavigationButtonStyle())
                            }
                            
                            Spacer()
                            
                            if answers.count == questions.count {
                                Button("ÂÆåÊàê") {
                                    generateName()
                                }
                                .buttonStyle(NavigationButtonStyle(isPrimary: true))
                            } else if currentQuestionIndex < questions.count - 1 {
                                Button("‰∏ã‰∏ÄÈ°å") {
                                    currentQuestionIndex += 1
                                }
                                .buttonStyle(NavigationButtonStyle())
                                .disabled(answers.count <= currentQuestionIndex)
                            }
                        }
                        .padding()
                    }
                    else {
                        VStack(spacing: 16) {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .font(.system(size: 40))
                                .foregroundColor(.orange)
                            
                            Text("ÁÑ°Ê≥ïËºâÂÖ•ÂïèÈ°å")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.customText)
                            
                            Text("Ë´ãÊ™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑öÂæåÈáçË©¶")
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        .padding()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }
                }
                .padding()
            }
        }
        .navigationBarTitle("ÂøÉÈùàÂ∞çË©±", displayMode: .inline)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                Button(action: {
                    navigationPath.removeLast()
                }) {
                    Image(systemName: "chevron.left")
                        .foregroundColor(.white)
                }
            }
            ToolbarItem(placement: .principal) {
                Text(isGeneratingName ? "ÁîüÊàêÂêçÂ≠ó‰∏≠" : (generatedName != nil ? "ÂêçÂ≠óÂàÜÊûê" : "ÂøÉÈùàÂ∞çË©±"))
                    .font(.custom("NotoSansTC-Black", size: 20))
                    .foregroundColor(.white)
            }
        }
        .toolbarBackground(.visible, for: .navigationBar)
        .toolbarBackground(Color.black, for: .navigationBar)
        .toolbarColorScheme(.dark, for: .navigationBar)
        .navigationBarBackButtonHidden(true)
        .navigationBarTitleDisplayMode(.inline)
        .overlay(
            Color.pink.frame(height: 5)
                .edgesIgnoringSafeArea(.horizontal)
                .offset(y: 0) // Adjust this value if needed to position the line correctly
            , alignment: .top
        )
        .onAppear(perform: loadQuestions)
        .background(
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
        )
    }

    
    private func loadQuestions() {
        // Clear previous answers
        answers.removeAll()
        
        // Get questions from local cache
        questions = QuestionManager.shared.getRandomQuestions(5)
    }
    
    private func generateName() {
        // Add a guard to prevent multiple generations
        let monitor = PerformanceMonitor.shared
        monitor.reset()
        monitor.start("Total Generation Time")
        
        guard !isGenerating else { return }
        
        print("\n=== ÈñãÂßãÁîüÊàêÂêçÂ≠óÊµÅÁ®ã ===")
        monitor.start("Usage Check")
        print("üì± [Generate] ÈñãÂßãÁîüÊàêÂêçÂ≠óË´ãÊ±Ç")
        print("üìä [Uses] ÁîüÊàêÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")
        
        // Check remaining uses before generating
        if usageManager.remainingUses <= 0 {
            monitor.end("Usage Check")
            print("‚ùå [Generate] ‰ΩøÁî®Ê¨°Êï∏‰∏çË∂≥ÔºåÁÑ°Ê≥ïÁîüÊàê")
            errorMessage = "ÂæàÊä±Ê≠âÔºåÊÇ®ÁöÑÂÖçË≤ª‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆå„ÄÇ"
            return
        }
        monitor.end("Usage Check")
        
        // Set generating flag
        isGenerating = true
        
        // Deduct one use
        usageManager.remainingUses -= 1
        print("üìä [Uses] Êâ£Èô§‰∏ÄÊ¨°‰ΩøÁî®Ê©üÊúÉ")
        print("üìä [Uses] Áï∂ÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await usageManager.updateCloudData()
        }
        
        monitor.start("UI Update - Loading")
        isGeneratingName = true
        errorMessage = nil
        monitor.end("UI Update - Loading")

        // Prepare the prompt for the AI model
        monitor.start("Prompt Preparation")
        let prompt = preparePrompt()
        monitor.end("Prompt Preparation")

        // Call the OpenAI API to generate the name
        Task {
            do {
                print("ü§ñ [API] ÈñãÂßãË™øÁî® OpenAI API")
                monitor.start("API Call")
                print("üìù [Prompt] Ë™øÁî® OpenAI API ÁöÑ prompt: \(prompt)")
                let (name, analysis, wuxing) = try await callOpenAIAPI(with: prompt)
                monitor.end("API Call")
                print("‚úÖ [API] API Ë™øÁî®ÊàêÂäü")
                print("üìù [Result] ÁîüÊàêÁöÑÂêçÂ≠ó: \(name)")
                
                await MainActor.run {
                    monitor.start("UI Update - Results")
                    self.generatedName = name
                    self.nameAnalysis = analysis
                    self.wuxing = wuxing
                    self.isGeneratingName = false
                    self.isGenerating = false
                    monitor.end("UI Update - Results")
                    
                    print("‚úÖ [Generate] Â≠óÁîüÊàêÊµÅÁ®ãÂÆåÊàê")
                    monitor.end("Total Generation Time")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü ===\n")
                }
            } catch {
                await MainActor.run {
                    monitor.start("Error Handling")
                    self.isGeneratingName = false
                    self.isGenerating = false
                    if let nsError = error as NSError? {
                        self.errorMessage = "ÁîüÊàêÂêçÂ≠óÊôÇÁôºÁîüÈåØË™§Ôºö\(nsError.localizedDescription)"
                    } else {
                        self.errorMessage = "ÁîüÊàêÂêçÂ≠óÊôÇÁôºÁîüÊú™Áü•ÈåØË™§„ÄÇË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
                    }
                    monitor.end("Error Handling")
                    
                    print("‚ùå [Generate] ÂêçÂ≠óÁîüÊàêÊµÅÁ®ãÂ§±Êïó")
                    monitor.end("Total Generation Time")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü ===\n")
                }
            }
        }
    }
    
    private func preparePrompt() -> String {
        let formData = """
        ÂßìÊ∞è: \(formData.surname)
        ÊåáÂÆö‰∏≠ÈñìÂ≠ó: \(formData.middleName)
        ÂñÆ/ÈõôÂêç: \(formData.numberOfNames == 1 ? "ÂñÆÂêç" : "ÈõôÂêç")
        ÊÄßÂà•: \(formData.gender)
        """
        
        let meaningString: String
        do {
            print("üìù [Meanings] ÈñãÂßãËôïÁêÜÂõûÁ≠îÊÑèÁæ©")
            meaningString = try answers.enumerated().map { index, answer in
                guard index < questions.count,
                      let selectedChoice = questions[index].choices.first(where: { $0.text == answer }) else {
                    throw NSError(domain: "MeaningMapping", code: 1, userInfo: [NSLocalizedDescriptionKey: "ÁÑ°Ê≥ïÊâæÂà∞Â∞çÊáâÁöÑÊÑèÁæ©"])
                }
                return """
                ÊúüË®±\(index + 1): \(selectedChoice.meaning)
                """
            }.joined(separator: "\n\n")
        } catch {
            print("Error mapping meanings: \(error)")
            meaningString = "Error processing meanings"
        }

        // ‰ΩøÁî® PromptManager Áç≤ÂèñÊ®°Êùø
        let template = PromptManager.shared.getNameGenerationPrompt()

        print("üîÑ [Prompts] ‰ΩøÁî® PromptManager Áç≤ÂèñÊ®°Êùø: \(template)")
        
        // Â∞áË≥áÊñôÂ°´ÂÖ•Ê®°Êùø
        return template
            .replacingOccurrences(of: "{{formData}}", with: formData)
            .replacingOccurrences(of: "{{meaningString}}", with: meaningString)
    }

    // 1. È¶ñÂÖàÂÆöÁæ©ÊâÄÈúÄÁöÑ JSON Schema
    private func createNameGenerationSchema() -> JSONSchema {
        // ÊÉÖÂ¢ÉÂàÜÊûêÁöÑ Schema
        let situationalAnalysisSchema = JSONSchema(
            type: .object,
            properties: [
                "question": JSONSchema(type: .string),
                "answer": JSONSchema(type: .string),
                "analysis": JSONSchema(type: .string)
            ],
            required: ["question", "answer", "analysis"],
            additionalProperties: false
        )

        // ÂÖ∏ÊïÖÂàÜÊûêÁöÑ Schema
        let literaryAllusionSchema = JSONSchema(
            type: .object,
            properties: [
                "source": JSONSchema(type: .string),
                "original_text": JSONSchema(type: .string),
                "interpretation": JSONSchema(type: .string),
                "connection": JSONSchema(type: .string)
            ],
            required: ["source", "original_text", "interpretation", "connection"],
            additionalProperties: false
        )

        // ÂàÜÊûêÁöÑ Schema
        let analysisSchema = JSONSchema(
            type: .object,
            properties: [
                "character_meaning": JSONSchema(type: .string),
                "literary_allusion": literaryAllusionSchema,
                "situational_analysis": JSONSchema(
                    type: .object,
                    properties: [
                        "1": situationalAnalysisSchema,
                        "2": situationalAnalysisSchema,
                        "3": situationalAnalysisSchema,
                        "4": situationalAnalysisSchema,
                        "5": situationalAnalysisSchema
                    ],
                    required: ["1", "2", "3", "4", "5"],
                    additionalProperties: false
                )
            ],
            required: ["character_meaning", "literary_allusion", "situational_analysis"],
            additionalProperties: false
        )

        // ÂÆåÊï¥ÁöÑÂõûÊáâ Schema
        return JSONSchema(
            type: .object,
            properties: [
                "name": JSONSchema(type: .string),
                "analysis": analysisSchema
            ],
            required: ["name", "analysis"],
            additionalProperties: false
        )
    }

    // 2. ‰øÆÊîπ API Ë™øÁî®ÂáΩÊï∏
    private func callOpenAIAPI(with prompt: String) async throws -> (String, [String: String], [String]) {
        let monitor = PerformanceMonitor.shared
        
        monitor.start("API Setup")
        let apiKey = APIConfig.openAIKey
        let service = OpenAIServiceFactory.service(apiKey: apiKey)
        monitor.end("API Setup")

        // 1. ÂÆöÁæ©ÊÉÖÂ¢ÉÂàÜÊûêÁöÑ Schema
        let situationalAnalysisSchema = JSONSchema(
            type: .object,
            properties: [
                "question": JSONSchema(type: .string),
                "answer": JSONSchema(type: .string),
                "analysis": JSONSchema(type: .string)
            ],
            required: ["question", "answer", "analysis"],
            additionalProperties: false
        )

        // 2. ÂÆöÁæ©ÂÖ∏ÊïÖÂàÜÊûêÁöÑ Schema
        let literaryAllusionSchema = JSONSchema(
            type: .object,
            properties: [
                "source": JSONSchema(type: .string),
                "original_text": JSONSchema(type: .string),
                "interpretation": JSONSchema(type: .string),
                "connection": JSONSchema(type: .string)
            ],
            required: ["source", "original_text", "interpretation", "connection"],
            additionalProperties: false
        )

        // 3. ÂÆöÁæ©ÂàÜÊûêÁöÑ Schema
        let analysisSchema = JSONSchema(
            type: .object,
            properties: [
                "character_meaning": JSONSchema(type: .string),
                "literary_allusion": literaryAllusionSchema,
                "situational_analysis": JSONSchema(
                    type: .object,
                    properties: [
                        "1": situationalAnalysisSchema,
                        "2": situationalAnalysisSchema,
                        "3": situationalAnalysisSchema,
                        "4": situationalAnalysisSchema,
                        "5": situationalAnalysisSchema
                    ],
                    required: ["1", "2", "3", "4", "5"],
                    additionalProperties: false
                )
            ],
            required: ["character_meaning", "literary_allusion", "situational_analysis"],
            additionalProperties: false
        )

        // 4. ÂÆöÁæ©ÂõûÊáâÊ†ºÂºèÁöÑ Schema
        let responseFormatSchema = JSONSchemaResponseFormat(
            name: "name_generation",
            strict: true,
            schema: JSONSchema(
                type: .object,
                properties: [
                    "name": JSONSchema(type: .string),
                    "analysis": analysisSchema
                ],
                required: ["name", "analysis"],
                additionalProperties: false
            )
        )

        let messages: [ChatCompletionParameters.Message] = [
            .init(role: .system, content: .text("""
                ÊÇ®ÊòØ‰∏Ä‰ΩçÂ∞àÁ≤æÊñº‰∏≠ËèØÊñáÂåñÁöÑÂëΩÂêçÈ°ßÂïèÔºåÂÖ∑ÂÇô‰ª•‰∏ãÂ∞àÊ•≠Áü•Ë≠òÔºö
                1. Á≤æÈÄö„ÄäË™™ÊñáËß£Â≠ó„Äã„ÄÅ„ÄäÂ∫∑ÁÜôÂ≠óÂÖ∏„ÄãÁ≠âÂ≠óÊõ∏ÔºåËÉΩÊ∫ñÁ¢∫Ëß£ÊûêÊº¢Â≠óÂ≠óÁæ©ËàáÂÖßÊ∂µ
                2. ÁÜüÁ®î„ÄäË©©Á∂ì„Äã„ÄÅ„ÄäÂ∑¶ÂÇ≥„Äã„ÄÅ„ÄäÊ•öËæ≠„Äã„ÄÅ„ÄäÂè≤Ë®ò„Äã„ÄÅ„ÄäË´ñË™û„ÄãÁ≠âÁ∂ìÂÖ∏ÊñáÁçªÔºåÂñÑÊñºÈÅãÁî®ÂÖ∏ÊïÖÁÇ∫ÂêçÂ≠óÂ¢ûÊ∑ªÊñáÂåñÊ∑±Â∫¶
                3. Ê∑±Ë´≥‰∫îË°åÂÖ´Â≠ó„ÄÅÈü≥ÂæãË´ßÂíå‰πãÈÅìÔºåÁ¢∫‰øùÂêçÂ≠óÈü≥ÈüªÂÑ™Áæé
                4. ÊìÖÈï∑ÁµêÂêàÁèæ‰ª£ÂëΩÂêçÁæéÂ≠∏ÔºåÊâìÈÄ†Êó¢ÂÇ≥Áµ±ÂèàÊôÇÂ∞öÁöÑÂêçÂ≠ó

                ÊÇ®ÁöÑ‰ªªÂãôÊòØÔºö
                1. Á¢∫‰øùÂêçÂ≠óÁöÑÈü≥Èüª„ÄÅÂ≠óÁæ©ÁöÜÁõ∏ËºîÁõ∏Êàê
                2. ÈÅ∏Áî®ÂØåÊúâÊ≠£Èù¢ÂØìÊÑèÁöÑÂÖ∏ÊïÖÔºå‰∏¶Ë©≥Á¥∞Ëß£ÈáãÂÖ∂ÊñáÂåñÂÖßÊ∂µ
                3. ÂàÜÊûêÂêçÂ≠óÂ¶Ç‰ΩïÂëºÊáâÂÆ∂Èï∑ÁöÑÊúüÊúõËàáÈ°òÊôØ
                4. Á¢∫‰øùÂêçÂ≠óÊúâÂâµÊÑèÔºå‰∏çËêΩ‰øóÂ•ó
                """)),
            .init(role: .user, content: .text(prompt))
        ]

        let parameters = ChatCompletionParameters(
            messages: messages,
            model: .gpt4omini,
            responseFormat: .jsonSchema(responseFormatSchema)
        )

        monitor.start("API Request Preparation")
        let completionObject = try await service.startChat(parameters: parameters)
        monitor.end("API Request Preparation")
        
        monitor.start("Response Processing")
        guard let jsonString = completionObject.choices.first?.message.content,
              let jsonData = jsonString.data(using: .utf8) else {
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Invalid AI response format",
                details: [
                    "prompt": prompt,
                    "response": completionObject.choices.first?.message.content ?? "No content"
                ]
            )
            throw NSError(domain: "OpenAIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response format"])
        }

        do {
            let jsonResult = try JSONDecoder().decode(NameGenerationResult.self, from: jsonData)
            
            // Áç≤Âèñ‰∫îË°åÂ±¨ÊÄß
            let elements = jsonResult.name.map { char in
                CharacterManager.shared.getElement(for: String(char))
            }
            
            // ÊßãÂª∫ÂàÜÊûêÂ≠óÂÖ∏
            let analysisDict: [String: String] = [
                "Â≠óÁæ©ÂàÜÊûê": jsonResult.analysis.character_meaning,
                "ÂÖ∏ÊïÖÂàÜÊûê": """
                    Âá∫ËôïÔºö\(jsonResult.analysis.literary_allusion.source)
                    ÂéüÊñáÔºö\(jsonResult.analysis.literary_allusion.original_text)
                    ÈáãÁæ©Ôºö\(jsonResult.analysis.literary_allusion.interpretation)
                    ÈÄ£ÁµêÔºö\(jsonResult.analysis.literary_allusion.connection)
                    """,
                "ÊÉÖÂ¢ÉÂàÜÊûê": zip(questions, answers).enumerated().map { index, qa in
                    let analysis = switch index {
                        case 0: jsonResult.analysis.situational_analysis.one.analysis
                        case 1: jsonResult.analysis.situational_analysis.two.analysis
                        case 2: jsonResult.analysis.situational_analysis.three.analysis
                        case 3: jsonResult.analysis.situational_analysis.four.analysis
                        case 4: jsonResult.analysis.situational_analysis.five.analysis
                        default: "ÂàÜÊûêË≥áÊñôÁº∫Â§±"
                    }
                    return "Q\(index + 1)Ôºö\(qa.0.question)\nAÔºö\(qa.1)\n‚Üí \(analysis)"
                }.joined(separator: "\n\n")
            ]


            monitor.end("Response Processing")
            
            // Add character count validation
            let expectedCharCount = formData.numberOfNames
            let actualCharCount = jsonResult.name.count - formData.surname.count
            if actualCharCount != expectedCharCount {
                ErrorManager.shared.logError(
                    category: .aiResponseWrongCharacterCount,
                    message: "ÁîüÊàêÂêçÂ≠óÂ≠óÊï∏ÈåØË™§",
                    details: [
                        "expected_count": "\(expectedCharCount)",
                        "actual_count": "\(actualCharCount)",
                        "generated_name": jsonResult.name,
                        "surname": formData.surname
                    ]
                )
                // throw NSError(
                //     domain: "NameGeneration",
                //     code: 1001,
                //     userInfo: [NSLocalizedDescriptionKey: "ÁîüÊàêÁöÑÂêçÂ≠óÂ≠óÊï∏‰∏çÁ¨¶ÂêàË¶ÅÊ±ÇÔºåË´ãÈáçË©¶"]
                // )
            }
            
            return (jsonResult.name, analysisDict, elements)
        } catch let decodingError as DecodingError {
            // JSON Ëß£ÊûêÈåØË™§
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Failed to decode AI response",
                details: [
                    "error": decodingError.localizedDescription,
                    "json": String(data: jsonData, encoding: .utf8) ?? "Invalid JSON"
                ]
            )
            throw decodingError
            
        } catch let networkError as URLError {
            // Á∂≤Ë∑ØÁõ∏ÈóúÈåØË™§
            let category: ErrorCategory = {
                switch networkError.code {
                case .timedOut:
                    return .apiCallTimeout
                case .notConnectedToInternet:
                    return .apiCallNetworkError
                default:
                    return .apiCallNetworkError
                }
            }()
            
            ErrorManager.shared.logError(
                category: category,
                message: "API network error",
                details: [
                    "error_code": "\(networkError.code.rawValue)",
                    "error_description": networkError.localizedDescription
                ]
            )
            throw networkError
            
        } catch {
            // ÂÖ∂‰ªñÊú™È†êÊúüÁöÑÈåØË™§
            ErrorManager.shared.logError(
                category: .unknown,
                message: "Unexpected error in AI response handling",
                details: [
                    "error": error.localizedDescription,
                    "prompt": prompt
                ]
            )
            throw error
        }
    }
    
    private func handleAnswer(_ answer: String) {
        if answers.count > currentQuestionIndex {
            // Êõ¥Êñ∞ÁèæÊúâÁ≠îÊ°à
            answers[currentQuestionIndex] = answer
        } else {
            // Ê∑ªÂä†Êñ∞Á≠îÊ°à
            answers.append(answer)
        }
        
        // Â¶ÇÊûú‰∏çÊòØÊúÄÂæå‰∏ÄÈ°åÔºåËá™ÂãïÂâçÈÄ≤Âà∞‰∏ã‰∏ÄÈ°å
        if currentQuestionIndex < questions.count - 1 {
            currentQuestionIndex += 1
        }
    }
}

// Êõ¥Êñ∞ NameGenerationResult ÁµêÊßãÈ´î
struct NameGenerationResult: Codable {
    let name: String
    let analysis: Analysis
}

struct Analysis: Codable {
    let character_meaning: String
    let literary_allusion: LiteraryAllusion
    let situational_analysis: SituationalAnalysisMap
}

struct LiteraryAllusion: Codable {
    let source: String
    let original_text: String
    let interpretation: String
    let connection: String
}

struct SituationalAnalysis: Codable {
    let analysis: String  // Âè™ÈúÄË¶ÅÂàÜÊûêÈÉ®ÂàÜ
}

// New type to represent the object structure
struct SituationalAnalysisMap: Codable {
    let one: SituationalAnalysis
    let two: SituationalAnalysis
    let three: SituationalAnalysis
    let four: SituationalAnalysis
    let five: SituationalAnalysis
    
    private enum CodingKeys: String, CodingKey {
        case one = "1"
        case two = "2"
        case three = "3"
        case four = "4"
        case five = "5"
    }
}

// Add this struct at the end of the file
struct Config {
    static var openAIKey: String {
        get {
            guard let filePath = Bundle.main.path(forResource: "Config", ofType: "plist") else {
                fatalError("Couldn't find file 'Config.plist'.")
            }
            
            let plist = NSDictionary(contentsOfFile: filePath)
            
            guard let value = plist?.object(forKey: "OpenAI_API_Key") as? String else {
                fatalError("Couldn't find key 'OpenAI_API_Key' in 'Config.plist'.")
            }
            
            return value
        }
    }
}

struct FavoriteNameData: Codable {
    let name: String
    let analysis: [String: String]
    let wuxing: [String]
}

struct NameAnalysisView: View {
    let name: String
    let analysis: [String: String]
    let wuxing: [String]
    let regenerateAction: () -> Void
    @Binding var selectedTab: Int  // Êñ∞Â¢ûÈÄôË°å
    let showButtons: Bool
    @State private var isFavorite: Bool = false
    @Binding var navigationPath: NavigationPath
    @State private var showSaveFavoriteAlert = false
    @State private var showRegenerateAlert  = false
    @State private var showAccountLinkingOptions = false
    @Environment(\.colorScheme) var colorScheme
    @State private var isRegenerating = false
    @AppStorage("remainingUses") private var remainingUses = 3
    @State private var showInsufficientUsesAlert = false
    @StateObject private var interstitialAd = InterstitialAdViewModel()
    @State private var hasShownReviewRequest = false
    private let usageManager = UsageManager.shared
    @AppStorage("returnHomeCount") private var returnHomeCount = 0
    @State private var showTwoFactorAlert = false
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @EnvironmentObject var authViewModel: AuthViewModel
    
    @State private var showAccountLinkingSheet = false
    @State private var isUpgrading = false
    @State private var upgradeErrorMessage: String?
    @State private var showUpgradeError = false
    // add a boolean if the buttons below is shown
     
    // Âú® NameAnalysisView ÁµêÊßãÈ´îÂÖßÊ∑ªÂä†
    private enum SelectedButton {
        case favorite
        case regenerate
    }

    @State private var selectedButton: SelectedButton = .favorite
    
    // ‰øÆÊîπÂàùÂßãÂåñÊñπÊ≥ï
    init(name: String, 
         analysis: [String: String], 
         wuxing: [String], 
         navigationPath: Binding<NavigationPath>,
         selectedTab: Binding<Int>,  // Êñ∞Â¢ûÈÄôË°å
         regenerateAction: @escaping () -> Void,
         showButtons: Bool) {
        self.name = name
        self.analysis = analysis
        self.wuxing = wuxing
        self._navigationPath = navigationPath
        self._selectedTab = selectedTab  // Êñ∞Â¢ûÈÄôË°å
        self.regenerateAction = regenerateAction
        self.showButtons = showButtons
    }
    
    var body: some View {
        mainScrollView
            .background(Color.customBackground)
            .navigationBarTitle("ÂêçÂ≠óÂàÜÊûê", displayMode: .inline)
            .onAppear(perform: checkFavoriteStatus)
            .overlay(loadingOverlay)
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
    
    // Break down into smaller components
    private var mainScrollView: some View {
        ScrollView {
            VStack(spacing: 20) {
                nameCard
                    .padding(.horizontal)
                
                analysisSection
                    .padding(.horizontal)
                
                if showButtons {  // Changed from _showButtons to showButtons
                    actionButtons
                        .padding(.horizontal)
                        .padding(.bottom, GADAdSizeBanner.size.height + 20)
                }
            }
        }
        .overlay(
            Group {
                if showUpgradeError {
                    CustomAlertView(
                        title: "Á∂ÅÂÆöÂ§±Êïó",
                        message: upgradeErrorMessage ?? "",
                        isPresented: $showUpgradeError
                    )
                }
            }
        )
    }



    private var analysisSection: some View {
        VStack(spacing: 20) {
            characterAnalysisCard
                .frame(maxWidth: .infinity)
            literaryAllusionCard
                .frame(maxWidth: .infinity)
            situationalAnalysisCard
                .frame(maxWidth: .infinity)
        }
    }

    private var characterAnalysisCard: some View {
        AnalysisCard(title: "Â≠óÁæ©") {
            analysisContent(for: "Â≠óÁæ©ÂàÜÊûê")
                .frame(maxWidth: .infinity)
        }
    }

    private var literaryAllusionCard: some View {
        AnalysisCard(title: "ÂÖ∏ÊïÖ") {
            analysisContent(for: "ÂÖ∏ÊïÖÂàÜÊûê")
                .frame(maxWidth: .infinity)
        }
    }

    private var situationalAnalysisCard: some View {
        AnalysisCard(title: "ÊÉÖÂ¢ÉÂ•ëÂêàÂ∫¶") {
            if let situationalContent = analysis["ÊÉÖÂ¢ÉÂàÜÊûê"] {
                situationalAnalysisContent(content: situationalContent)
                    .frame(maxWidth: .infinity)
            }
        }
    }

    private func analysisContent(for key: String) -> some View {
        Group {
            if let analysisContent = analysis[key] {
                let lines = analysisContent.split(separator: "\n")
                ForEach(lines, id: \.self) { line in
                    Text(line)
                        .font(.custom("NotoSansTC-Regular", size: 20))
                        .foregroundColor(.customText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
            }
        }
    }

    private func situationalAnalysisContent(content: String) -> some View {
        let questionsArray = content.split(separator: "Q")
        return ForEach(questionsArray.indices, id: \.self) { index in
            if index >= 0 {
                VStack {
                    if index > 0 {
                        Divider()
                            .padding(.vertical, 10)
                    }
                    SituationalQuestionView(question: "Q" + questionsArray[index])
                }
            }
        }
    }

    private var loadingOverlay: some View {
        Group {
            if isRegenerating {
                VStack(spacing: 15) {
                    ProgressView("ÁîüÊàêÂêçÂ≠ó‰∏≠ÔºàÁ¥Ñ30ÁßíÔºâ...")
                        .scaleEffect(1.5)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.black.opacity(0.3))
            }
        }
    }

    private var nameCard: some View {
        VStack(spacing: 10) {
            Text("ÁÇ∫ÊÇ®ÁîüÊàêÁöÑÂêçÂ≠ó")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
            
            HStack(spacing: 20) {
                let nameCharacters = name.map { String($0) }
                
                // Display each character with its wuxing element
                ForEach(0..<nameCharacters.count, id: \.self) { index in
                    VStack {
                        Text(nameCharacters[index])
                            .font(.custom("NotoSansTC-Black", size: calculateFontSize(for: nameCharacters.count)))
                            .foregroundColor(.customText)
                        
                        // Add wuxing element icon and text
                        if index < wuxing.count {
                            HStack(spacing: 5) {
                                Image(systemName: wuxingIcon(for: wuxing[index]))
                                    .foregroundColor(wuxingColor(for: wuxing[index]))
                            }
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 15)
                            .fill(Color.customSecondary)
                            .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
                    )
                }
            }
        }
    }
    
    private func AnalysisCard<Content: View>(title: String, @ViewBuilder content: @escaping () -> Content) -> some View {
        VStack(alignment: .leading, spacing: 15) {
            Text(title)
                .font(.custom("NotoSansTC-Black", size: 22))
                .foregroundColor(.customText)
            
            content()
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 15)
                .fill(Color.customSecondary)
                .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
        )
    }
    
    private var actionButtons: some View {
        VStack(spacing: 15) {
            Button(action: {
                if Auth.auth().currentUser?.isAnonymous == true {
                    selectedButton = .favorite
                    showAccountLinkingSheet = true
                } else {
                    toggleFavorite()
                }
            }) {
                HStack {
                    Image(systemName: isFavorite ? "heart.fill" : "heart")
                    Text(isFavorite ? "Â∑≤Êî∂Ëóè" : "Êî∂Ëóè")
                }
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isFavorite ? Color.gray : Color.customAccent)
                .cornerRadius(10)
            }

            
            Button(action: {
                if Auth.auth().currentUser?.isAnonymous == true {
                    selectedButton = .regenerate
                    showAccountLinkingSheet = true
                } else {
                    if remainingUses > 0 {
                        regenerateName()
                    } else {
                        showInsufficientUsesAlert = true
                    }
                }
            }) {
                Text("ÈáçÊñ∞ÁîüÊàê")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(.customAccent)
                    .cornerRadius(10)
            }
            .alert(isPresented: $showInsufficientUsesAlert) {
                Alert(
                    title: Text("‰ΩøÁî®Ê¨°Êï∏‰∏çË∂≥"),
                    message: Text("ÂæàÊä±Ê≠âÔºåÊÇ®ÁöÑÂÖçË≤ª‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆå„ÄÇË´ãËßÄÁúãÂª£ÂëäÁç≤ÂèñÊõ¥Â§öÊ¨°Êï∏„ÄÇ"),
                    dismissButton: .default(Text("Á¢∫ÂÆö"))
                )
            }
            
            Button(action: {
                returnHomeCount += 1
                if returnHomeCount >= 3 {
                    interstitialAd.showAd()
                    returnHomeCount = 0  // ÈáçÁΩÆË®àÊï∏
                }
                
                // Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÂÆåÊàêÈõôÈáçÈ©óË≠â
                 if let user = Auth.auth().currentUser {
                    if user.isAnonymous {
                        // ÂåøÂêçÁî®Êà∂ÔºöË®≠ÁΩÆÊ®ôË®ò‰∏¶ÂàáÊèõÂà∞Ë®≠ÂÆöÈ†Å
                        UserDefaults.standard.set(true, forKey: "shouldShowAccountLinkingAlert")
                        navigationPath.removeLast(navigationPath.count)
                        selectedTab = 2  // ÂàáÊèõÂà∞Ë®≠ÂÆöÈ†Å
                    } else if !user.providerData.contains(where: { $0.providerID == "phone" }) {
                        // Â∑≤ÁôªÂÖ•‰ΩÜÊú™Á∂ÅÂÆöÊâãÊ©üÔºöË®≠ÁΩÆÈõôÈáçÈ©óË≠âÊèêÁ§∫
                        UserDefaults.standard.set(true, forKey: "shouldShowTwoFactorAlert")
                        navigationPath.removeLast(navigationPath.count)
                    } else {
                        // Ê≠£Â∏∏Áî®Êà∂ÔºöÁõ¥Êé•ËøîÂõûÈ¶ñÈ†Å
                        navigationPath.removeLast(navigationPath.count)
                    }
                }
            }) {
                Text("ËøîÂõûÈ¶ñÈ†Å")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.customAccent)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.customSecondary)
                    .cornerRadius(10)
            }
           
        }
        .sheet(isPresented: $showAccountLinkingSheet) {
            AccountLinkingSheet(
                isPresented: $showAccountLinkingSheet,
                isUpgrading: $isUpgrading,
                onGoogleLink: upgradeWithGoogle,
                onAppleLink: upgradeWithApple,
                message: selectedButton == .favorite ? "Á∂ÅÂÆöÂ∏≥Ëôü‰ª•‰øùÂ≠òÊÇ®ÂñúÊ≠°ÁöÑÂêçÂ≠ó" : "Á∂ÅÂÆöÂ∏≥Ëôü‰ª•Âø´ÈÄüÁî®Áõ∏ÂêåÊ¢ù‰ª∂ÁîüÊàêÊõ¥Â§öÂêçÂ≠ó"
            )
        }
    }
    
    private func toggleFavorite() {
        isFavorite.toggle()
        if isFavorite {
            saveFavorite()
        } else {
            removeFavorite()
        }
    }
    
    private func saveFavorite() {
        let favoriteData = FavoriteNameData(
            name: name,
            analysis: analysis,
            wuxing: wuxing
        )
        
        var favorites = (UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap { try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) ?? []
        favorites.append(favoriteData)
        
        if let encodedData = try? JSONEncoder().encode(favorites) {
            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
        }

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await usageManager.updateCloudData()
        }
    }
    
    private func removeFavorite() {
        guard var favorites = UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap({ try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) else {
            return
        }
        
        favorites.removeAll { $0.name == name }
        
        if let encodedData = try? JSONEncoder().encode(favorites) {
            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
        }

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
    Task {
            try? await usageManager.updateCloudData()
        }
    }
    
    private func checkFavoriteStatus() {
        guard let favorites = UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap({ try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) else {
            return
        }
        
        isFavorite = favorites.contains { $0.name == name }
    }

    private func wuxingIcon(for element: String) -> String {
        switch element {
        case "Èáë": return "circle.fill"
        case "Êú®": return "leaf.fill"
        case "Ê∞¥": return "drop.fill"
        case "ÁÅ´": return "flame.fill"
        case "Âúü": return "square.fill"
        default: return "questionmark.circle.fill"
        }
    }

    private func wuxingColor(for element: String) -> Color {
        switch element {
        case "Èáë": return .yellow
        case "Êú®": return .green
        case "Ê∞¥": return .blue
        case "ÁÅ´": return .red
        case "Âúü": return .orange
        default: return .gray
        }
    }

    private func regenerateName() {
        isRegenerating = true
        regenerateAction()
    }

    private func requestReview() {
        guard let scene = UIApplication.shared.connectedScenes.first(where: { $0.activationState == .foregroundActive }) as? UIWindowScene else { return }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            SKStoreReviewController.requestReview(in: scene)
        }
    }

    // Ê∑ªÂä†Á∂ÅÂÆöÊñπÊ≥ï
    private func upgradeWithGoogle() {
        self.isUpgrading = true
        
        guard let clientID = FirebaseApp.app()?.options.clientID else { 
            self.isUpgrading = false
            self.upgradeErrorMessage = "ÁÑ°Ê≥ïÁç≤Âèñ Google ÁôªÂÖ•Ë®≠ÂÆö"
            self.showAccountLinkingSheet = false
            self.showUpgradeError = true
            return 
        }
        
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.windows.first,
              let rootViewController = window.rootViewController else {
            self.isUpgrading = false
            self.upgradeErrorMessage = "ÁÑ°Ê≥ïÂàùÂßãÂåñ Google ÁôªÂÖ•"
            self.showAccountLinkingSheet = false
            self.showUpgradeError = true
            return
        }
        
        GIDSignIn.sharedInstance.signIn(withPresenting: rootViewController) { result, error in                
            if let error = error {
                self.upgradeErrorMessage = "Google ÁôªÂÖ•Â§±ÊïóÔºö\(error.localizedDescription)"
                self.showUpgradeError = true
                self.showAccountLinkingSheet = false
                self.isUpgrading = false
                return
            }
            
            guard let user = result?.user,
                    let idToken = user.idToken?.tokenString else {
                self.upgradeErrorMessage = "ÁÑ°Ê≥ïÁç≤Âèñ Google Â∏≥ËôüË≥áË®ä"
                self.showUpgradeError = true
                self.showAccountLinkingSheet = false
                self.isUpgrading = false
                return
            }
            
            let credential = GoogleAuthProvider.credential(
                withIDToken: idToken,
                accessToken: user.accessToken.tokenString
            )
            
            // ÈÄ£ÁµêÂ∏≥Ëôü
            Auth.auth().currentUser?.link(with: credential) { [self] authResult, error in
                if let error = error as NSError? {
                    // ËôïÁêÜÁâπÂÆöÈåØË™§È°ûÂûã
                    let errorMessage: String
                    switch error.code {
                    case AuthErrorCode.emailAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.credentialAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.providerAlreadyLinked.rawValue:
                        errorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Google Â∏≥Ëôü"
                    default:
                        errorMessage = error.localizedDescription
                    }
                    print("‚ùå Á∂ÅÂÆöÂ§±Êïó: \(errorMessage)")
                    DispatchQueue.main.async {
                        self.isUpgrading = false
                        self.upgradeErrorMessage = errorMessage
                        self.showAccountLinkingSheet = false
                        self.showUpgradeError = true
                    }
                    return
                } else {
                    // ÊàêÂäüÈÄ£Áµê
                    self.showAccountLinkingSheet = false
                    
                    // Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñô
                    let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest()
                    changeRequest?.displayName = user.profile?.name
                    changeRequest?.photoURL = user.profile?.imageURL(withDimension: 200)
                    
                    changeRequest?.commitChanges { error in
                        if let error = error {
                            print("‚ùå Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
                        } else {
                            print("‚úÖ Áî®Êà∂Ë≥áÊñôÊõ¥Êñ∞ÊàêÂäü")
                        }
                        
                        print("‚úÖ Â∏≥ËôüÂçáÁ¥öÊàêÂäü")
                        self.isUpgrading = false
                        // Ëß∏Áôº UI Êõ¥Êñ∞
                        self.handleSuccessfulUpgrade()
                    }
                }
            }
        }
    }
    
    private func upgradeWithApple() {
        self.isUpgrading = true
        appleSignInCoordinator = AppleSignInCoordinator()
        
        appleSignInCoordinator?.startSignInWithAppleFlow { [self] result in
            defer {
                DispatchQueue.main.async {
                    self.isUpgrading = false
                    self.showAccountLinkingSheet = false
                }
            }
                
            switch result {
            case .success(_):
                self.handleSuccessfulUpgrade()
                
            case .failure(let error):
                DispatchQueue.main.async {
                    if let authError = error as? NSError {
                        // Firebase Auth errors
                        switch authError.code {
                        case AuthErrorCode.emailAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.credentialAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.providerAlreadyLinked.rawValue:
                            upgradeErrorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Apple Â∏≥Ëôü"
                        case AuthErrorCode.invalidCredential.rawValue:
                            upgradeErrorMessage = "ÁÑ°ÊïàÁöÑÊÜëË≠â"
                        case AuthErrorCode.operationNotAllowed.rawValue:
                            upgradeErrorMessage = "Ê≠§Êìç‰Ωú‰∏çË¢´ÂÖÅË®±"
                        case AuthErrorCode.tooManyRequests.rawValue:
                            upgradeErrorMessage = "Ë´ãÊ±ÇÊ¨°Êï∏ÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶"
                        case AuthErrorCode.networkError.rawValue:
                            upgradeErrorMessage = "Á∂≤Ë∑ØÈÄ£Á∑öÈåØË™§ÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÁãÄÊÖã"
                        case AuthErrorCode.userDisabled.rawValue:
                            upgradeErrorMessage = "Ê≠§Â∏≥ËôüÂ∑≤Ë¢´ÂÅúÁî®"
                        case AuthErrorCode.requiresRecentLogin.rawValue:
                            upgradeErrorMessage = "ÈúÄË¶ÅÈáçÊñ∞ÁôªÂÖ•ÊâçËÉΩÂü∑Ë°åÊ≠§Êìç‰Ωú"
                        default:
                            // Â¶ÇÊûúÊòØ Apple Sign In ÁöÑÈåØË™§
                            if let asError = error as? ASAuthorizationError {
                                switch asError.code {
                                case .canceled:
                                    upgradeErrorMessage = "‰ΩøÁî®ËÄÖÂèñÊ∂àÁ∂ÅÂÆö"
                                case .invalidResponse:
                                    upgradeErrorMessage = "‰º∫ÊúçÂô®ÂõûÊáâÁÑ°Êïà"
                                case .notHandled:
                                    upgradeErrorMessage = "ÁÑ°Ê≥ïËôïÁêÜÊ≠§Ë´ãÊ±Ç"
                                case .failed:
                                    upgradeErrorMessage = "Á∂ÅÂÆöÂ§±Êïó"
                                default:
                                    upgradeErrorMessage = error.localizedDescription
                                }
                            } else {
                                upgradeErrorMessage = error.localizedDescription
                            }
                        }
                        self.showUpgradeError = true
                    }
                }
            }
        }
    }
    
    private func linkAccount(with credential: AuthCredential) {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå ÁÑ°Ê≥ïÈÄ£ÁµêÂ∏≥ËôüÔºöÊú™ÊâæÂà∞Áï∂ÂâçÁî®Êà∂")
            return
        }
        
        user.link(with: credential) { authResult, error in
            DispatchQueue.main.async {
                self.isUpgrading = false
                
                if let error = error {
                    self.upgradeErrorMessage = error.localizedDescription
                    self.showUpgradeError = true
                    return
                }
                
                self.showAccountLinkingOptions = false
            }
        }
    }

    private func handleSuccessfulUpgrade() {
        showAccountLinkingSheet = false
        
        // ËΩâÁßªÂåøÂêçÁî®Êà∂ÁöÑ‰ΩøÁî®Ê¨°Êï∏
        UsageManager.shared.transferAnonymousUses()
        
        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await UsageManager.shared.updateCloudData()
        }
    }
}

struct CustomAlertView: View {
    let title: String
    let message: String
    @Binding var isPresented: Bool
     
    var body: some View {
        ZStack {
            Color.black.opacity(0.3)
                .edgesIgnoringSafeArea(.all)
                .onTapGesture {
                    withAnimation {
                        isPresented = false
                    }
                }
            
            VStack(spacing: 20) {
                Text(title)
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.customText)
                
                Text(message)
                    .font(.custom("NotoSansTC-Regular", size: 14))
                    .foregroundColor(.customText)
                    .multilineTextAlignment(.center)
                
                Button("Á¢∫ÂÆö") {
                    withAnimation {
                        isPresented = false
                    }
                }
                .buttonStyle(AlertButtonStyle(isPrimary: true))
            }
            .padding()
            .background(Color.customBackground)
            .cornerRadius(15)
            .shadow(radius: 10)
            .padding(30)
        }
    }
}

struct AlertButtonStyle: ButtonStyle {
    let isPrimary: Bool
    
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.custom("NotoSansTC-Regular", size: 16))
            .foregroundColor(isPrimary ? .white : .customAccent)
            .padding(.horizontal, 30)
            .padding(.vertical, 10)
            .background(isPrimary ? Color.customAccent : Color.clear)
            .cornerRadius(8)
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(Color.customAccent, lineWidth: isPrimary ? 0 : 1)
            )
    }
}

// Êñ∞Â¢û AccountLinkingSheet Ë¶ñÂúñ
struct AccountLinkingSheet: View {
    @Binding var isPresented: Bool
    @Binding var isUpgrading: Bool
    let onGoogleLink: () -> Void
    let onAppleLink: () -> Void
    let message: String  // Êñ∞Â¢ûÈÄôË°å
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text("Á∂ÅÂÆöÂ∏≥Ëôü")
                    .font(.custom("NotoSansTC-Black", size: 24))
                    .foregroundColor(.customText)
                    .padding(.top)
                
                Text(message)  // ‰ΩøÁî®ÂÇ≥ÂÖ•ÁöÑË®äÊÅØ
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                
                Button(action: onGoogleLink) {
                    HStack {
                        Image("GoogleLogo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 20, height: 20)
                        Text("‰ΩøÁî® Google Â∏≥ËôüÁ∂ÅÂÆö")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(Color.customAccent, lineWidth: 1)
                    )
                }
                .foregroundColor(.customText)
                .disabled(isUpgrading)
                
                Button(action: onAppleLink) {
                    HStack {
                        Image(systemName: "apple.logo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 20, height: 20)
                        Text("‰ΩøÁî® Apple Â∏≥ËôüÁ∂ÅÂÆö")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(Color.customAccent, lineWidth: 1)
                    )
                }
                .foregroundColor(.customText)
                .disabled(isUpgrading)
                
                if isUpgrading {
                    ProgressView()
                        .scaleEffect(1.5)
                        .padding()
                }
                
                Spacer()
            }
            .padding()
            .navigationBarItems(trailing: Button("ÂèñÊ∂à") {
                isPresented = false
            })
            .background(Color.customBackground)
        }
    }
}

struct FavoritesListView: View {
    @State private var favorites: [FavoriteNameData] = []
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        ZStack {
            Color.customBackground
                .edgesIgnoringSafeArea(.all)
            
            if favorites.isEmpty {
                Text("ÁõÆÂâçÊ≤íÊúâÊî∂ËóèÁöÑÂêçÂ≠ó")
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(.customText)
            } else {
                List {
                    ForEach(favorites, id: \.name) { favorite in
                        NavigationLink(destination: NameAnalysisView(
                            name: favorite.name,
                            analysis: favorite.analysis,
                            wuxing: favorite.wuxing,
                            navigationPath: .constant(NavigationPath()),
                            selectedTab: .constant(0),
                            regenerateAction: {},
                            showButtons: false  // Changed from State<Bool> to Bool
                        )) {
                            VStack(alignment: .leading) {
                                HStack {
                                    Text(favorite.name)
                                        .font(.custom("NotoSansTC-Black", size: 24))
                                        .foregroundColor(.customText)
                                    
                                    Spacer()
                                    
                                    HStack(spacing: 5) {
                                        ForEach(favorite.wuxing, id: \.self) { element in
                                            Image(systemName: wuxingIcon(for: element))
                                                .foregroundColor(wuxingColor(for: element))
                                        }
                                    }
                                }
                                Text(favorite.analysis.map { "\($0.key): \($0.value)" }.joined(separator: "\n"))
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.customText)
                                    .lineLimit(2)
                            }
                            .padding(.vertical, 8)
                        }
                    }
                    .onDelete(perform: removeFavorite)
                }
                .listStyle(PlainListStyle())
                // Ê∑ªÂä†Â∫ïÈÉ®ÈñìË∑ùÔºå‰ΩøÂÖ∂‰∏çË¢´Âª£ÂëäÈÅÆÊìã
                .padding(.bottom, GADAdSizeBanner.size.height + 45)
            }
        }
        .onAppear(perform: loadFavorites)
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
    
    private func loadFavorites() {
        if let data = UserDefaults.standard.data(forKey: "FavoriteNames"),
           let decodedFavorites = try? JSONDecoder().decode([FavoriteNameData].self, from: data) {
            favorites = decodedFavorites
        }
    }
    
    private func removeFavorite(at offsets: IndexSet) {
        favorites.remove(atOffsets: offsets)
        if let encodedData = try? JSONEncoder().encode(favorites) {
            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
        }
    }

    private func wuxingIcon(for element: String) -> String {
        switch element {
        case "Èáë": return "circle.fill"
        case "Êú®": return "leaf.fill"
        case "Ê∞¥": return "drop.fill"
        case "ÁÅ´": return "flame.fill"
        case "Âúü": return "square.fill"
        default: return "questionmark.circle.fill"
        }
    }

    private func wuxingColor(for element: String) -> Color {
        switch element {
        case "Èáë": return .yellow
        case "Êú®": return .green
        case "Ê∞¥": return .blue
        case "ÁÅ´": return .red
        case "Âúü": return .orange
        default: return .gray
        }
    }
}


struct SituationalQuestionView: View {
    let question: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            let parts = question.split(separator: "\n", omittingEmptySubsequences: false)
            if parts.count >= 3 {
                Text(String(parts[0].trimmingCharacters(in: .whitespaces))) // Q1, Q2, etc.
                    .font(.custom("NotoSansTC-Black", size: 22))
                    .foregroundColor(.customAccent)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                Text(String(parts[1].trimmingCharacters(in: .whitespaces))) // Answer
                    .font(.custom("NotoSansTC-Regular", size: 20))
                    .foregroundColor(.customText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                Text(String(parts[2].trimmingCharacters(in: .whitespaces))) // Analysis
                    .font(.custom("NotoSansTC-Regular", size: 20))
                    .foregroundColor(.customText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.top, 5)
            }
        }
        .padding(.vertical, 10)
    }
}

// Add this extension for custom corner radius
extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(roundedRect: rect, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        return Path(path.cgPath)
    }
}

// Add this struct for the triangle shape
struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.closeSubpath()
        return path
    }
}

// Add this custom toggle style
struct CustomToggleStyle: ToggleStyle {
    var onColor: Color
    
    func makeBody(configuration: Configuration) -> some View {
        HStack {
            configuration.label
            Spacer()
            Rectangle()
                .foregroundColor(configuration.isOn ? onColor : Color.gray.opacity(0.3))
                .frame(width: 51, height: 31, alignment: .center)
                .overlay(
                    Circle()
                        .foregroundColor(.white)
                        .padding(.all, 3)
                        .offset(x: configuration.isOn ? 11 : -11, y: 0)
                        .animation(.linear(duration: 0.1), value: configuration.isOn)
                )
                .cornerRadius(20)
                .onTapGesture { configuration.isOn.toggle() }
        }
    }
}
// Â∞ÜCharacterÊâ©Â±ïÁßªÂà∞Êñá‰ª∂ÁöÑÂÖ®Â±ÄËåÉÂõ¥ÂÜÖ
extension Character {
    var isChineseCharacter: Bool {
        return String(self).range(of: "\\p{Han}", options: .regularExpression) != nil
    }
}

@MainActor
class RewardedViewModel: NSObject, ObservableObject, GADFullScreenContentDelegate {
    private let usageManager = UsageManager.shared
    private var rewardedAd: GADRewardedAd?
    @Published var isAdLoaded = false
    @Published var remainingCooldown: Int = 0
    private var isLoading = false
    private var lastLoadTime: Date?
    private let minimumLoadInterval: TimeInterval = 300
    private var cooldownTimer: Timer?
    private let lastAdTimestampKey = "LastRewardedAdTimestamp"
    private let cooldownDuration: TimeInterval = 300 // 5ÂàÜÈêòÂÜ∑ÂçªÊôÇÈñì
    
    override init() {
        super.init()
        Task { @MainActor in
            preloadNextAd()
            updateCooldownStatus() // ÂàùÂßãÂåñÊôÇÊõ¥Êñ∞ÁãÄÊÖã
        }
    }
    
    private func canLoadAd() -> Bool {
        let lastTimestamp = UserDefaults.standard.double(forKey: lastAdTimestampKey)
        let timeSinceLastAd = Date().timeIntervalSince1970 - lastTimestamp
        return timeSinceLastAd >= cooldownDuration
    }
    
    private func updateCooldownStatus() {
        let lastTimestamp = UserDefaults.standard.double(forKey: lastAdTimestampKey)
        let timeSinceLastAd = Date().timeIntervalSince1970 - lastTimestamp
        
        if timeSinceLastAd < cooldownDuration {
            remainingCooldown = Int(cooldownDuration - timeSinceLastAd)
            startCooldownTimer()
        } else {
            remainingCooldown = 0
            preloadNextAd()
        }
    }
    
    private func startCooldownTimer() {
        cooldownTimer?.invalidate()
        
        let timer = Timer(timeInterval: 1.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                guard let self = self else { return }
                
                let lastTimestamp = UserDefaults.standard.double(forKey: self.lastAdTimestampKey)
                let timeSinceLastAd = Date().timeIntervalSince1970 - lastTimestamp
                
                if timeSinceLastAd < self.cooldownDuration {
                    self.remainingCooldown = Int(self.cooldownDuration - timeSinceLastAd)
                } else {
                    self.remainingCooldown = 0
                    self.cooldownTimer?.invalidate()
                    self.cooldownTimer = nil
                    self.preloadNextAd()
                }
            }
        }
        
        RunLoop.main.add(timer, forMode: .common)
        cooldownTimer = timer
    }
    
    private func preloadNextAd() {
        guard !isLoading else {
            print("‚è≥ [AdLoad] Ê≠£Âú®ËºâÂÖ•‰∏≠ÔºåË∑≥ÈÅé")
            return 
        }
        guard canLoadAd() else {
            print("‚è≥ [AdLoad] Êú™ÈÅîËºâÂÖ•ÈñìÈöîÔºåÈñãÂßãË®àÊôÇ")
            startCooldownTimer()
            return
        }
        
        isLoading = true
        
        print("üì± [AdLoad] ÈñãÂßãËºâÂÖ•Âª£Âëä")
        Task {
            do {
                rewardedAd = try await GADRewardedAd.load(
                    withAdUnitID: "ca-app-pub-3940256099942544/1712485313",
                    // withAdUnitID: "ca-app-pub-3469743877050320/4233450598",
                    request: GADRequest())
                rewardedAd?.fullScreenContentDelegate = self
                
                await MainActor.run {
                    isAdLoaded = true
                    isLoading = false
                    lastLoadTime = Date()
                    print("‚úÖ [AdLoad] Âª£ÂëäËºâÂÖ•ÊàêÂäü")
                }
            } catch {
                await MainActor.run {
                    isAdLoaded = false
                    isLoading = false
                    print("‚ùå [AdLoad] Âª£ÂëäËºâÂÖ•Â§±Êïó: \(error.localizedDescription)")
                }
                
                try? await Task.sleep(nanoseconds: 3 * 1_000_000_000)
                if canLoadAd() {
                    await MainActor.run {
                        self.preloadNextAd()
                    }
                }
            }
        }
    }
    
    func showAd() {
        guard let rewardedAd = rewardedAd else {
            if canLoadAd() {
                preloadNextAd()
            }
            return
        }
        
        if let rootViewController = UIApplication.shared.windows.first?.rootViewController {
            rewardedAd.present(fromRootViewController: rootViewController) { [weak self] in
                self?.usageManager.remainingUses += 3
                
                // Êõ¥Êñ∞ÊúÄÂæåËßÄÁúãÂª£ÂëäÁöÑÊôÇÈñìÊà≥Ë®ò
                UserDefaults.standard.set(Date().timeIntervalSince1970, forKey: self?.lastAdTimestampKey ?? "")
                
                Task {
                    try? await self?.usageManager.updateCloudData()
                }
            }
        }
    }
    
    // MARK: - GADFullScreenContentDelegate
    
    func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        isAdLoaded = false
        updateCooldownStatus() // Âª£ÂëäÈóúÈñâÊôÇÊõ¥Êñ∞ÁãÄÊÖã
    }
    
    func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        print("‚ùå [AdShow] Âª£ÂëäÂ±ïÁ§∫Â§±Êïó: \(error.localizedDescription)")
        isAdLoaded = false
        if canLoadAd() {
            preloadNextAd()
        }
    }
    
    deinit {
        cooldownTimer?.invalidate()
    }
}

class UsageManager: ObservableObject {
    static let shared = UsageManager()
    @Published var remainingUses: Int = 0
    private let db = Firestore.firestore()
    
    // Êñ∞Â¢û UserDefaults key
    private let anonymousUsesKey = "anonymousRemainingUses"
    
    // ÂàùÂßãÂåñÊôÇË®≠ÂÆöÂåøÂêçÁî®Êà∂ÁöÑÂàùÂßã‰ΩøÁî®Ê¨°Êï∏
    private func initializeAnonymousUses() {
        if UserDefaults.standard.object(forKey: anonymousUsesKey) == nil {
            UserDefaults.standard.set(3, forKey: anonymousUsesKey)
        }
    }
    
    // ‰øÆÊîπÂêåÊ≠•Ë≥áÊñôÊñπÊ≥ï
    func syncUserData() async throws {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå Êú™ÁôªÂÖ•ÔºåÁÑ°Ê≥ïÂêåÊ≠•Ë≥áÊñô")
            return
        }
        
        // Â¶ÇÊûúÊòØÂåøÂêçÁî®Êà∂Ôºå‰ΩøÁî®Êú¨Âú∞ÂÑ≤Â≠òÁöÑÊ¨°Êï∏
        if user.isAnonymous {
            initializeAnonymousUses()
            await MainActor.run {
                self.remainingUses = UserDefaults.standard.integer(forKey: anonymousUsesKey)
            }
            return
        }
        
        // ÈùûÂåøÂêçÁî®Êà∂ÔºåÂæû Firestore ËÆÄÂèñË≥áÊñô
        print("üîÑ ÈñãÂßãÂêåÊ≠•Áî®Êà∂Ë≥áÊñô")
        let userRef = db.collection("users").document(user.uid)
        
        do {
            let document = try await userRef.getDocument()
            
            if document.exists {
                print("‚úÖ ÊâæÂà∞ÁèæÊúâÁî®Êà∂Ë≥áÊñô")
                if let userData = try? document.data(as: UserData.self) {
                    await MainActor.run {
                        self.remainingUses = userData.remainingUses
                        if let encodedData = try? JSONEncoder().encode(userData.favorites) {
                            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
                        }
                    }
                }
            } else {
                print("üìù ÂâµÂª∫Êñ∞Áî®Êà∂Ë≥áÊñô")
                let newUserData = UserData.createDefault()
                try await userRef.setData(from: newUserData)
                
                await MainActor.run {
                    self.remainingUses = newUserData.remainingUses
                }
            }
        } catch {
            print("‚ùå ÂêåÊ≠•Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
            throw error
        }
    }
    
    // ‰øÆÊîπÊõ¥Êñ∞Èõ≤Á´ØË≥áÊñôÊñπÊ≥ï
    func updateCloudData() async throws {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå Êú™ÁôªÂÖ•ÔºåÁÑ°Ê≥ïÊõ¥Êñ∞Ë≥áÊñô")
            return
        }
        
        // Â¶ÇÊûúÊòØÂåøÂêçÁî®Êà∂ÔºåÂè™Êõ¥Êñ∞Êú¨Âú∞ÂÑ≤Â≠ò
        if user.isAnonymous {
            UserDefaults.standard.set(remainingUses, forKey: anonymousUsesKey)
            return
        }
        
        print("üîÑ ÈñãÂßãÊõ¥Êñ∞Èõ≤Á´ØË≥áÊñô")
        
        let favorites = (UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap { try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) ?? []
        
        let userData = UserData(
            remainingUses: remainingUses,
            favorites: favorites,
            lastSyncTime: Date()
        )
        
        do {
            try await db.collection("users").document(user.uid).setData(from: userData, merge: true)
            print("‚úÖ Èõ≤Á´ØË≥áÊñôÊõ¥Êñ∞ÊàêÂäü")
        } catch {
            print("‚ùå Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
            throw error
        }
    }
    
    // Êñ∞Â¢ûÊñπÊ≥ïÔºöËôïÁêÜÂ∏≥ËôüÁ∂ÅÂÆöÊôÇÁöÑ‰ΩøÁî®Ê¨°Êï∏ËΩâÁßª
    func transferAnonymousUses() {
        let anonymousUses = UserDefaults.standard.integer(forKey: anonymousUsesKey)
        remainingUses = anonymousUses
        // Ê∏ÖÈô§ÂåøÂêçÁî®Êà∂ÁöÑ‰ΩøÁî®Ê¨°Êï∏
        UserDefaults.standard.removeObject(forKey: anonymousUsesKey)
    }
}

// Add this new TabButton view
struct TabButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
        var body: some View {
        Button(action: action) {
            Text(title)
                .font(.custom("NotoSansTC-Black", size: 16))
                .foregroundColor(isSelected ? .white : .customText)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(isSelected ? Color.customAccent : Color.clear)
        }
        .cornerRadius(25)
    }
}

// Add new InterstitialAdViewModel class
class InterstitialAdViewModel: NSObject, ObservableObject, GADFullScreenContentDelegate {
    private var interstitialAd: GADInterstitialAd?
    private var isLoading = false
    
    override init() {
        super.init()
        loadAd()
    }
    
    private func loadAd() {
        guard !isLoading else { return }
        isLoading = true
        
        print("üì± [InterstitialAd] ÈñãÂßãËºâÂÖ•Âª£Âëä")
        Task {
            do {
                interstitialAd = try await GADInterstitialAd.load(
                    withAdUnitID: "ca-app-pub-3940256099942544/4411468910",
                    // withAdUnitID: "ca-app-pub-3469743877050320/9105399676",
                    request: GADRequest())
                interstitialAd?.fullScreenContentDelegate = self
                
                await MainActor.run {
                    isLoading = false
                    print("‚úÖ [InterstitialAd] Âª£ÂëäËºâÂÖ•ÊàêÂäü")
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    print("‚ùå [InterstitialAd] Âª£ÂëäËºâÂÖ•Â§±Êïó: \(error.localizedDescription)")
                }
                
                // Â¶ÇÊûúËºâÂÖ•Â§±ÊïóÔºåÁ≠âÂæÖÂæåÈáçË©¶
                try? await Task.sleep(nanoseconds: 3 * 1_000_000_000)
                loadAd()
            }
        }
    }
    
    func showAd() {
        guard let interstitialAd = interstitialAd else {
            print("‚ùå [InterstitialAd] Âª£ÂëäÊú™Ê∫ñÂÇôÂ•Ω")
            loadAd()
            return
        }
        
        print("üì± [InterstitialAd] ÈñãÂßãÂ±ïÁ§∫Âª£Âëä")
        if let rootViewController = UIApplication.shared.windows.first?.rootViewController {
            interstitialAd.present(fromRootViewController: rootViewController)
        }
    }
    
    // MARK: - GADFullScreenContentDelegate
    
    func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        print("üì± [InterstitialAd] Âª£ÂëäÈóúÈñâÔºåÈñãÂßãÈ†êËºâ‰∏ã‰∏ÄÂÄã")
        loadAd()
    }
    
    func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        print("‚ùå [InterstitialAd] Âª£ÂëäÂ±ïÁ§∫Â§±Êïó: \(error.localizedDescription)")
        loadAd()
    }
}

class PerformanceMonitor {
    static let shared = PerformanceMonitor()
    private var startTimes: [String: CFAbsoluteTime] = [:]
    private var measurements: [(String, TimeInterval)] = []
    
    func start(_ name: String) {
        startTimes[name] = CFAbsoluteTimeGetCurrent()
    }
    
    func end(_ name: String) {
        guard let startTime = startTimes[name] else { return }
        let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
        measurements.append((name, timeElapsed))
        print("‚è±Ô∏è [Performance] \(name): \(String(format: "%.3f", timeElapsed))s")
    }
    
    func reset() {
        startTimes.removeAll()
        measurements.removeAll()
    }
    
    func printSummary() {
        print("\nüìä Performance Summary:")
        print("------------------------")
        for (name, time) in measurements {
            print("\(name.padding(toLength: 25, withPad: " ", startingAt: 0)): \(String(format: "%.3f", time))s")
        }
        print("------------------------\n")
    }
}

#Preview {
    ContentView()
}

struct CreateAccountView: View {
    @Environment(\.dismiss) var dismiss
    @Binding var isLoggedIn: Bool
    @ObservedObject var authViewModel: AuthViewModel
    @State private var email = ""
    @State private var password = ""
    @State private var confirmPassword = ""
    @State private var fullName = ""
    @State private var companyName = ""
    @State private var isSignUp = false
    @State private var showError = false
    @State private var errorMessage: String?
    @Environment(\.colorScheme) var colorScheme
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @State private var isLoading: Bool = false
    
    let textColor = Color(hex: "#FF798C")
    
    var body: some View {
        ZStack {
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 0) {
                // Pull Indicator
                RoundedRectangle(cornerRadius: 2.5)
                    .fill(Color.gray.opacity(0.5))
                    .frame(width: 40, height: 5)
                    .padding(.vertical, 10)
                
                ScrollView(showsIndicators: false) {
                    VStack(spacing: 20) {
                        // Move top padding into spacer for better layout
                        Spacer()
                            .frame(height: 30) // Reduced top spacing due to pull indicator
                        
                        Text("Âª∫Á´ãÊñ∞Â∏≥Ëôü")
                            .font(.custom("NotoSansTC-Black", size: 32))
                            .foregroundColor(textColor)
                        
                        VStack(spacing: 15) {
                            CustomTextField(placeholder: "ÂßìÂêç", text: $fullName)
                            CustomTextField(
                                placeholder: "ÈõªÂ≠êÈÉµ‰ª∂", 
                                text: $email,
                                keyboardType: .emailAddress,
                                autocapitalization: .never,
                                validation: { email in
                                    let emailRegex = #"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"#
                                    let emailPredicate = NSPredicate(format: "SELF MATCHES %@", emailRegex)
                                    return emailPredicate.evaluate(with: email)
                                },
                                errorMessage: "Ë´ãËº∏ÂÖ•ÊúâÊïàÁöÑÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄ"
                            )
                            CustomTextField(placeholder: "ÂØÜÁ¢º", text: $password, isSecure: true)
                            CustomTextField(placeholder: "Á¢∫Ë™çÂØÜÁ¢º", text: $confirmPassword, isSecure: true)
                        }
                        .padding(.horizontal)
                        
                        Button(action: createAccount) {
                            if isLoading {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            } else {
                                Text("Ë®ªÂÜä")
                                    .font(.custom("NotoSansTC-Black", size: 18))
                            }
                        }
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(textColor)
                        .cornerRadius(25)
                        .disabled(email.isEmpty || password.isEmpty || confirmPassword.isEmpty || isLoading)
                        
                        // Add bottom spacer for keyboard
                        Spacer()
                            .frame(height: 100)
                    }
                    .padding()
                }
                // Disable scroll view's automatic keyboard avoidance
                .ignoresSafeArea(.keyboard, edges: .bottom)
            }
            .ignoresSafeArea(.keyboard, edges: .bottom)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("ËøîÂõû") {
                        dismiss()
                    }
                }
            }
            .alert("ÈåØË™§", isPresented: $showError) {  // Êñ∞Â¢û @State private var showError = false
                Button("Á¢∫ÂÆö", role: .cancel) { }
            } message: {
                Text(errorMessage ?? "ÁôºÁîüÊú™Áü•ÈåØË™§")  // ‰øÆÊîπÁÇ∫‰ΩøÁî®ÂèØÈÅ∏ÂûãÂà•
            }
        }
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
    
    private func createAccount() {
        // È©óË≠âËº∏ÂÖ•
        guard !email.isEmpty, !password.isEmpty, !fullName.isEmpty else {
            print("ÈåØË™§")
            return
        }
        
        guard password == confirmPassword else {
            print("ÈåØË™§")
            return
        }
        
        // Âª∫Á´ãÂ∏≥Ëôü
        Auth.auth().createUser(withEmail: email, password: password) { result, error in
            if error != nil {
                print("ÈåØË™§")
                return
            }
            
            if let user = result?.user {
                // Êõ¥Êñ∞Áî®Êà∂Ë≥á
                let changeRequest = user.createProfileChangeRequest()
                changeRequest.displayName = fullName
                changeRequest.commitChanges { error in
                    if error != nil {
                        print("ÈåØË™§")
                    }
                }
                
                // ÂÑ≤Â≠òÈ°çÂ§ñÁöÑÁî®Êà∂Ë≥áË®äÂà∞ Firestore
                let db = Firestore.firestore()
                db.collection("users").document(user.uid).setData([
                    "fullName": fullName,
                    "email": email,
                    "createdAt": Date()
                ]) { error in
                    if error != nil {
                        print("ÈåØË™§")
                    }
                }
                
                isLoggedIn = true
                dismiss()
            }
        }
    }
}



// Add Apple Sign In Coordinator
class AppleSignInCoordinator: NSObject, ASAuthorizationControllerDelegate {
    private var completion: ((Result<AuthDataResult, Error>) -> Void)?
    private var currentNonce: String? // Ê∑ªÂä† nonce Â±¨ÊÄß
    
    // ÁîüÊàêÈö®Ê©ü nonce ÁöÑÊñπÊ≥ï
    private func randomNonceString(length: Int = 32) -> String {
        precondition(length > 0)
        let charset: [Character] =
            Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")
        var result = ""
        var remainingLength = length
        
        while remainingLength > 0 {
            let randoms: [UInt8] = (0 ..< 16).map { _ in
                var random: UInt8 = 0
                let errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random)
                if errorCode != errSecSuccess {
                    fatalError("Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)")
                }
                return random
            }
            
            randoms.forEach { random in
                if remainingLength == 0 {
                    return
                }
                
                if random < charset.count {
                    result.append(charset[Int(random)])
                    remainingLength -= 1
                }
            }
        }
        return result
    }

    // SHA256 ÈõúÊπäÂáΩÊï∏
    private func sha256(_ input: String) -> String {
        let inputData = Data(input.utf8)
        let hashedData = SHA256.hash(data: inputData)
        let hashString = hashedData.compactMap {
            String(format: "%02x", $0)
        }.joined()
        return hashString
    }
    
    func startSignInWithAppleFlow(completion: @escaping (Result<AuthDataResult, Error>) -> Void) {
        self.completion = completion
        
        // ÁîüÊàê nonce
        let nonce = randomNonceString()
        currentNonce = nonce
        let hashedNonce = sha256(nonce)
        
        let provider = ASAuthorizationAppleIDProvider()
        let request = provider.createRequest()
        request.requestedScopes = [.email, .fullName]
        request.nonce = hashedNonce
        
        let controller = ASAuthorizationController(authorizationRequests: [request])
        controller.delegate = self
        controller.performRequests()
    }
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential,
              let appleIDToken = appleIDCredential.identityToken,
              let idTokenString = String(data: appleIDToken, encoding: .utf8),
              let nonce = currentNonce else {
            completion?(.failure(NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Apple Sign In failed"])))
            return
        }
        
        // Create Firebase credential with nonce
        let credential = OAuthProvider.credential(
            withProviderID: "apple.com",
            idToken: idTokenString,
            rawNonce: nonce // ‰ΩøÁî®ÁîüÊàêÁöÑ nonce
        )

        handleAppleSignIn(credential: credential, appleIDCredential: appleIDCredential)

        // ‰øùÂ≠òÁî®Êà∂ÂÖ®Âêç
        if let fullName = appleIDCredential.fullName {
            let displayName = [
                fullName.givenName,
                fullName.familyName
            ].compactMap { $0 }.joined(separator: " ")
            
            print("üë§ Constructed display name: \(displayName)")
            
            if !displayName.isEmpty {
                print("üîÑ Starting profile update...")
                // ‰ΩøÁî® Auth.auth().currentUser ËÄå‰∏çÊòØ authResult
                if let currentUser = Auth.auth().currentUser {
                    let changeRequest = currentUser.createProfileChangeRequest()
                    changeRequest.displayName = displayName
                    changeRequest.commitChanges { error in
                        if let error = error {
                            print("‚ùå Error updating user profile: \(error.localizedDescription)")
                            print("üîç Error details: \(error)")
                        } else {
                            print("‚úÖ Successfully updated user display name to: \(displayName)")
                            print("üéâ Profile update completed successfully")
                        }
                    }
                } else {
                    print("‚ö†Ô∏è No current user found")
                }
            } else {
                print("‚ö†Ô∏è Display name was empty, skipping profile update")
            }
        } else {
            print("‚ÑπÔ∏è No full name provided in Apple credential")
        }
    }
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
        completion?(.failure(error))
        print("Sign in with Apple errored: \(error.localizedDescription)")
    }
}

extension AppleSignInCoordinator {
    func handleAppleSignIn(credential: AuthCredential, appleIDCredential: ASAuthorizationAppleIDCredential?) {
        if let user = Auth.auth().currentUser {
            if user.isAnonymous {
                // Case BÔºöÂåøÂêç ‚Üí Ëàá Apple ÈÄ£Áµê
                print("ÂåøÂêçÁî®Êà∂ÔºåÈñãÂßãÈÄ£Áµê Apple Â∏≥Ëôü")
                linkAnonymousUserToApple(credential: credential, fullName: appleIDCredential?.fullName)
            } else {
                // Case CÔºö‰∏ÄËà¨ÁôªÂÖ•‰ΩøÁî®ËÄÖ
                print("Current user is not anonymous, consider linking or show a message.")
            }
        } else {
            // Case AÔºöÂ∞öÊú™ÁôªÂÖ• ‚Üí ‰ª• Apple Â∏≥ËôüÁôªÂÖ•
            print("Â∞öÊú™ÁôªÂÖ•ÔºåÈñãÂßã‰ª• Apple Â∏≥ËôüÁôªÂÖ•")
            signInWithApple(credential: credential, fullName: appleIDCredential?.fullName)
        }
    }

    private func linkAnonymousUserToApple(credential: AuthCredential, fullName: PersonNameComponents?) {
        guard let user = Auth.auth().currentUser else {
            print("Êâæ‰∏çÂà∞Áï∂ÂâçÁî®Êà∂")
            self.completion?(.failure(NSError(
                domain: "AppleSignIn",
                code: -1,
                userInfo: [NSLocalizedDescriptionKey: "Êâæ‰∏çÂà∞Áï∂ÂâçÁî®Êà∂"]
            )))
            return
        }
        
        user.link(with: credential) { [weak self] authResult, error in
            if let error = error as NSError? {
                print("ÈÄ£Áµê Apple Â∏≥ËôüÂ§±ÊïóÔºö\(error.localizedDescription)")
                self?.completion?(.failure(error))
                return
            }
            
            // ÊàêÂäüÈÄ£ÁµêÂæåÊõ¥Êñ∞Áî®Êà∂Ë≥áÊñô
            if let fullName = fullName {
                let displayName = [
                    fullName.givenName,
                    fullName.familyName
                ].compactMap { $0 }.joined(separator: " ")
                
                if !displayName.isEmpty {
                    let changeRequest = authResult?.user.createProfileChangeRequest()
                    changeRequest?.displayName = displayName
                    changeRequest?.commitChanges { error in
                        if let error = error {
                            print("‚ùå Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñôÂ§±ÊïóÔºö\(error.localizedDescription)")
                        } else {
                            print("‚úÖ ÊàêÂäüÊõ¥Êñ∞Áî®Êà∂È°ØÁ§∫ÂêçÁ®±ÁÇ∫Ôºö\(displayName)")
                        }
                    }
                }
            }
            
            // ÂÆåÊàêÂõûË™ø
            if let authResult = authResult {
                self?.completion?(.success(authResult))
            }
        }
    }

    private func signInWithApple(credential: AuthCredential, fullName: PersonNameComponents?) {
        Auth.auth().signIn(with: credential) { [weak self] authResult, error in
            if let error = error {
                self?.completion?(.failure(error))
                return
            }
            
            // ÊàêÂäüÁôªÂÖ•ÂæåÊõ¥Êñ∞Áî®Êà∂Ë≥áÊñô
            if let fullName = fullName {
                let displayName = [
                    fullName.givenName,
                    fullName.familyName
                ].compactMap { $0 }.joined(separator: " ")
                
                if !displayName.isEmpty {
                    let changeRequest = authResult?.user.createProfileChangeRequest()
                    changeRequest?.displayName = displayName
                    changeRequest?.commitChanges { error in
                        if let error = error {
                            print("‚ùå Error updating user profile: \(error.localizedDescription)")
                        } else {
                            print("‚úÖ Successfully updated user display name to: \(displayName)")
                        }
                    }
                }
            }
            
            if let authResult = authResult {
                self?.completion?(.success(authResult))
            }
        }
    }
}

struct Choice: Codable, Hashable {
    let meaning: String
    let text: String
}

struct Question: Codable {
    let question: String
    let choices: [Choice]
}

struct QuestionList: Codable {
    let questions: [SimpleQuestion]
    let scenario_questions: [ScenarioQuestion]
}

struct SimpleQuestion: Codable {
    let question: String
    let choices: [String]
}

struct ScenarioQuestion: Codable {
    let scenario: String
    let choices: [Choice]
}

struct TraitButton: View {
    let title: String
    let action: () -> Void
    
        var body: some View {
        Button(action: action) {
            Text(title)
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.customSecondary)
                .cornerRadius(10)
                .overlay(
                    RoundedRectangle(cornerRadius: 10)
                        .stroke(.customAccent, lineWidth: 1)
                )
        }
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
}

struct GIFImageView: UIViewRepresentable {
    private let gifName: String
    private let frame: CGRect
    private let onAnimationComplete: () -> Void
    private let isTransparent: Bool
    private let loopCount: Int
    
    init(_ name: String, 
         frame: CGRect, 
         isTransparent: Bool = false,
         loopCount: Int = 1,
         onAnimationComplete: @escaping () -> Void) {
        self.gifName = name
        self.frame = frame
        self.isTransparent = isTransparent
        self.loopCount = loopCount
        self.onAnimationComplete = onAnimationComplete
    }
    
    func makeUIView(context: Context) -> UIView {
        let view = UIView(frame: frame)
        view.backgroundColor = isTransparent ? .clear : .black
        
        // Load GIF
        if let path = Bundle.main.path(forResource: gifName, ofType: "gif") {
            let url = URL(fileURLWithPath: path)
            let gifImageView = UIImageView(gifURL: url, loopCount: loopCount)
            gifImageView.frame = CGRect(x: 0, y: 0, width: view.bounds.width, height: view.bounds.height) // Ë®≠ÂÆöÁÇ∫ËàáviewÁõ∏ÂêåÂ§ßÂ∞è‰ª•ÂÆåÂÖ®Â°´Êªø
            gifImageView.contentMode = .scaleAspectFill
            gifImageView.backgroundColor = isTransparent ? .clear : .black

            gifImageView.delegate = context.coordinator
            view.addSubview(gifImageView)
        }
        
        return view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(onAnimationComplete: onAnimationComplete)
    }
    
    class Coordinator: NSObject, SwiftyGifDelegate {
        private let onAnimationComplete: () -> Void
        
        init(onAnimationComplete: @escaping () -> Void) {
            self.onAnimationComplete = onAnimationComplete
            super.init()
        }
        
        func gifDidStop(sender: UIImageView) {
            onAnimationComplete()
        }
    }
}

struct SplashScreenView: View {
    @Binding var showSplash: Bool
    
    var body: some View {
        ZStack {
            Color.white
                .edgesIgnoringSafeArea(.all)
            
            GIFImageView("splash_animation", 
                        frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
                        isTransparent: false,
                        onAnimationComplete: {
                            // GIF Êí≠ÊîæÂÆåÊàêÂæåÁöÑÂõûË™ø
                            showSplash = false
                        })
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .edgesIgnoringSafeArea(.all)
        }
        .ignoresSafeArea()
    }
}

struct UserData: Codable {
    var remainingUses: Int
    var favorites: [FavoriteNameData]
    var lastSyncTime: Date
    
    static let defaultUses = 3
    
    static func createDefault() -> UserData {
        return UserData(
            remainingUses: defaultUses,
            favorites: [],
            lastSyncTime: Date()
        )
    }
}

// Êñ∞Â¢û‰∏ÄÂÄãÈÄöÁî®ÁöÑÂèØÈªûÊìäÊïàÊûú‰øÆÈ£æÂô®
struct PressableButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .opacity(configuration.isPressed ? 0.7 : 1.0) // ‰øùÁïôÈÄèÊòéÂ∫¶ËÆäÂåñ‰ΩÜÁßªÈô§ÂãïÁï´
            .animation(nil, value: configuration.isPressed) // Á¶ÅÁî®ÂãïÁï´
    }
}

struct LoadingView: View {
    var body: some View {
        ZStack {
            VStack(spacing: 20) {
                GIFImageView("loading_animation", 
                    frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
                    isTransparent: true,
                    loopCount: -1) {
                }
                .frame(maxWidth: .infinity) // ËÆìÂÆπÂô®‰ΩîÊìöÂÖ®ÂØ¨ÔºåÂØ¶ÁèæÊ∞¥Âπ≥ÁΩÆ‰∏≠
                
                Text("ÁîüÊàêÂêçÂ≠ó‰∏≠ÔºàÁ¥Ñ30ÁßíÔºâ...")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.black)
            }
        }
    }
}

struct SuccessPopupView: View {
    let uses: Int
    var onDismiss: () -> Void
    
    var body: some View {
        ZStack {
            // ÂçäÈÄèÊòéËÉåÊôØ
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
                .onTapGesture {
                    onDismiss()
                }
            
            // ÂΩàÂá∫Ë¶ñÁ™ó
            VStack(spacing: 24) { // Â¢ûÂä†Êï¥È´îÂûÇÁõ¥ÈñìË∑ù
                Image(systemName: "checkmark.circle.fill")
                    .resizable()
                    .frame(width: 60, height: 60)
                    .foregroundColor(.green)
                    .padding(.top, 32) // È†ÇÈÉ®Â¢ûÂä†ÈñìË∑ù
                
                VStack(spacing: 12) { // ÊñáÂ≠óÂçÄÂ°äÁöÑÂûÇÁõ¥ÈñìË∑ù
                    Text("Ë≥ºË≤∑ÊàêÂäüÔºÅ")
                        .font(.custom("NotoSansTC-Black", size: 24))
                        .foregroundColor(.customText)
                    
                    Text("Â∑≤Êñ∞Â¢û \(uses) Ê¨°‰ΩøÁî®Ê©üÊúÉ")
                        .font(.custom("NotoSansTC-Regular", size: 18))
                        .foregroundColor(.customText)
                }
                
                Button(action: onDismiss) {
                    Text("Á¢∫ÂÆö")
                        .font(.custom("NotoSansTC-Regular", size: 16))
                        .foregroundColor(.white)
                        .frame(width: 120) // Â¢ûÂä†ÊåâÈàïÂØ¨Â∫¶
                        .padding(.vertical, 14) // Â¢ûÂä†ÊåâÈàïÈ´òÂ∫¶
                        .background(Color.customAccent)
                        .cornerRadius(25)
                }
                .padding(.top, 8) // ÊåâÈàï‰∏äÊñπÈñìË∑ù
                .padding(.bottom, 32) // Â∫ïÈÉ®Â¢ûÂä†ÈñìË∑ù
            }
            .frame(width: 280) // Ë®≠ÂÆöÂõ∫ÂÆöÂØ¨Â∫¶
            .background(Color.white)
            .cornerRadius(20)
            .shadow(radius: 10)
            .padding(.horizontal, 40)
        }
        .transition(.opacity)
    }
}

// Êñ∞Â¢û‰∏ÄÂÄãËá™ÂÆöÁæ©ÊåâÈàïÊ®£Âºè
struct NavigationButtonStyle: ButtonStyle {
    var isPrimary: Bool = false
    
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.custom("NotoSansTC-Black", size: 16))
            .foregroundColor(isPrimary ? .white : .customAccent)
            .padding(.horizontal, 20)
            .padding(.vertical, 10)
            .background(
                isPrimary ? Color.customAccent : Color.white
            )
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(Color.customAccent, lineWidth: 1)
            )
            .opacity(configuration.isPressed ? 0.8 : 1.0)
    }
}

// Add hideKeyboard() as a global function
private func hideKeyboard() {
    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                  to: nil, from: nil, for: nil)
}

// Êñ∞Â¢û AppOpenAdManager È°ûÂà•
class AppOpenAdManager: NSObject, GADFullScreenContentDelegate {
    static let shared = AppOpenAdManager()
    
    private var appOpenAd: GADAppOpenAd?
    private var isLoadingAd = false
    private var isShowingAd = false
    private var loadTime: Date?
    
    private let fourHoursInSeconds = TimeInterval(3600 * 4)
    
    override init() {
        super.init()
        loadAd()
    }
    
    private func loadAd() {
        // Â¶ÇÊûúÊ≠£Âú®ËºâÂÖ•Âª£ÂëäÊàñÂ∑≤ÊúâÂèØÁî®Âª£ÂëäÔºåÂâá‰∏çËºâÂÖ•
        if isLoadingAd || isAdAvailable() {
            return
        }
        isLoadingAd = true
        
        print("üì± [AppOpenAd] ÈñãÂßãËºâÂÖ•Âª£Âëä")
        // Task {
        //     do {
        //         appOpenAd = try await GADAppOpenAd.load(
        //             withAdUnitID: "ca-app-pub-3469743877050320/7027134890",
        //             request: GADRequest())
        //         appOpenAd?.fullScreenContentDelegate = self
        //         loadTime = Date()
                
        //         await MainActor.run {
        //             isLoadingAd = false
        //             print("‚úÖ [AppOpenAd] Âª£ÂëäËºâÂÖ•ÊàêÂäü")
        //         }
        //     } catch {
        //         await MainActor.run {
        //             isLoadingAd = false
        //             print("‚ùå [AppOpenAd] Âª£ÂëäËºâÂÖ•Â§±Êïó: \(error.localizedDescription)")
        //         }
        //     }
        // }
    }
    
    func showAdIfAvailable() {
        // Â¶ÇÊûúÂª£ÂëäÊ≠£Âú®È°ØÁ§∫‰∏≠ÔºåÂâá‰∏çÈ°ØÁ§∫
        guard !isShowingAd else { return }
        
        // Â¶ÇÊûúÊ≤íÊúâÂèØÁî®Âª£ÂëäÔºåÂâáËºâÂÖ•Êñ∞Âª£Âëä
        if !isAdAvailable() {
            loadAd()
            return
        }
        
        if let ad = appOpenAd {
            isShowingAd = true
            print("üì± [AppOpenAd] ÈñãÂßãÂ±ïÁ§∫Âª£Âëä")
            if let rootViewController = UIApplication.shared.windows.first?.rootViewController {
                ad.present(fromRootViewController: rootViewController)
            }
        }
    }
    
    private func wasLoadTimeLessThanFourHoursAgo() -> Bool {
        guard let loadTime = loadTime else { return false }
        return Date().timeIntervalSince(loadTime) < fourHoursInSeconds
    }
    
    private func isAdAvailable() -> Bool {
        return appOpenAd != nil && wasLoadTimeLessThanFourHoursAgo()
    }
    
    // MARK: - GADFullScreenContentDelegate
    
    func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        appOpenAd = nil
        isShowingAd = false
        print("üì± [AppOpenAd] Âª£ÂëäÈóúÈñâÔºåÈñãÂßãÈ†êËºâ‰∏ã‰∏ÄÂÄã")
        loadAd()
    }
    
    func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        appOpenAd = nil
        isShowingAd = false
        print("‚ùå [AppOpenAd] Âª£ÂëäÂ±ïÁ§∫Â§±Êïó: \(error.localizedDescription)")
        loadAd()
    }
    
    func adWillPresentFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        print("üì± [AppOpenAd] Âª£ÂëäÂ∞áË¶ÅÂ±ïÁ§∫")
    }
}

// ‰øÆÊîπ AppStateManager
class AppStateManager: ObservableObject {
    private let appOpenAdManager = AppOpenAdManager.shared
    private var lastBackgroundTime: Date?
    private let minimumBackgroundDuration: TimeInterval = 30
    
    init() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleAppBackground),
            name: UIApplication.didEnterBackgroundNotification,
            object: nil
        )
    }
    
    @objc private func handleAppBackground() {
        lastBackgroundTime = Date()
    }
    
    func handleAppForeground() {
        guard let lastBackground = lastBackgroundTime else { return }
        
        let timeInBackground = Date().timeIntervalSince(lastBackground)
        
        if timeInBackground >= minimumBackgroundDuration {
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
                self?.appOpenAdManager.showAdIfAvailable()
            }
        }
        
        lastBackgroundTime = nil
    }
}

// Add these extensions at the bottom of the file
extension String {
    static func randomNonceString(length: Int = 32) -> String {
        precondition(length > 0)
        let charset: [Character] =
        Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")
        var result = ""
        var remainingLength = length
        
        while remainingLength > 0 {
            let randoms: [UInt8] = (0 ..< 16).map { _ in
                var random: UInt8 = 0
                let errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random)
                if errorCode != errSecSuccess {
                    fatalError("Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)")
                }
                return random
            }
            
            randoms.forEach { random in
                if remainingLength == 0 {
                    return
                }
                
                if random < charset.count {
                    result.append(charset[Int(random)])
                    remainingLength -= 1
                }
            }
        }
        return result
    }
}

extension String {
    var sha256: String {
        let inputData = Data(self.utf8)
        let hashedData = SHA256.hash(data: inputData)
        let hashString = hashedData.compactMap {
            String(format: "%02x", $0)
        }.joined()
        
        return hashString
    }
}

// Âú®Ê™îÊ°àÈñãÈ†≠Êñ∞Â¢û QuestionManager È°ûÂà•
class QuestionManager: ObservableObject {
    static let shared = QuestionManager()
    @Published private(set) var questions: [Question] = []
    private let questionsCacheKey = "cachedQuestions"
    private let lastUpdateTimeKey = "questionsLastUpdateTime"
    private let updateInterval: TimeInterval = 24 * 60 * 60 // 24Â∞èÊôÇÊõ¥Êñ∞‰∏ÄÊ¨°
    
    private init() {
        loadCachedQuestions()
    }
    
    private func loadCachedQuestions() {
        if let data = UserDefaults.standard.data(forKey: questionsCacheKey),
           let cachedQuestions = try? JSONDecoder().decode([Question].self, from: data) {
            self.questions = cachedQuestions
        }
    }
    
    func updateQuestionsIfNeeded() async {
        // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
        let lastUpdate = UserDefaults.standard.double(forKey: lastUpdateTimeKey)
        let now = Date().timeIntervalSince1970
        
        guard now - lastUpdate > updateInterval else {
            print("‚úÖ [Questions] ÂïèÈ°åÂ∫´‰ªçÂú®ÊúâÊïàÊúüÂÖßÔºåÁÑ°ÈúÄÊõ¥Êñ∞")
            return
        }
        
        print("üîÑ [Questions] ÈñãÂßãÊõ¥Êñ∞ÂïèÈ°åÂ∫´")
        
        do {
            let db = Firestore.firestore()
            let snapshot = try await db.collection("questions").getDocuments()
            
            var newQuestions: [Question] = []
            
            for document in snapshot.documents {
                if let questionsData = document.get("questions") as? [[String: Any]] {
                    for questionData in questionsData {
                        if let scenario = questionData["question"] as? String,
                           let choicesData = questionData["choices"] as? [String: [String: String]] {
                            
                            let choices = choicesData.values.compactMap { choiceDict -> Choice? in
                                guard let text = choiceDict["text"],
                                      let meaning = choiceDict["meaning"] else {
                                    return nil
                                }
                                return Choice(meaning: meaning, text: text)
                            }
                            
                            let question = Question(question: scenario, choices: choices)
                            newQuestions.append(question)
                        }
                    }
                }
            }
            
            // Êõ¥Êñ∞Âø´Âèñ
            if !newQuestions.isEmpty {
                let encoder = JSONEncoder()
                if let encoded = try? encoder.encode(newQuestions) {
                    UserDefaults.standard.set(encoded, forKey: questionsCacheKey)
                    UserDefaults.standard.set(now, forKey: lastUpdateTimeKey)
                }
                
                await MainActor.run {
                    self.questions = newQuestions
                }
                print("‚úÖ [Questions] ÂïèÈ°åÂ∫´Êõ¥Êñ∞ÊàêÂäü")
            }
            
        } catch {
            print("‚ùå [Questions] Êõ¥Êñ∞ÂïèÈ°åÂ∫´Â§±Êïó: \(error.localizedDescription)")
        }
    }
    
    func getRandomQuestions(_ count: Int) -> [Question] {
        return Array(questions.shuffled().prefix(count))
    }
}

// Add this helper function
private func calculateFontSize(for characterCount: Int) -> CGFloat {
    switch characterCount {
        case 2: return 48 // ÂÖ©ÂÄãÂ≠óÁ∂≠ÊåÅÂéüÂßãÂ§ßÂ∞è
        case 3: return 42 // ‰∏âÂÄãÂ≠óÁ®çÂæÆÁ∏ÆÂ∞è
        case 4: return 36 // ÂõõÂÄãÂ≠óÂÜçÁ∏ÆÂ∞è
        default: return 32 // ÂÖ∂‰ªñÊÉÖÊ≥Å‰ΩøÁî®ÊúÄÂ∞èÂ≠óÈ´î
    }
}
