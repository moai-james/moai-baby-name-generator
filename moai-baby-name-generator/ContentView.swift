//
//  ContentView.swift
//  moai-baby-name-generator
//
//  Created by james hsiao on 2024/10/9.
//
import UIKit
import SwiftUI
import SwiftyGif
import SwiftOpenAI
import GoogleSignIn
import FirebaseCore
import FirebaseAuth
import FirebaseFirestore
import WebKit
import GoogleMobileAds
import StoreKit
import AuthenticationServices
import CryptoKit
import FirebaseAppCheck

// extension Color {
//     static let customBackground = Color("CustomBackground")
//     static let customText = Color("CustomText")
//     static let customAccent = Color("CustomAccent")
//     static let customSecondary = Color("CustomSecondary")
struct BannerView: UIViewControllerRepresentable {
    func makeUIViewController(context: Context) -> UIViewController {
        print("üì± [BannerAd] Starting to create banner view")
        let bannerView = GADBannerView(adSize: GADAdSizeBanner)
        let viewController = UIViewController()
        
        // Ê∏¨Ë©¶Áî®Âª£ÂëäÂñÆÂÖÉ ID,ÁôºÂ∏ÉÊôÇË¶ÅÊèõÊàêÁúüÂØ¶ÁöÑ
        print("üéØ [BannerAd] Setting ad unit ID")
        // bannerView.adUnitID = "ca-app-pub-3469743877050320/3645991765"
        bannerView.adUnitID = "ca-app-pub-3940256099942544/2934735716"
        bannerView.rootViewController = viewController
        
        
        print("üîÑ [BannerAd] Adding banner view to view controller")
        viewController.view.addSubview(bannerView)
        viewController.view.frame = CGRect(origin: .zero, size: GADAdSizeBanner.size)
        
        print("üì§ [BannerAd] Loading banner ad request")
        bannerView.load(GADRequest())
        print("‚úÖ [BannerAd] Banner view setup complete")
        return viewController
    }

    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {}
}

struct ContentView: View {
    @State private var navigationPath = NavigationPath()
    @State private var showSplash = true
    @StateObject private var authViewModel = AuthViewModel()
    @StateObject private var usageManager = UsageManager.shared
    @StateObject private var appStateManager = AppStateManager()
    
    
    var body: some View {
        ZStack {
            NavigationStack(path: $navigationPath) {
                MainView(navigationPath: $navigationPath, 
                        selectedTab: $authViewModel.selectedTab,
                        isLoggedIn: $authViewModel.isLoggedIn,
                        authViewModel: authViewModel)
            }
            .accentColor(.customAccent)

            if showSplash {
                SplashScreenView(showSplash: $showSplash)
                .zIndex(1)
            }
            
            if !showSplash && !authViewModel.isLoggedIn {
                LoginView(authViewModel: authViewModel)
            }
        }
        .onAppear {
            checkExistingAuth()
            
            // Êõ¥Êñ∞ÊèêÁ§∫Ë©ûÊ®°ÊùøÔºåÂä†ÂÖ•ÈåØË™§ËôïÁêÜ
            Task {
                do {
                    await PromptManager.shared.updatePrompts()
                } catch {
                    print("‚ùå [ContentView] Êõ¥Êñ∞ÊèêÁ§∫Ë©ûÊ®°ÊùøÂ§±Êïó: \(error.localizedDescription)")
                    ErrorManager.shared.logError(
                        category: .unknown,
                        message: "ContentView ÂïüÂãïÊôÇÊõ¥Êñ∞ÊèêÁ§∫Ë©ûÊ®°ÊùøÂ§±Êïó",
                        details: ["error": error.localizedDescription]
                    )
                }
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
            appStateManager.handleAppForeground()
        }
    }
    
    private func checkExistingAuth() {
        if let user = Auth.auth().currentUser {
            print("üë§ Found existing user: \(user.uid)")
            user.getIDTokenResult { tokenResult, error in
                if let error = error {
                    print("‚ùå Token È©óË≠âÈåØË™§: \(error.localizedDescription)")
                    self.authViewModel.isLoggedIn = false
                    return
                }
                
                guard let tokenResult = tokenResult else {
                    print("‚ùå No token result")
                    self.authViewModel.isLoggedIn = false
                    return
                }
                
                if tokenResult.expirationDate > Date() {
                    print("‚úÖ Token is valid")
                    authViewModel.handleSuccessfulLogin()
                } else {
                    print("üîÑ Token expired, refreshing...")
                    user.getIDTokenForcingRefresh(true) { _, error in
                        if let error = error {
                            print("‚ùå Token Âà∑Êñ∞ÈåØË™§: \(error.localizedDescription)")
                            self.authViewModel.isLoggedIn = false
                        } else {
                            print("‚úÖ Token refreshed successfully")
                            authViewModel.handleSuccessfulLogin()
                        }
                    }
                }
            }
        } else {
            print("üë§ No existing user found")
            self.authViewModel.isLoggedIn = false
        }
    }

}

struct LoginView: View {
    @ObservedObject var authViewModel: AuthViewModel
    @State private var errorMessage: String?
    @Environment(\.colorScheme) var colorScheme
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @State private var isLoading = false
    @State private var showPhoneVerification = false
    @State private var showVerificationCode = false
    @State private var mfaResolver: MultiFactorResolver?
    @State private var lastSMSRequestTime: Date?
    @State private var cooldownRemaining: Int = 0
    let smsCooldownDuration: Int = 60 // ÂÜ∑ÂçªÊôÇÈñìÔºàÁßíÔºâ
    
    let textColor = Color(hex: "#FF798C")
    
    var body: some View {
        ZStack {
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 20) {
                HStack(alignment: .center, spacing: 0) {
                    Image("login_mascot")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 180)
                        .offset(x:-15)
                        
                    Text("Ê≠°ËøéÂä†ÂÖ•")
                        .font(.custom("NotoSansTC-Black", size: 32))
                        .foregroundColor(textColor)
                        .offset(x:-20, y:10)
                        .bold()
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                
                
                
                // if let errorMessage = errorMessage {
                //     Text(errorMessage)
                //         .foregroundColor(.red)
                //         .font(.custom("NotoSansTC-Regular", size: 14))
                // }
                
                Button(action: signInWithGoogle) {
                    HStack {
                        Image("GoogleLogo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 17)
                        Text("‰ΩøÁî® Google Â∏≥ËôüÁôªÂÖ•")
                            .font(.custom("NotoSansTC-Black", size: 16))
                            .bold()
                    }
                    .foregroundColor(textColor)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(textColor, lineWidth: 1)
                    )
                }
                
                Button(action: signInWithApple) {
                    HStack {
                        Image(systemName: "apple.logo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 17)
                        Text("‰ΩøÁî® Apple Â∏≥ËôüÁôªÂÖ•")
                            .font(.custom("NotoSansTC-Black", size: 16))
                            .bold()
                    }
                    .foregroundColor(textColor)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(textColor, lineWidth: 1)
                    )
                }
                
                Button(action: signInAsGuest) {
                    HStack {
                        Image(systemName: "person.fill")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 17)
                        Text("‰ª•Ë®™ÂÆ¢Ë∫´‰ªΩ‰ΩøÁî®")
                            .font(.custom("NotoSansTC-Black", size: 16))
                            .bold()
                    }
                    .foregroundColor(textColor)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(textColor, lineWidth: 1)
                    )
                }
                
                // Spacer()
            
                // Version information
                if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String,
                let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
                    Text("Version \(version) (\(build))")
                        .font(.footnote)
                        .foregroundColor(.gray)
                        .padding(.bottom, 10)
                }

            }
            .padding(.horizontal, 30)
            
            // Phone Verification Sheet
            .sheet(isPresented: $authViewModel.showPhoneVerification, onDismiss: {
                authViewModel.resetVerificationState()
            }) {
                NavigationView {
                    VStack(spacing: 20) {
                        // Phone number input
                        CustomTextField(
                            placeholder: "Ë´ãËº∏ÂÖ•ÊâãÊ©üËôüÁ¢º",
                            text: $authViewModel.phoneNumber,
                            keyboardType: .phonePad
                        )
                        .padding(.horizontal)
                        
                        if authViewModel.canResetPhoneNumber {
                            // È°ØÁ§∫ÈáçË®≠ÊâãÊ©üËôüÁ¢ºÁöÑÈÅ∏È†Ö
                            HStack {
                                Text("ÊâãÊ©üËôüÁ¢ºËº∏ÂÖ•ÈåØË™§Ôºü")
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.gray)
                                
                                Button("ÈáçÊñ∞Ëº∏ÂÖ•ËôüÁ¢º") {
                                    authViewModel.resetPhoneNumberInput()
                                }
                                .font(.custom("NotoSansTC-Regular", size: 14))
                                .foregroundColor(.customAccent)
                            }
                            .padding(.horizontal)
                        }
                        
                        if authViewModel.verificationID != nil {
                            // Verification code input
                            CustomTextField(
                                placeholder: "Ë´ãËº∏ÂÖ•È©óË≠âÁ¢º",
                                text: $authViewModel.verificationCode,
                                keyboardType: .numberPad,
                                textContentType: .oneTimeCode  // Ê∑ªÂä†ÈÄôË°å‰æÜÊîØÊåÅËá™ÂãïÂ°´ÂÖÖÁ∞°Ë®äÈ©óË≠âÁ¢º
                            )
                            .padding(.horizontal)
                            .onChange(of: authViewModel.verificationCode) { newValue in
                                // Áï∂È©óË≠âÁ¢ºÊîπËÆäÊôÇÔºåÊ™¢Êü•ÊòØÂê¶ÁÇ∫ÂæûÂâ™Ë≤ºÁ∞øË≤º‰∏äÁöÑÂÖßÂÆπ
                                if let pasteboardString = UIPasteboard.general.string,
                                   pasteboardString.count == 6,  // ÂÅáË®≠È©óË≠âÁ¢ºÁÇ∫ 6 ‰ΩçÊï∏
                                   pasteboardString.allSatisfy({ $0.isNumber }) {
                                    authViewModel.verificationCode = pasteboardString
                                }
                            }
                            
                            // Countdown timer and resend button
                            HStack {
                                if let remainingTime = authViewModel.remainingTime {
                                    Text("È©óË≠âÁ¢ºÊúâÊïàÊôÇÈñìÔºö\(remainingTime)Áßí")
                                        .font(.custom("NotoSansTC-Regular", size: 14))
                                        .foregroundColor(.gray)
                                    
                                    if remainingTime == 0 {
                                        Button("ÈáçÊñ∞ÁôºÈÄÅ") {
                                            authViewModel.sendVerificationCode()
                                        }
                                        .font(.custom("NotoSansTC-Regular", size: 14))
                                        .foregroundColor(.customAccent)
                                    }
                                }
                            }
                            .padding(.horizontal)
                            
                            // Verify button with loading state
                            Button(action: {
                                authViewModel.verifyCode()
                            }) {
                                HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                    if authViewModel.isLoading {
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    } else {
                                        Text("È©óË≠â")
                                    }
                                }
                                .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                                .padding()
                                .background(authViewModel.isLoading ? Color.gray : Color.customAccent)
                                .foregroundColor(.white)
                                .cornerRadius(25)
                            }
                            .padding(.horizontal)
                            .disabled(authViewModel.isLoading)
                        } else {
                            // Send code button
                            Button(action: {
                                authViewModel.sendVerificationCode()
                            }) {
                                HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                    if authViewModel.isLoading {
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    } else {
                                        Text(authViewModel.displayCooldownTime > 0 
                                            ? "Ë´ãÁ≠âÂæÖ \(authViewModel.displayCooldownTime) Áßí"
                                            : "ÁôºÈÄÅÈ©óË≠âÁ¢º")
                                    }
                                }
                                .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                                .padding()
                                .background(
                                    authViewModel.displayCooldownTime > 0 || authViewModel.isLoading 
                                        ? Color.gray 
                                        : Color.customAccent
                                )
                                .foregroundColor(.white)
                                .cornerRadius(25)
                            }
                            .padding(.horizontal)
                            .disabled(authViewModel.displayCooldownTime > 0 || authViewModel.isLoading)
                        }
                        
                        if let error = authViewModel.errorMessage {
                            Text(error)
                                .font(.custom("NotoSansTC-Regular", size: 14))
                                .foregroundColor(.red)
                                .padding()
                        }
                        
                        Spacer()
                    }
                    .padding(.top)
                    .navigationTitle("ÈõôÈáçÈ©óË≠âË®≠ÂÆö")
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationBarItems(trailing: Button("ÂèñÊ∂à") {
                        authViewModel.showPhoneVerification = false
                    }
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    )
                    .onAppear {
                        authViewModel.resetVerificationState()
                    }
                }
            }
            
            // Loading overlay
            if isLoading {
                Color.black.opacity(0.5)
                    .edgesIgnoringSafeArea(.all)
                
                VStack {
                    ProgressView()
                        .scaleEffect(1.5)
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    Text("ÁôªÂÖ•‰∏≠...")
                        .foregroundColor(.white)
                        .padding(.top)
                }
            }
        }
        .sheet(isPresented: $showVerificationCode) {
            if let resolver = mfaResolver {
                VerificationCodeView(resolver: resolver)
            }
        }
    }

    private func signInWithGoogle() {
        guard let clientID = FirebaseApp.app()?.options.clientID else { 
            print("‚ùå ÁÑ°Ê≥ïÁç≤Âèñ clientID")
            return 
        }
        
        // Ë®≠ÁΩÆ loading ÁãÄÊÖã
        isLoading = true
        
        print("‚úÖ ÈñãÂßã Google ÁôªÂÖ•ÊµÅÁ®ã")
        print("ClientID: \(clientID)")
        
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.keyWindow ?? windowScene.windows.first,
              let rootViewController = window.rootViewController else {
            isLoading = false  // Â¶ÇÊûúÂ§±ÊïóË¶ÅÈóúÈñâ loading
            print("‚ùå ÁÑ°Ê≥ïÁç≤Âèñ rootViewController")
            return
        }
        
        print("‚úÖ Ê∫ñÂÇôÈ°ØÁ§∫ Google ÁôªÂÖ•Ë¶ñÁ™ó")
        
        GIDSignIn.sharedInstance.signIn(withPresenting: rootViewController) { [self] result, error in
            if let error = error {
                print("‚ùå Google ÁôªÂÖ•ÈåØË™§: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                isLoading = false  // ÁôªÂÖ•Â§±ÊïóÈóúÈñâ loading
                return
            }
            
            print("‚úÖ Google ÁôªÂÖ•ÊàêÂäü")
            guard let user = result?.user,
                  let idToken = user.idToken?.tokenString else {
                isLoading = false  // Ë≥áÊñôÁÑ°ÊïàÈóúÈñâ loading
                return
            }
            
            let credential = GoogleAuthProvider.credential(withIDToken: idToken, accessToken: user.accessToken.tokenString)
            
            Auth.auth().signIn(with: credential) { [self] authResult, error in
                // ÂÆåÊàêÊôÇÈóúÈñâ loading
                defer { isLoading = false }
                
                if let error = error as NSError? {
                    if error.domain == AuthErrorDomain,
                       error.code == AuthErrorCode.secondFactorRequired.rawValue {
                        // Handle MFA
                        print(" Auth.auth().currentUser: \(String(describing: Auth.auth().currentUser))")
                        authViewModel.mfaResolver = error.userInfo[AuthErrorUserInfoMultiFactorResolverKey] as? MultiFactorResolver
                        authViewModel.showPhoneVerification = true
                    } else {
                        errorMessage = error.localizedDescription
                    }
                } else {
                    print(" Auth.auth().currentUser: \(String(describing: Auth.auth().currentUser))")
                    print("‚úÖ googleÁôªÂÖ•ÊàêÂäü")
                    authViewModel.handleSuccessfulLogin()
                }
            }           
        }
    }
    
    private func signInWithApple() {
        isLoading = true  // ÈñãÂßãËºâÂÖ•
        appleSignInCoordinator = AppleSignInCoordinator()
        appleSignInCoordinator?.startSignInWithAppleFlow { result in
            // ÂÆåÊàêÊôÇÈóúÈñâ loading
            defer { isLoading = false }
            
            switch result {
            case .success(_):
                authViewModel.handleSuccessfulLogin()
            case .failure(let error):
                errorMessage = error.localizedDescription
            }
        }
    }
    
    private func signInAsGuest() {
        isLoading = true  // ÈñãÂßãËºâÂÖ•
        
        // Ê∏ÖÁ©∫Êî∂ËóèÂàóË°®
        UserDefaults.standard.removeObject(forKey: "FavoriteNames")
        
        Auth.auth().signInAnonymously { [self] authResult, error in
            // ÂÆåÊàêÊôÇÈóúÈñâ loading
            defer { isLoading = false }
            
            if let error = error {
                print("‚ùå Ë®™ÂÆ¢ÁôªÂÖ•ÈåØË™§: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                return
            }
            
            guard let user = authResult?.user else {
                print("‚ùå ÁÑ°Ê≥ïÁç≤ÂèñÁî®Êà∂Ë≥áË®ä")
                return
            }
            
            print("‚úÖ ÂâµÂª∫Êñ∞ÁöÑÂåøÂêçÂ∏≥Ëôü")
            print("üë§ Áî®Êà∂ ID: \(user.uid)")
            print("üîë ÊòØÂê¶ÁÇ∫ÂåøÂêçÁî®Êà∂: \(user.isAnonymous)")
            
            // Âú® Firestore ‰∏≠ÂâµÂª∫Áî®Êà∂ÊñáÊ™î
            let db = Firestore.firestore()
            db.collection("users").document(user.uid).setData([
                "isAnonymous": true,
                "createdAt": FieldValue.serverTimestamp(),
                "lastLoginAt": FieldValue.serverTimestamp(),
                "favorites": [] // Á¢∫‰øùÊî∂ËóèÂàóË°®ÁÇ∫Á©∫
            ], merge: true) { error in
                if let error = error {
                    print("‚ùå ÂâµÂª∫Áî®Êà∂ÊñáÊ™îÂ§±Êïó: \(error.localizedDescription)")
                } else {
                    print("‚úÖ ÂâµÂª∫Áî®Êà∂ÊñáÊ™îÊàêÂäü")
                }
            }
            
            authViewModel.handleSuccessfulLogin()
        }
    }

    private func startCooldownTimer() {
        // Ë®≠ÁΩÆÊúÄÂæåÁôºÈÄÅÊôÇÈñì
        lastSMSRequestTime = Date()
        // ÈñãÂßãÂÄíÊï∏Ë®àÊôÇ
        cooldownRemaining = smsCooldownDuration
        
        // ÂâµÂª∫Ë®àÊôÇÂô®‰æÜÊõ¥Êñ∞Ââ©È§òÊôÇÈñì
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
            if cooldownRemaining > 0 {
                cooldownRemaining -= 1
            } else {
                timer.invalidate()
            }
        }
    }
    
    private func canSendSMS() -> Bool {
        guard let lastRequest = lastSMSRequestTime else { return true }
        let timeSinceLastRequest = Date().timeIntervalSince(lastRequest)
        return timeSinceLastRequest >= Double(smsCooldownDuration)
    }
}

struct CustomTextField: View {
    let placeholder: String
    @Binding var text: String
    var keyboardType: UIKeyboardType = .default
    var autocapitalization: TextInputAutocapitalization = .sentences
    var isSecure: Bool = false
    var validation: ((String) -> Bool)?
    var errorMessage: String?
    var textContentType: UITextContentType? = nil
    var returnKeyType: UIReturnKeyType = .done
    var cooldownRemaining: Int? = nil
    
    @State private var isValid: Bool = true
    @State private var showError: Bool = false
    @FocusState private var isFocused: Bool  // Êñ∞Â¢û FocusState
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            if isSecure {
                SecureField(placeholder, text: $text)
                    .textFieldStyle(CustomTextFieldStyle())
                    .keyboardType(keyboardType)
                    .textInputAutocapitalization(autocapitalization)
                    .textContentType(textContentType)
                    .submitLabel(.done)
                    .focused($isFocused)  // Ê∑ªÂä† focused ‰øÆÈ£æÁ¨¶
                    .onTapGesture {  // Ê∑ªÂä†ÈªûÊìäÊâãÂã¢
                        isFocused = true
                    }
                    .onChange(of: text) { newValue in
                        validateInput(newValue)
                    }
            } else {
                TextField(placeholder, text: $text)
                    .textFieldStyle(CustomTextFieldStyle())
                    .keyboardType(keyboardType)
                    .textInputAutocapitalization(autocapitalization)
                    .textContentType(textContentType)
                    .submitLabel(.done)
                    .focused($isFocused)  // Ê∑ªÂä† focused ‰øÆÈ£æÁ¨¶
                    .onTapGesture {  // Ê∑ªÂä†ÈªûÊìäÊâãÂã¢
                        isFocused = true
                    }
                    .onChange(of: text) { newValue in
                        validateInput(newValue)
                    }
            }
            
            if showError, let errorMessage = errorMessage {
                Text(errorMessage)
                    .font(.caption)
                    .foregroundColor(.red)
                    .padding(.leading, 4)
            }
            
            if let cooldown = cooldownRemaining, cooldown > 0 {
                Text("\(cooldown) ÁßíÂæåÂèØÈáçÊñ∞ÁôºÈÄÅ")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
        }
    }
    
    private func validateInput(_ value: String) {
        if let validation = validation {
            isValid = validation(value)
            showError = !isValid && !value.isEmpty
        }
    }
}

struct CustomTextFieldStyle: TextFieldStyle {
    func _body(configuration: TextField<Self._Label>) -> some View {
        configuration
            .padding()
            .background(Color.white)
            .cornerRadius(25)
            .overlay(
                RoundedRectangle(cornerRadius: 25)
                    .stroke(Color.customAccent, lineWidth: 1)
            )
    }
}

extension View {
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content) -> some View {

        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }

        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

struct MainView: View {
    // Navigation and tab state
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int
    @Binding var isLoggedIn: Bool
    
    // View models
    @ObservedObject var authViewModel: AuthViewModel
    @StateObject private var rewardedViewModel = RewardedViewModel()
    @StateObject private var usageManager = UsageManager.shared
    @StateObject private var interstitialAd = InterstitialAdViewModel()
    @StateObject private var iapManager = IAPManager.shared
    @ObservedObject private var taskManager = TaskManager.shared
    
    // Environment and storage
    @Environment(\.colorScheme) var colorScheme
    @AppStorage("isDarkMode") private var isDarkMode = false
    @AppStorage("favoriteTabCount") private var favoriteTabCount = 0
    
    // Alert states
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var showPhoneVerification = false
    @State private var showDeleteAccountAlert = false
    @State private var showTwoFactorAlert = false
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @State private var upgradeErrorMessage: String? // Renamed to avoid conflict
    @State private var showUpgradeError = false
    @State private var isUpgrading = false
    
    // Add new state for showing account linking options
    @State private var showAccountLinkingOptions = false
    @State private var showSerialNumberInput = false

    // Ê∑ªÂä†Êñ∞ÁöÑ state ËÆäÊï∏
    @State private var showCharCountError = false
    @State private var generatedNameWithError: String = ""

    var body: some View {
        ZStack {
            // Main content area
            ZStack {
                if selectedTab == 0 {
                    homeView
                } else if selectedTab == 1 {
                    VStack {
                        Text("Êî∂Ëóè")
                            .font(.custom("NotoSansTC-Black", size: 32))
                            .foregroundColor(.customText)
                            .padding(.top, 20)
                        FavoritesListView()
                    }
                } else if selectedTab == 2 {
                    StoreView()
                } else if selectedTab == 3 {
                    settingsView
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
                
            // Tab bar with banner ad
            VStack(spacing: 0) {
                Spacer()
                    
                // Add banner ad
                BannerView()
                    .frame(width: GADAdSizeBanner.size.width, height: GADAdSizeBanner.size.height)
                    
                // Tab bar
                HStack(spacing: 20) {
                    Spacer()
                    TabBarButton(imageName: "home_icon", isSelected: selectedTab == 0) { 
                        selectedTab = 0 
                    }
                    Spacer()
                    TabBarButton(imageName: "favs_icon", isSelected: selectedTab == 1) { 
                        // Show interstitial ad when switching to favorites tab
                        if selectedTab != 1 {
                            favoriteTabCount += 1
                            if favoriteTabCount >= 3 {
                                interstitialAd.showAd()
                                favoriteTabCount = 0  // Reset counter
                            }
                        }
                        selectedTab = 1
                    }
                    Spacer()
                    TabBarButton(imageName: "store_icon", isSelected: selectedTab == 2) { 
                        selectedTab = 2 
                    }
                    Spacer()
                    TabBarButton(imageName: "setting_icon", isSelected: selectedTab == 3, action: { 
                        selectedTab = 3 
                    }, badgeCount: taskManager.missions.filter { !$0.isRewardClaimed }.count)
                    // TabBarButton(imageName: "setting_icon", isSelected: selectedTab == 3, badgeCount: 0) { 
                    //     selectedTab = 3 
                    // }
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.vertical , 10)
                .frame(maxWidth: .infinity)
                .background(Color.tabbar)
                .cornerRadius(25, corners: [.topLeft, .topRight])
            }
            .ignoresSafeArea(edges: .bottom)
        }
        .navigationDestination(for: String.self) { destination in
            if destination == "FormView" {
                FormView(navigationPath: $navigationPath, 
                        selectedTab: $selectedTab,
                        isLoggedIn: $authViewModel.isLoggedIn,
                        authViewModel: authViewModel)
                .background(Color.black.opacity(0.3))
                .transition(.identity)
            }
        }
        .navigationDestination(for: FormData.self) { formData in
            DesignFocusView(navigationPath: $navigationPath, formData: formData)
            .transition(.identity)
        }
        .navigationDestination(for: FormWithDesignData.self) { formWithDesignData in
            SpecialRequirementView(navigationPath: $navigationPath, 
                                 formWithDesignData: formWithDesignData,
                                 selectedTab: $selectedTab)
            .transition(.identity)
        }
        .preferredColorScheme(isDarkMode ? .dark : .light)
        .onAppear {
            // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈ°ØÁ§∫ÈõôÈáçÈ©óË≠âÊèêÈÜí
            if UserDefaults.standard.bool(forKey: "shouldShowTwoFactorAlert") {
                showTwoFactorAlert = true
                UserDefaults.standard.set(false, forKey: "shouldShowTwoFactorAlert")
            }
        }
    }
   
    var homeView: some View {
        ZStack {
            GeometryReader { geometry in
                VStack() {
                    // Header ‰øùÊåÅÂú®Â§ñÂ±§
                    VStack(spacing: 0) {
                        Color.black.frame(height: 0)
                        HStack {
                            Spacer()
                            Text("ÂçÉÂ∞ãAIÂëΩÂêç")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.white)
                            Spacer()
                        }
                        .padding(.vertical, 8)
                        .background(Color.black)
                        Color.pink.frame(height: 5)
                    }.zIndex(1)
                    
                    // Content area
                    VStack(spacing: 0) {
                        Spacer()
                            .frame(height: geometry.size.height * 0.03) // Ê∏õÂ∞ëÈ†ÇÈÉ®ÈñìË∑ùÔºåÂõ†ÁÇ∫Â∑≤Á∂ìÊúâ header
                        
                        // ‰∏ªË¶ÅÂúñÁ§∫ÂçÄÂüü
                        ZStack {
                            Circle()
                                .fill(Color.white)
                                .frame(
                                    width: min(geometry.size.width * 0.9, 380),
                                    height: min(geometry.size.width * 0.9, 375)
                                )
                                .opacity(0.5)
                            
                            Image("main_mascot")
                                .resizable()
                                .scaledToFit()
                                .frame(
                                    width: min(geometry.size.width * 0.6, 260),
                                    height: min(geometry.size.width * 0.6, 260)
                                )
                        }
                        .frame(width: geometry.size.width)
                        .frame(height: geometry.size.height * 0.35)
                        
                        // ÈñãÂßãÂèñÂêçÊåâÈàï
                        Button(action: {
                            if usageManager.remainingUses > 0 {
                                // Ë®òÈåÑÈñãÂßãÂ∞éËà™
                                // NavigationErrorTracker.shared.logNavigationError(
                                //     type: "navigation_start",
                                //     details: [
                                //         "remaining_uses": "\(usageManager.remainingUses)",
                                //         "button_action": "start_naming"
                                //     ],
                                //     navigationState: "main_to_form"
                                // )
                                
                                // Ë®òÈåÑÁï∂ÂâçË∑ØÂæë
                                let currentPath = navigationPath
                                
                                // ÂòóË©¶Â∞éËà™
                                DispatchQueue.main.async {
                                    navigationPath.append("FormView")
                                }
                                
                                // Ë®≠ÂÆöÊ™¢Êü•Ë®àÊôÇÂô®
                                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                    // Âè™Âú®Â∞éËà™Â§±ÊïóÊôÇË®òÈåÑÈåØË™§
                                    if navigationPath == currentPath {
                                        // Â∞éËà™Â§±ÊïóÔºåË®òÈåÑÈåØË™§
                                        NavigationErrorTracker.shared.logNavigationError(
                                            type: "navigation_failed",
                                            details: [
                                                "error": "Navigation timeout",
                                                "current_path": "\(currentPath)",
                                                "new_path": "\(navigationPath)",
                                                "remaining_uses": "\(usageManager.remainingUses)",
                                                "device_orientation": UIDevice.current.orientation.rawValue.description,
                                                "background_refresh_status": UIApplication.shared.backgroundRefreshStatus.rawValue.description
                                            ],
                                            navigationState: "stuck_at_main"
                                        )
                                        
                                        print("‚ö†Ô∏è Navigation failed, attempting recovery...")
                                        
                                        // ÂòóË©¶ÈáçÁΩÆÂ∞éËà™
                                        // DispatchQueue.main.async {
                                        //     navigationPath = NavigationPath()
                                        //     navigationPath.append("FormView")
                                        // }
                                    }
                                }
                            } else {
                                showAlert = true
                            }
                        }) {    
                            Text("ÈñãÂßãÂëΩÂêç")
                                .font(.custom("NotoSansTC-Black", size: min(32, geometry.size.width * 0.08)))
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, geometry.size.height * 0.02)
                                .cornerRadius(25)
                                .tracking(20)
                        }
                        .background(
                            Image("naming_button")
                                .resizable()
                                .scaledToFill()
                        )
                        .frame(width: geometry.size.width * 0.8)
                        .padding(.horizontal, 20)
                        .padding(.vertical, geometry.size.height * 0.03)
                        
                        Spacer()
                            .frame(height: geometry.size.height * 0.05) // ÊåâÈàïÂíå‰ΩøÁî®Ê¨°Êï∏Âç°Áâá‰πãÈñìÁöÑÈñìË∑ù
                        
                        // ‰ΩøÁî®Ê¨°Êï∏ÂíåÂª£ÂëäÊåâÈàïÂç°Áâá
                        VStack(spacing: geometry.size.height * 0.015) {
                            VStack(spacing: geometry.size.height * 0.01) {
                                Text("\(usageManager.remainingUses)")
                                    .font(.custom("NotoSansTC-Black", size: min(36, geometry.size.width * 0.09)))
                                    .foregroundColor(.customText)
                                    .bold()
                                
                                Text("Ââ©È§ò‰ΩøÁî®Ê¨°Êï∏")
                                    .font(.custom("NotoSansTC-Regular", size: min(16, geometry.size.width * 0.04)))
                                    .foregroundColor(.customText)
                            }
                            
                            Button(action: {
                                rewardedViewModel.showAd()
                            }) {
                                HStack {
                                    Image(systemName: "play.circle.fill")
                                    Text(rewardedViewModel.remainingCooldown > 0 
                                        ? "Ë´ãÁ≠âÂæÖ \(rewardedViewModel.remainingCooldown) Áßí"
                                        : "ËßÄÁúãÂª£ÂëäÁç≤Âæó3Ê¨°‰ΩøÁî®Ê©üÊúÉ")
                                        .font(.custom("NotoSansTC-Regular", size: min(16, geometry.size.width * 0.04)))
                                }
                                .foregroundColor(.customText)
                                .padding(.vertical, geometry.size.height * 0.015)
                                .padding(.horizontal, geometry.size.width * 0.04)
                                .background(Color.white.opacity(0.8))
                                .cornerRadius(25)
                            }
                            .disabled(!rewardedViewModel.isAdLoaded || rewardedViewModel.remainingCooldown > 0)
                            .opacity(rewardedViewModel.isAdLoaded && rewardedViewModel.remainingCooldown == 0 ? 1 : 0.5)
                        }
                        .padding(.vertical, geometry.size.height * 0.02)
                        .padding(.horizontal, geometry.size.width * 0.04)
                        .background(
                            RoundedRectangle(cornerRadius: 20)
                                .fill(Color.white.opacity(0.5))
                        )
                        .padding(.horizontal, geometry.size.width * 0.04)
                        
                        Spacer()
                            .frame(height: geometry.size.height * 0.05) // Banner Âª£Âëä‰∏äÊñπÁöÑÈñìË∑ù
                    }
                }
            }
        }
        .background(
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
        )
        .onAppear {
            // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈ°ØÁ§∫ÈõôÈáçÈ©óË≠âÊèêÈÜí
            if UserDefaults.standard.bool(forKey: "shouldShowTwoFactorAlert") {
                showTwoFactorAlert = true
                UserDefaults.standard.set(false, forKey: "shouldShowTwoFactorAlert")
            }
        }
        .alert("ÊèêÂçáÂ∏≥ËôüÂÆâÂÖ®", isPresented: $showTwoFactorAlert) {
            Button("Á®çÂæåÂÜçË™™") { }
            Button("ÂâçÂæÄË®≠ÂÆö") {
                selectedTab = 3  // ÂàáÊèõÂà∞Ë®≠ÂÆöÈ†ÅÈù¢
                // Ëß∏ÁôºÈõôÈáçÈ©óË≠âÊåâÈàï
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                    authViewModel.showPhoneVerification = true
                }
            }
        } message: {
            Text("Âª∫Ë≠∞ÊÇ®ÈñãÂïüÈõôÈáçÈ©óË≠â‰ª•ÊèêÂçáÂ∏≥ËôüÂÆâÂÖ®ÊÄß")
        }
    }

    private var settingsView: some View {
        VStack(spacing: 0) {
            // È†ÇÈÉ®ÂçÄÂüüÔºöÈ†≠ÂÉèÂíåÊãõÂëºË™û
            HStack(alignment: .center, spacing: 12) {
                // Áî®Êà∂È†≠ÂÉè
                if let user = Auth.auth().currentUser, let photoURL = user.photoURL {
                    AsyncImage(url: photoURL) { image in
                        image
                            .resizable()
                            .scaledToFit()
                            .frame(width: 40, height: 40)
                            .clipShape(Circle())
                    } placeholder: {
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                    }
                } else {
                    Image(systemName: "person.circle.fill")
                        .resizable()
                        .frame(width: 40, height: 40)
                        .foregroundColor(.gray)
                }
                
                // ÊãõÂëºË™û
                VStack(alignment: .leading, spacing: 4) {
                    Text("Ê≠°ËøéÂõû‰æÜ")
                        .font(.custom("NotoSansTC-Regular", size: 16))
                        .foregroundColor(.gray)
                    if let user = Auth.auth().currentUser {
                        Text(user.displayName ?? "‰ΩøÁî®ËÄÖ")
                            .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                    }
                }
                
                Spacer()
                
                // ÁôªÂá∫ÊåâÈàï
                Button(action: logOut) {
                    Image(systemName: "rectangle.portrait.and.arrow.right")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 24, height: 24)
                        .foregroundColor(.red)
                }
            }
            .padding(.horizontal, 20)
            .padding(.top, 20)
            .padding(.bottom, 10)
            
            // Main content area
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Add Security section
                    if Auth.auth().currentUser?.isAnonymous == true {
                        VStack(alignment: .leading, spacing: 15) {
                            Text("Á∂ÅÂÆöÂ∏≥Ëôü")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.customText)
                            
                            Button(action: {
                                showAccountLinkingOptions = true
                            }) {
                                SettingRow(
                                    icon: "person.badge.plus", 
                                    title: "Á∂ÅÂÆöÂ∏≥Ëôü",
                                    isLoading: isUpgrading
                                )
                            }
                            .disabled(isUpgrading)
                            .actionSheet(isPresented: $showAccountLinkingOptions) {
                                ActionSheet(
                                    title: Text("ÈÅ∏ÊìáÁ∂ÅÂÆöÊñπÂºè"),
                                    buttons: [
                                        .default(Text("‰ΩøÁî® Google Â∏≥Ëôü")) {
                                            isUpgrading = true
                                            upgradeWithGoogle()
                                        },
                                        .default(Text("‰ΩøÁî® Apple Â∏≥Ëôü")) {
                                            isUpgrading = true
                                            upgradeWithApple()
                                        },
                                        .cancel(Text("ÂèñÊ∂à"))
                                    ]
                                )
                            }
                            .tint(.customAccent) // ‰ΩøÁî® tint modifier ‰æÜË®≠ÁΩÆÊï¥ÂÄã ActionSheet ÁöÑ‰∏ªÈ°åËâ≤
                        }
                        .padding(.horizontal)
                    }

                    else {
                        VStack(alignment: .leading, spacing: 15) {
                            Text("ÂÆâÂÖ®")
                                .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                        
                            Button(action: {
                                authViewModel.showPhoneVerification = true
                            }) {
                                SettingRow(icon: "lock.shield.fill", title: authViewModel.isTwoFactorAuthenticated ? "Â∑≤ÈõôÈáçÈ©óË≠â" : "ÈõôÈáçÈ©óË≠â")
                            }
                                .opacity(authViewModel.isTwoFactorAuthenticated ? 0.6 : 1) // Â¶ÇÊûúÂ∑≤È©óË≠âÂâáÈôç‰ΩéÈÄèÊòéÂ∫¶
                                .disabled(authViewModel.isTwoFactorAuthenticated)
                        }
                        .padding(.horizontal)

                        // Êñ∞Â¢û‰ªªÂãô‰∏≠ÂøÉÂçÄÂ°ä
                        VStack(alignment: .leading, spacing: 15) {
                            Text("‰ªªÂãô")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.customText)
                            
                            NavigationLink(destination: TaskListView()) {
                                SettingRow(
                                    icon: "list.star",
                                    title: "‰ªªÂãô‰∏≠ÂøÉ",
                                    textColor: .customText,
                                    badge: taskManager.tabBadgeCount > 0 ? "\(taskManager.tabBadgeCount)" : nil
                                )
                            }
                        }
                        .padding(.horizontal)
                    }
                    
                    
                    
                    // Ë≥áË®äÂçÄÂüü
                    VStack(alignment: .leading, spacing: 15) {
                        Text("Ë≥áË®ä")
                            .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                        
                        Button(action: {
                            if let url = URL(string: "https://moai.tw") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            SettingRow(icon: "info.circle.fill", title: "ÈóúÊñºÂçÉÂ∞ã")
                        }
                        
                        NavigationLink(destination: TermsAndPrivacyView()) {
                            SettingRow(icon: "doc.text.fill", title: "ÊúçÂãôÊ¢ùÊ¨æËàáÈö±ÁßÅÊ¨ä")
                        }
                        
                        Button(action: {
                            if let url = URL(string: "https://lin.ee/HtLRDoX") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            SettingRow(
                                icon: "line", 
                                title: "ÂÆòÊñπLINE",
                                iconColor: Color(hex: "#FF798C"),
                                isCustomImage: true
                            )
                        }
                    }
                    .padding(.horizontal)
                    
                    // Âú® settingsView ÁöÑ VStack ‰∏≠ÔºåÂú®ÊúÄÂæå‰∏ÄÂÄãÂçÄÂ°äÂæåÊ∑ªÂä†Ôºö
                    VStack(alignment: .leading, spacing: 15) {
                        Text("Â∏≥Ëôü")
                            .font(.custom("NotoSansTC-Black", size: 20))
                            .foregroundColor(.customText)
                        
                        Button(action: {
                            showDeleteAccountAlert = true
                        }) {
                            SettingRow(
                                icon: "person.crop.circle.badge.minus",
                                title: "Âà™Èô§Â∏≥Ëôü",
                                textColor: .red
                            )
                        }
                    }
                    .padding(.horizontal)
                    .alert("Á¢∫Ë™çÂà™Èô§Â∏≥Ëôü", isPresented: $showDeleteAccountAlert) {
                        Button("ÂèñÊ∂à", role: .cancel) { }
                        Button("Âà™Èô§", role: .destructive) {
                            deleteAccount()
                        }
                    } message: {
                        Text("Ê≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©ÂéüÔºåÊÇ®Á¢∫ÂÆöË¶ÅÊ∞∏‰πÖÂà™Èô§ÊÇ®ÁöÑÂ∏≥ËôüÂóéÔºü")
                    }

                    
                }
                .padding(.horizontal)
                .padding(.bottom, GADAdSizeBanner.size.height + 45)
            }
        }
        // Add this sheet presentation after other .sheet modifiers in the settingsView
        .sheet(isPresented: $showSerialNumberInput) {
            SerialNumberInputView(isPresented: $showSerialNumberInput)
        }
        // Add sheet for phone verification
        .sheet(isPresented: $authViewModel.showPhoneVerification, onDismiss: {
            authViewModel.resetVerificationState()
        }) {
            NavigationView {
                VStack(spacing: 20) {
                    // Phone number input
                    CustomTextField(
                        placeholder: "Ë´ãËº∏ÂÖ•ÊâãÊ©üËôüÁ¢º",
                        text: $authViewModel.phoneNumber,
                        keyboardType: .phonePad
                    )
                    .padding(.horizontal)
                    
                    if authViewModel.canResetPhoneNumber {
                        // È°ØÁ§∫ÈáçË®≠ÊâãÊ©üËôüÁ¢ºÁöÑÈÅ∏È†Ö
                        HStack {
                            Text("ÊâãÊ©üËôüÁ¢ºËº∏ÂÖ•ÈåØË™§Ôºü")
                                .font(.custom("NotoSansTC-Regular", size: 14))
                                .foregroundColor(.gray)
                            
                            Button("ÈáçÊñ∞Ëº∏ÂÖ•ËôüÁ¢º") {
                                authViewModel.resetPhoneNumberInput()
                            }
                            .font(.custom("NotoSansTC-Regular", size: 14))
                            .foregroundColor(.customAccent)
                        }
                        .padding(.horizontal)
                    }
                    
                    if authViewModel.verificationID != nil {
                        // Verification code input
                        CustomTextField(
                            placeholder: "Ë´ãËº∏ÂÖ•È©óË≠âÁ¢º",
                            text: $authViewModel.verificationCode,
                            keyboardType: .numberPad,
                            textContentType: .oneTimeCode  // Ê∑ªÂä†ÈÄôË°å‰æÜÊîØÊåÅËá™ÂãïÂ°´ÂÖÖÁ∞°Ë®äÈ©óË≠âÁ¢º
                        )
                        .padding(.horizontal)
                        .onChange(of: authViewModel.verificationCode) { newValue in
                            // Áï∂È©óË≠âÁ¢ºÊîπËÆäÊôÇÔºåÊ™¢Êü•ÊòØÂê¶ÁÇ∫ÂæûÂâ™Ë≤ºÁ∞øË≤º‰∏äÁöÑÂÖßÂÆπ
                            if let pasteboardString = UIPasteboard.general.string,
                               pasteboardString.count == 6,  // ÂÅáË®≠È©óË≠âÁ¢ºÁÇ∫ 6 ‰ΩçÊï∏
                               pasteboardString.allSatisfy({ $0.isNumber }) {
                                authViewModel.verificationCode = pasteboardString
                            }
                        }
                        
                        // Countdown timer and resend button
                        HStack {
                            if let remainingTime = authViewModel.remainingTime {
                                Text("È©óË≠âÁ¢ºÊúâÊïàÊôÇÈñìÔºö\(remainingTime)Áßí")
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.gray)
                                
                                if remainingTime == 0 {
                                    Button("ÈáçÊñ∞ÁôºÈÄÅ") {
                                        authViewModel.sendVerificationCode()
                                    }
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.customAccent)
                                }
                            }
                        }
                        .padding(.horizontal)
                        
                        // Verify button with loading state
                        Button(action: {
                            authViewModel.verifyCode()
                        }) {
                            HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                if authViewModel.isLoading {
                                    ProgressView()
                                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                } else {
                                    Text("È©óË≠â")
                                }
                            }
                            .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                            .padding()
                            .background(authViewModel.isLoading ? Color.gray : Color.customAccent)
                            .foregroundColor(.white)
                            .cornerRadius(25)
                        }
                        .padding(.horizontal)
                        .disabled(authViewModel.isLoading)
                    } else {
                        // Send code button
                        Button(action: {
                            authViewModel.sendVerificationCode()
                        }) {
                            HStack {  // Ê∑ªÂä† HStack ‰æÜÁ¢∫‰øùÂÖßÂÆπÊ©´ÂêëÂ°´Êªø
                                if authViewModel.isLoading {
                                    ProgressView()
                                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                } else {
                                    Text(authViewModel.displayCooldownTime > 0 
                                        ? "Ë´ãÁ≠âÂæÖ \(authViewModel.displayCooldownTime) Áßí"
                                        : "ÁôºÈÄÅÈ©óË≠âÁ¢º")
                                }
                            }
                            .frame(maxWidth: .infinity)  // Â∞á frame ÁßªÂà∞ HStack ‰∏ä
                            .padding()
                            .background(
                                authViewModel.displayCooldownTime > 0 || authViewModel.isLoading 
                                    ? Color.gray 
                                    : Color.customAccent
                            )
                            .foregroundColor(.white)
                            .cornerRadius(25)
                        }
                        .padding(.horizontal)
                        .disabled(authViewModel.displayCooldownTime > 0 || authViewModel.isLoading)
                    }
                    
                    if let error = authViewModel.errorMessage {
                        Text(error)
                            .font(.custom("NotoSansTC-Regular", size: 14))
                            .foregroundColor(.red)
                            .padding()
                    }
                    
                    Spacer()
                }
                .padding(.top)
                .navigationTitle("ÈõôÈáçÈ©óË≠âË®≠ÂÆö")
                .navigationBarTitleDisplayMode(.inline)
                .navigationBarItems(trailing: Button("ÂèñÊ∂à") {
                    authViewModel.showPhoneVerification = false
                }
                .font(.custom("NotoSansTC-Regular", size: 16))
                )
                .onAppear {
                    authViewModel.resetVerificationState()
                }
            }
        }
        .overlay(
            Group {
                if showUpgradeError {
                    CustomAlertView(
                        title: "Á∂ÅÂÆöÂ§±Êïó",
                        message: upgradeErrorMessage ?? "",
                        isPresented: $showUpgradeError
                    )
                }
            }
        )
        // Add this sheet presentation after other .sheet modifiers in the settingsView
        .sheet(isPresented: $showSerialNumberInput) {
            SerialNumberInputView(isPresented: $showSerialNumberInput)
        }
    }
    
    

    // ‰øùÊåÅ SettingRow ÁµêÊßãÈ´î‰∏çËÆä
    struct SettingRow: View {
        let icon: String
        let title: String
        var price: String? = nil
        var textColor: Color = .customText
        var iconColor: Color = .customAccent // Êñ∞Â¢û iconColor ÂèÉÊï∏
        var isPurchasing: Bool = false
        var isLoading: Bool = false
        var badge: String? // Êñ∞Â¢û badge ÂèÉÊï∏
        var isCustomImage: Bool = false // Êñ∞Â¢ûÂèÉÊï∏‰æÜÂçÄÂàÜÁ≥ªÁµ±ÂúñÊ®ôÂíåËá™ÂÆöÁæ©ÂúñÁâá
        
        var body: some View {
            HStack {
                if isLoading {
                    ProgressView()
                        .scaleEffect(0.8)
                        .frame(width: 24, height: 24)
                } else {
                    if isCustomImage {
                        Image(icon)
                            .resizable()
                            .scaledToFit()
                        .frame(width: 24, height: 24)
                } else {
                    Image(systemName: icon)
                        .resizable()
                        .scaledToFit()
                        .frame(width: 24, height: 24)
                        .foregroundColor(iconColor)
                    }
                }
                
                Text(isLoading ? "Á∂ÅÂÆö‰∏≠..." : title)
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(textColor)
                
                Spacer()
                
                if isPurchasing {
                    ProgressView()
                } else if let price = price {
                    Text(price)
                        .foregroundColor(.customAccent)
                }
                
                if let badge = badge {
                    Text(badge)
                        .font(.system(size: 14))
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.customAccent)
                        .clipShape(Capsule())
                }
                
                Image(systemName: "chevron.right")
                    .font(.system(size: 14))
                    .foregroundColor(.gray)
            }
            .padding()
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
        }
    }

    // Êñ∞Â¢û Terms and Privacy View
    struct TermsAndPrivacyView: View {
        var body: some View {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    Text("ÊúçÂãôÊ¢ùÊ¨æËàáÈö±ÁßÅÊ¨äÊîøÁ≠ñ")
                        .font(.custom("NotoSansTC-Black", size: 24))
                        .padding(.bottom, 10)
                    
                    Group {
                        Text("Êë©ËâæÁßëÊäÄÊúâÈôêÂÖ¨Âè∏Èö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñ")
                            .font(.custom("NotoSansTC-Regular", size: 20))
                            .padding(.bottom, 5)
                        
                        Text("Èö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñÁöÑÂÖßÂÆπ")
                            .font(.custom("NotoSansTC-Regular", size: 18))
                        
                        Text("Êú¨Èö±ÁßÅÊ¨äÊîøÁ≠ñË™™ÊòéÊë©ËâæÁßëÊäÄÊúâÈôêÂÖ¨Âè∏(‰ª•‰∏ãË™™ÊòéÂ∞á‰ª•ÂìÅÁâåÂêçÁ®±-„ÄéÂçÉÂ∞ãÂëΩÂêç„Äè„ÄÅ„ÄéÊàëÂÄë„ÄèÊàñ„ÄéÊàëÂÄëÁöÑ„ÄèÁ∞°Á®±)ÈÄöÈÅéÊàëÂÄëÁöÑÊáâÁî®Á®ãÂºèÂèäÁ∂≤Á´ôÊî∂ÈõÜÂà∞ÁöÑË≥áË®äÔºå‰ª•ÂèäÊàëÂÄëÂ∞áÂ¶Ç‰Ωï‰ΩøÁî®ÈÄô‰∫õË≥áË®ä„ÄÇÊàëÂÄëÈùûÂ∏∏ÈáçË¶ñÊÇ®ÁöÑÈö±ÁßÅÊ¨ä„ÄÇË´ãÊÇ®Èñ±ËÆÄ‰ª•‰∏ãÊúâÈóúÈö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñÁöÑÊõ¥Â§öÂÖßÂÆπ„ÄÇ")
                            .padding(.bottom, 10)
                        
                        Group {
                            Text("ÊàëÂÄë‰ΩøÁî®ÊÇ®ÂÄã‰∫∫Ë≥áÊñôÁöÑÊñπÂºè")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("Êú¨ÊîøÁ≠ñÊ∂µËìãÁöÑÂÖßÂÆπÂåÖÊã¨ÔºöÊë©ËâæÁßëÊäÄÂ¶Ç‰ΩïËôïÁêÜËíêÈõÜÊàñÊî∂Âà∞ÁöÑÂÄã‰∫∫Ë≥áÊñô (ÂåÖÊã¨ËàáÊÇ®ÈÅéÂéª‰ΩøÁî®ÊàëÂÄëÁöÑÁî¢ÂìÅÂèäÊúçÂãôÁõ∏ÈóúÁöÑË≥áÊñôÔºâ„ÄÇÂÄã‰∫∫Ë≥áÊñôÊòØÊåáÂæó‰ª•Ë≠òÂà•ÊÇ®ÁöÑË∫´ÂàÜ‰∏îÊú™ÂÖ¨ÈñãÁöÑË≥áÊñôÔºåÂ¶ÇÂßìÂêç„ÄÅÂú∞ÂùÄ„ÄÅÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄÊàñÈõªË©±ËôüÁ¢º„ÄÇ\nÊú¨Èö±ÁßÅÊ¨ä‰øùË≠∑ÊîøÁ≠ñÂè™ÈÅ©Áî®ÊñºÊë©ËâæÁßëÊäÄ")
                        }
                        
                        Group {
                            Text("Ë≥áÊñôËíêÈõÜÂèä‰ΩøÁî®ÂéüÂâá")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("Âú®ÊÇ®Ë®ªÂÜäÊë©ËâæÁßëÊäÄÊâÄÂ±¨ÁöÑÂÆòÁ∂≤„ÄÅ‰ΩøÁî®AppÁõ∏ÈóúÁî¢ÂìÅ„ÄÅÁÄèË¶ΩÊàëÂÄëÁöÑÁî¢ÂìÅÂÆòÁ∂≤ÊàñÊüê‰∫õÂêà‰ΩúÂ§•‰º¥ÁöÑÁ∂≤È†ÅÔºå‰ª•ÂèäÂèÉÂä†ÂÆ£ÂÇ≥Ê¥ªÂãïÊàñË¥àÁçéÊ¥ªÂãïÊôÇÔºåÊë©ËâæÁßëÊäÄÊúÉËíêÈõÜÊÇ®ÁöÑÂÄã‰∫∫Ë≥áÊñô„ÄÇÊë©ËâæÁßëÊäÄ‰πüÂèØËÉΩÂ∞áÂïÜÊ•≠Â§•‰º¥ÊàñÂÖ∂‰ªñ‰ºÅÊ•≠ÊâÄÊèê‰æõÁöÑÈóúÊñºÊÇ®ÁöÑË≥áË®äËàáÊë©ËâæÁßëÊäÄÊâÄÊìÅÊúâÁöÑÊÇ®ÁöÑÂÄã‰∫∫Ë≥áÊñôÁõ∏ÁµêÂêà„ÄÇ\n\nÁï∂ÊÇ®Âú®‰ΩøÁî®Êë©ËâæÁßëÊäÄÊâÄÊèê‰æõÁöÑÊúçÂãôÈÄ≤ÊúÉÂì°Ë®ªÂÜäÊôÇÔºåÊàëÂÄëÊúÉË©¢ÂïèÊÇ®ÁöÑÂßìÂêç„ÄÅÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄ„ÄÅÂá∫ÁîüÊó•Êúü„ÄÅÊÄßÂà•ÂèäÈÉµÈÅûÂçÄËôüÁ≠âË≥áÊñô„ÄÇÂú®ÊÇ®Ë®ªÂÜäÊë©ËâæÁßëÊäÄÁöÑÊúÉÂì°Â∏≥Ëôü‰∏¶ÁôªÂÖ•ÊàëÂÄëÁöÑÊúçÂãôÂæåÔºåÊàëÂÄëÂ∞±ËÉΩËæ®Âà•ÊÇ®ÁöÑË∫´ÂàÜ„ÄÇÊÇ®ÂæóËá™Áî±ÈÅ∏ÊìáÊòØÂê¶Êèê‰æõÂÄã‰∫∫Ë≥áÊñôÁµ¶ÊàëÂÄëÔºå‰ΩÜËã•ÁâπÂÆöË≥áÊñôÊ¨Ñ‰Ωç‰øÇÂ±¨ÂøÖÂ°´Ê¨Ñ‰ΩçËÄÖÔºåÊÇ®Ëã•‰∏çÊèê‰æõË©≤Á≠âË≥áÊñôÂâáÁÑ°Ê≥ï‰ΩøÁî®Áõ∏ÈóúÁöÑÊë©ËâæÁßëÊäÄÊâÄÊèê‰æõÁî¢ÂìÅÂèäÊúçÂãô„ÄÇ")
                        }
                        
                        Group {
                            Text("ÂÖ∂‰ªñÊäÄË°ìÊî∂ÈõÜË≥áË®äÁ¥∞ÁØÄ")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("‚û§ ËªüÁ°¨È´îÁõ∏ÈóúË≥áË®ä\nÊàëÂÄëÊúÉÊî∂ÈõÜË£ùÁΩÆÂ∞àÂ±¨Ë≥áË®ä (‰æãÂ¶ÇÊÇ®ÁöÑÁ°¨È´îÂûãËôü„ÄÅ‰ΩúÊ•≠Á≥ªÁµ±ÁâàÊú¨„ÄÅË£ùÁΩÆÂîØ‰∏ÄÁöÑË≠òÂà•Á¢ºÔºå‰ª•ÂèäÂåÖÊã¨ÈõªË©±ËôüÁ¢ºÂú®ÂÖßÁöÑË°åÂãïÁ∂≤Ë∑ØË≥áË®ä)„ÄÇ\n\n‚û§ Âú∞ÁêÜ‰ΩçÁΩÆË≥áË®ä\nÁï∂ÊÇ®‰ΩøÁî®APPÊúçÂãôÊôÇÔºåÊàëÂÄëÊúÉÊî∂ÈõÜ‰∏¶ËôïÁêÜÊÇ®ÂØ¶ÈöõÊâÄÂú®‰ΩçÁΩÆÁöÑÁõ∏ÈóúË≥áË®ä„ÄÇÊàëÂÄëÊúÉ‰ΩøÁî®ÂêÑÁ®ÆÊäÄË°ìÂà§Êñ∑ÊÇ®ÁöÑÊâÄÂú®‰ΩçÁΩÆÔºåÂåÖÊã¨ IP ‰ΩçÂùÄ„ÄÅGPS ÂíåÂÖ∂‰ªñÊÑüÊáâÂô®„ÄÇ\n\n‚û§ Â∞àÂ±¨ÊáâÁî®Á®ãÂºèÁ∑®Ëôü\nÊüê‰∫õÊúçÂãôÊâÄÈôÑÁöÑÂ∞àÂ±¨ÊáâÁî®Á®ãÂºèÁ∑®ËôüÔºõÁï∂ÊÇ®ÂÆâË£ùÊàñËß£Èô§ÂÆâË£ùÈÄôÈ°ûÊúçÂãôÔºåÊàñÊòØÈÄôÈ°ûÊúçÂãôÂÆöÊúüËàáÊàëÂÄëÁöÑ‰º∫ÊúçÂô®ÈÄ£Á∑öÊôÇÔºåÁ≥ªÁµ±Â∞±ÊúÉÂ∞áÈÄôÂÄãÁ∑®Ëôü‰ª•ÂèäÂÆâË£ùË≥áË®äÂÇ≥ÈÄÅÁµ¶Êë©ËâæÁßëÊäÄ„ÄÇ")
                        }
                        
                        Group {
                            Text("ÂÖíÁ´•Á∑ö‰∏äÈö±ÁßÅ‰øùË≠∑Ê≥ïÊ°à")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("ÊàëÂÄëÁöÑÊâÄÊúâÂÖíÁ´•È°ûAPPÂèäÁ∂≤Á´ôÁî¢ÂìÅÁöÜÈÅµÂÆàÂÖíÁ´•Á∑ö‰∏äÈö±ÁßÅ‰øùË≠∑Ê¢ùÊ¨æthe Children's Online Privacy Protection Act („ÄéCOPPA„Äè)ÔºåÊàëÂÄë‰∏çÊúÉÊî∂ÈõÜ‰ªª‰ΩïÊú™Êªø13Ê≠≤ÂÖíÁ´•ÁöÑÂÄã‰∫∫Ë≥áË®äÔºåÂ¶ÇÊ™¢Ê∏¨Âà∞Âπ¥ÈΩ°Â∞èÊñº13Ê≠≤ÁöÑÁõ∏ÈóúË≥áË®äÔºåÊàëÂÄëÂ∞áÂèäÊôÇÂà™Èô§Ôºå‰∏çÊúÉ‰∫à‰ª•‰øùÁïôÊàñÂÑ≤Â≠ò„ÄÇ")
                        }
                        
                        Group {
                            Text("ËÅØÁπ´ÊàëÂÄë")
                                .font(.custom("NotoSansTC-Regular", size: 18))
                            Text("Â¶ÇÊûúÊÇ®ÊúâÈóúÊñºÊú¨Èö±ÁßÅÊ¨äÁöÑ‰ªª‰ΩïÂïèÈ°åÊàñÁñëÊÖÆÔºåË´ãËÅØÁπ´ÊàëÂÄëÔºõÊàëÂÄëÊúÉÁõ°Âø´ÂõûË¶ÜÊÇ®Ôºömoai@moai.tw")
                                .padding(.bottom, 20)
                        }
                    }
                }
                .padding()
            }
            .navigationBarTitle("ÊúçÂãôÊ¢ùÊ¨æËàáÈö±ÁßÅÊ¨ä", displayMode: .inline)
        }
    }

    private func logOut() {
        do {
            // Check if current user is anonymous
            if let user = Auth.auth().currentUser {
                if user.isAnonymous {
                    print("üë§ Deleting anonymous user account")
                    // Delete user data from Firestore first
                    let db = Firestore.firestore()
                    db.collection("users").document(user.uid).delete { error in
                        if let error = error {
                            print("‚ùå Error deleting Firestore data: \(error.localizedDescription)")
                        } else {
                            print("‚úÖ Firestore data deleted successfully")
                        }
                        
                        // Then delete the anonymous user account
                        user.delete { error in
                            if let error = error {
                                print("‚ùå Error deleting anonymous user: \(error.localizedDescription)")
                            } else {
                                print("‚úÖ Anonymous user deleted successfully")
                            }
                        }
                    }
                }
            }

            try Auth.auth().signOut()
            // Reset UI state after logout
            authViewModel.isLoggedIn = false
            authViewModel.isTwoFactorAuthenticated = false
            selectedTab = 0
            navigationPath = NavigationPath()
            
        } catch let signOutError as NSError {
            print("‚ùå Error signing out: \(signOutError)")
        }
    }

    private func deleteAccount() {
        guard let user = Auth.auth().currentUser else { return }
        
        // Âà™Èô§ Firestore ‰∏≠ÁöÑÁî®Êà∂Ë≥áÊñô
        let db = Firestore.firestore()
        db.collection("users").document(user.uid).delete { error in
            if let error = error {
                print("‚ùå Âà™Èô§ Firestore Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
            }
        }
        
        // Âà™Èô§ Authentication ‰∏≠ÁöÑÁî®Êà∂
        user.delete { error in
            if let error = error as NSError? {
                // ËôïÁêÜÈúÄË¶ÅÈáçÊñ∞È©óË≠âÁöÑÊÉÖÊ≥Å
                if error.code == AuthErrorCode.requiresRecentLogin.rawValue {
                    print("‚ö†Ô∏è ÈúÄË¶ÅÈáçÊñ∞È©óË≠âÂæåÊâçËÉΩÂà™Èô§Â∏≥Ëôü")
                    // ÂèØ‰ª•Âú®ÈÄôË£°Ê∑ªÂä†ÈáçÊñ∞È©óË≠âÁöÑÈÇèËºØ
                    // Âà™Èô§ÊàêÂäüÔºåÊõ¥Êñ∞ UI
                    authViewModel.isLoggedIn = false
                    selectedTab = 0
                    navigationPath = NavigationPath()
                    return
                }
                print("‚ùå Âà™Èô§Â∏≥ËôüÂ§±Êïó: \(error.localizedDescription)")
                return
            }
            
            // Âà™Èô§ÊàêÂäüÔºåÊõ¥Êñ∞ UI
            authViewModel.isLoggedIn = false
            selectedTab = 0
            navigationPath = NavigationPath()
        }
    }
    
    private func upgradeWithGoogle() {
        guard let clientID = FirebaseApp.app()?.options.clientID else { 
            isUpgrading = false
            return 
        }
        
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.keyWindow ?? windowScene.windows.first,
              let rootViewController = window.rootViewController else {
            return
        }
        
        GIDSignIn.sharedInstance.signIn(withPresenting: rootViewController) { result, error in
            if let error = error {
                print("‚ùå Google Á∂ÅÂÆöÈåØË™§: \(error.localizedDescription)")
                isUpgrading = false
                return
            }
            
            guard let user = result?.user,
                  let idToken = user.idToken?.tokenString else {
                return
            }
            
            let credential = GoogleAuthProvider.credential(withIDToken: idToken, accessToken: user.accessToken.tokenString)
            
            Auth.auth().currentUser?.link(with: credential) { [self] authResult, error in
                if let error = error as NSError? {
                    // ËôïÁêÜÁâπÂÆöÈåØË™§È°ûÂûã
                    let errorMessage: String
                    switch error.code {
                    case AuthErrorCode.emailAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.credentialAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.providerAlreadyLinked.rawValue:
                        errorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Google Â∏≥Ëôü"
                    default:
                        errorMessage = error.localizedDescription
                    }
                    DispatchQueue.main.async {
                        isUpgrading = false
                        upgradeErrorMessage = errorMessage
                        showUpgradeError = true
                    }
                    return
                }
                
                // Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñô
                let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest()
                changeRequest?.displayName = user.profile?.name
                changeRequest?.photoURL = user.profile?.imageURL(withDimension: 200)
                
                changeRequest?.commitChanges { error in
                    if let error = error {
                        print("‚ùå Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
                    } else {
                        print("‚úÖ Áî®Êà∂Ë≥áÊñôÊõ¥Êñ∞ÊàêÂäü")
                    }
                    
                    print("‚úÖ Â∏≥ËôüÂçáÁ¥öÊàêÂäü")
                    isUpgrading = false
                    // Ëß∏Áôº UI Êõ¥Êñ∞
                    authViewModel.handleSuccessfulLogin()
                }
            }
        }
    }
    
    private func upgradeWithApple() {
        isUpgrading = true
        appleSignInCoordinator = AppleSignInCoordinator()
        
        appleSignInCoordinator?.startSignInWithAppleFlow { result in
            defer {
                DispatchQueue.main.async {
                    isUpgrading = false
                }
            }
            
            switch result {
            case .success(_):
                self.handleSuccessfulUpgrade()
                
            case .failure(let error):
                DispatchQueue.main.async {
                    if let authError = error as? NSError {
                        // Firebase Auth errors
                        switch authError.code {
                        case AuthErrorCode.emailAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.credentialAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.providerAlreadyLinked.rawValue:
                            upgradeErrorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Apple Â∏≥Ëôü"
                        case AuthErrorCode.invalidCredential.rawValue:
                            upgradeErrorMessage = "ÁÑ°ÊïàÁöÑÊÜëË≠â"
                        case AuthErrorCode.operationNotAllowed.rawValue:
                            upgradeErrorMessage = "Ê≠§Êìç‰Ωú‰∏çË¢´ÂÖÅË®±"
                        case AuthErrorCode.tooManyRequests.rawValue:
                            upgradeErrorMessage = "Ë´ãÊ±ÇÊ¨°Êï∏ÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶"
                        case AuthErrorCode.networkError.rawValue:
                            upgradeErrorMessage = "Á∂≤Ë∑ØÈÄ£Á∑öÈåØË™§ÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÁãÄÊÖã"
                        case AuthErrorCode.userDisabled.rawValue:
                            upgradeErrorMessage = "Ê≠§Â∏≥ËôüÂ∑≤Ë¢´ÂÅúÁî®"
                        case AuthErrorCode.requiresRecentLogin.rawValue:
                            upgradeErrorMessage = "ÈúÄË¶ÅÈáçÊñ∞ÁôªÂÖ•ÊâçËÉΩÂü∑Ë°åÊ≠§Êìç‰Ωú"
                        default:
                            // Â¶ÇÊûúÊòØ Apple Sign In ÁöÑÈåØË™§
                            if let asError = error as? ASAuthorizationError {
                                switch asError.code {
                                case .canceled:
                                    upgradeErrorMessage = "‰ΩøÁî®ËÄÖÂèñÊ∂àÁ∂ÅÂÆö"
                                case .invalidResponse:
                                    upgradeErrorMessage = "‰º∫ÊúçÂô®ÂõûÊáâÁÑ°Êïà"
                                case .notHandled:
                                    upgradeErrorMessage = "ÁÑ°Ê≥ïËôïÁêÜÊ≠§Ë´ãÊ±Ç"
                                case .failed:
                                    upgradeErrorMessage = "Á∂ÅÂÆöÂ§±Êïó"
                                default:
                                    upgradeErrorMessage = error.localizedDescription
                                }
                            } else {
                                upgradeErrorMessage = error.localizedDescription
                            }
                        }
                        self.showUpgradeError = true
                    }
                }
            }
        }
    }
    
    // Â¶ÇÊûúÈúÄË¶ÅÈÄ£ÁµêÂ∏≥ËôüÁöÑË©±ÔºåÂèØ‰ª•Ê∑ªÂä†ÈÄôÂÄãËºîÂä©ÊñπÊ≥ï
    private func linkAccount(with credential: AuthCredential) {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå ÁÑ°Ê≥ïÈÄ£ÁµêÂ∏≥ËôüÔºöÊú™ÊâæÂà∞Áï∂ÂâçÁî®Êà∂")
            return
        }
        
        user.link(with: credential) { authResult, error in
            if let error = error {
                print("‚ùå Â∏≥ËôüÈÄ£ÁµêÂ§±Êïó: \(error.localizedDescription)")
                DispatchQueue.main.async {
                    self.upgradeErrorMessage = error.localizedDescription
                }
                return
            }
            
            print("‚úÖ Â∏≥ËôüÈÄ£ÁµêÊàêÂäü")
            // ÂèØ‰ª•Âú®ÈÄôË£°Ê∑ªÂä†ÂÖ∂‰ªñÊàêÂäüÂêéÁöÑËôïÁêÜÈÇèËºØ
        }
    }

    // Âú® upgradeWithGoogle Âíå upgradeWithApple ÊñπÊ≥ïÊàêÂäüÂêéÊ∑ªÂä†
    private func handleSuccessfulUpgrade() {
        isUpgrading = false
        
        // ËΩâÁßªÂåøÂêçÁî®Êà∂ÁöÑ‰ΩøÁî®Ê¨°Êï∏
        UsageManager.shared.transferAnonymousUses()
        
        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await UsageManager.shared.updateCloudData()
        }
        
        // Ëß¶Âèë UI Êõ¥Êñ∞
        authViewModel.handleSuccessfulLogin()
        
        // ‰øùÂ≠òÊñ∞ÁöÑËÆ§ËØÅÁä∂ÊÄÅ
        UserDefaults.standard.set(false, forKey: "isAnonymousUser")
    }
}

// authViewModel.isLoggedIn = false
// selectedTab = 0
// navigationPath = NavigationPath()

// Updated TabBarButton view
struct TabBarButton: View {
    let imageName: String
    let isSelected: Bool
    let action: () -> Void
    var badgeCount: Int? // Êñ∞Â¢û badge Êï∏ÈáèÂèÉÊï∏
    
    var body: some View {
        Button(action: action) {
            ZStack {
                Image(imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 40, height: 40)
                .foregroundColor(isSelected ? .customAccent : .gray)
                
                // Badge View
                if let count = badgeCount, count > 0 {
                    Text("\(count)")
                        .font(.system(size: 12))
                        .foregroundColor(.white)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.customAccent)
                        .clipShape(Capsule())
                        .offset(x: 12, y: -12)
                }
            }
        }
        .frame(width: 40, height: 40)
    }
}


struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

// Main Axis View - ‰∏ªËª∏Ë®≠Ë®àÁöÑ‰∏ã‰∏ÄÊ≠•
struct MainAxisView: View {
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int
    @Binding var isLoggedIn: Bool
    @ObservedObject var authViewModel: AuthViewModel
    @State private var selectedAxis = "‰∫îË°å"
    @State private var selectedElement = "Èáë"
    @State private var selectedStyle = "Âè§ÂÖ∏"
    @State private var selectedMeaning = "Êô∫ÊÖß"
    @State private var showAlert = false
    @State private var alertMessage = ""
    @Environment(\.colorScheme) var colorScheme
    
    // ‰∏ªËª∏ÈÅ∏È†ÖÈÖçÁΩÆ
    private let axisOptions = ["‰∫îË°å", "ÁîüËÇñ", "ÊòüÂ∫ß", "Â≠£ÁØÄ", "Êñπ‰Ωç"]
    private let elementOptions = ["Èáë", "Êú®", "Ê∞¥", "ÁÅ´", "Âúü"]
    private let styleOptions = ["Âè§ÂÖ∏", "Áèæ‰ª£", "ÊñáÈõÖ", "Ê¥ªÊΩë", "Á©©Èáç"]
    private let meaningOptions = ["Êô∫ÊÖß", "ÂÅ•Â∫∑", "Ë≤°ÂØå", "ÊÑõÊÉÖ", "‰∫ãÊ•≠", "ÂÆ∂Â∫≠"]
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // ËÉåÊôØÈªûÊìäÊâãÂã¢
                Color.clear
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .contentShape(Rectangle())
                    .onTapGesture {
                        hideKeyboard()
                    }
                
                VStack(spacing: 0) {
                    ScrollView {
                        VStack(spacing: 20) {
                            // ‰∏ªËª∏Ê®ôÈ°åÂçÄÂüü
                            MainAxisHeaderView()
                            
                            // ‰∏ªËª∏ÈÅ∏ÊìáÂçÄÂüü
                            MainAxisSelectionView(
                                selectedAxis: $selectedAxis,
                                axisOptions: axisOptions
                            )
                            
                            // ÂÖÉÁ¥†ÈÅ∏ÊìáÂçÄÂüü
                            ElementSelectionView(
                                selectedElement: $selectedElement,
                                elementOptions: elementOptions,
                                selectedAxis: selectedAxis
                            )
                            
                            // È¢®Ê†ºÈÅ∏ÊìáÂçÄÂüü
                            StyleSelectionView(
                                selectedStyle: $selectedStyle,
                                styleOptions: styleOptions
                            )
                            
                            // ÂØìÊÑèÈÅ∏ÊìáÂçÄÂüü
                            MeaningSelectionView(
                                selectedMeaning: $selectedMeaning,
                                meaningOptions: meaningOptions
                            )
                            
                            // È†êË¶ΩÂçÄÂüü
                            PreviewSectionView(
                                selectedAxis: selectedAxis,
                                selectedElement: selectedElement,
                                selectedStyle: selectedStyle,
                                selectedMeaning: selectedMeaning
                            )
                        }
                        .padding(.bottom, 120)
                    }
                    .scrollIndicators(.visible)
                    
                    // Â∫ïÈÉ®ÊåâÈàï
                    BottomButtonView(action: proceedToNextStep)
                }
            }
            .background(
                Image("background")
                    .resizable()
                    .scaledToFill()
                    .edgesIgnoringSafeArea(.all)
            )
            .navigationBarSetup(navigationPath: $navigationPath)
            .alert("ÊèêÁ§∫", isPresented: $showAlert) {
                Button("Á¢∫ÂÆö", role: .cancel) { }
            } message: {
                Text(alertMessage)
            }
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                       to: nil, from: nil, for: nil)
    }
    
    private func proceedToNextStep() {
        // È©óË≠âÈÅ∏Êìá
        if selectedAxis.isEmpty || selectedElement.isEmpty || selectedStyle.isEmpty || selectedMeaning.isEmpty {
            alertMessage = "Ë´ãÂÆåÊàêÊâÄÊúâ‰∏ªËª∏ÈÅ∏Êìá"
            showAlert = true
            return
        }
        
        // ÂâµÂª∫‰∏ªËª∏Ë≥áÊñô‰∏¶Â∞éËà™Âà∞‰∏ã‰∏ÄÊ≠•
        let axisData = MainAxisData(
            axis: selectedAxis,
            element: selectedElement,
            style: selectedStyle,
            meaning: selectedMeaning
        )
        
        withAnimation(.easeInOut(duration: 0.3)) {
            navigationPath.append(axisData)
        }
    }
}

// ‰∏ªËª∏Ê®ôÈ°åÂçÄÂüü
private struct MainAxisHeaderView: View {
    var body: some View {
        HStack(alignment: .top, spacing: 15) {
            Image("main_mascot")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
            
            VStack(alignment: .leading, spacing: 8) {
                Text("ÈÅ∏ÊìáÂëΩÂêç‰∏ªËª∏")
                    .font(.custom("NotoSansTC-Black", size: 24))
                    .foregroundColor(.customText)
                    .bold()
                
                Text("ÁÇ∫ÂØ∂ÂØ∂ÈÅ∏ÊìáÂëΩÂêçÁöÑÊ†∏ÂøÉ‰∏ªÈ°å\nËÆìÂêçÂ≠óÊõ¥ÊúâÊÑèÁæ©ÂíåÁâπËâ≤")
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.customText)
                    .lineLimit(2)
                    .padding(15)
                    .background(Color.white.opacity(0.9))
                    .cornerRadius(15)
                    .overlay(
                        Triangle()
                            .fill(Color.white.opacity(0.9))
                            .frame(width: 20, height: 20)
                            .rotationEffect(.degrees(-90))
                            .offset(x: -15, y: 15)
                        , alignment: .topLeading
                    )
            }
        }
        .padding(.horizontal, 20)
        .padding(.top, 20)
    }
}

// ‰∏ªËª∏ÈÅ∏ÊìáÂçÄÂüü
private struct MainAxisSelectionView: View {
    @Binding var selectedAxis: String
    let axisOptions: [String]
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("‰∏ªËª∏È°ûÂûã")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 3), spacing: 12) {
                ForEach(axisOptions, id: \.self) { option in
                    Button(action: { 
                        hideKeyboard()
                        selectedAxis = option 
                    }) {
                        Text(option)
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(selectedAxis == option ? .white : Color(hex: "#FF798C"))
                            .frame(maxWidth: .infinity)
                            .frame(height: 50)
                            .background(selectedAxis == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                            .cornerRadius(25)
                            .overlay(
                                RoundedRectangle(cornerRadius: 25)
                                    .stroke(Color(hex: "#FF798C"), lineWidth: 1)
                            )
                    }
                }
            }
        }
        .padding(.horizontal, 20)
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                       to: nil, from: nil, for: nil)
    }
}

// ÂÖÉÁ¥†ÈÅ∏ÊìáÂçÄÂüü
private struct ElementSelectionView: View {
    @Binding var selectedElement: String
    let elementOptions: [String]
    let selectedAxis: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("\(selectedAxis)ÂÖÉÁ¥†")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 5), spacing: 12) {
                ForEach(elementOptions, id: \.self) { option in
                    Button(action: { 
                        hideKeyboard()
                        selectedElement = option 
                    }) {
                        VStack(spacing: 4) {
                            Text(option)
                                .font(.custom("NotoSansTC-Black", size: 18))
                                .foregroundColor(selectedElement == option ? .white : Color(hex: "#FF798C"))
                            
                            Text(getElementDescription(for: option))
                                .font(.custom("NotoSansTC-Regular", size: 12))
                                .foregroundColor(selectedElement == option ? .white.opacity(0.8) : Color(hex: "#FF798C").opacity(0.7))
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 70)
                        .background(selectedElement == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                        .cornerRadius(20)
                        .overlay(
                            RoundedRectangle(cornerRadius: 20)
                                .stroke(Color(hex: "#FF798C"), lineWidth: 1)
                        )
                    }
                }
            }
        }
        .padding(.horizontal, 20)
    }
    
    private func getElementDescription(for element: String) -> String {
        switch element {
        case "Èáë": return "Â†ÖÊØÖ"
        case "Êú®": return "ÊàêÈï∑"
        case "Ê∞¥": return "Êô∫ÊÖß"
        case "ÁÅ´": return "ÁÜ±ÊÉÖ"
        case "Âúü": return "Á©©Èáç"
        default: return ""
        }
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                       to: nil, from: nil, for: nil)
    }
}

// È¢®Ê†ºÈÅ∏ÊìáÂçÄÂüü
private struct StyleSelectionView: View {
    @Binding var selectedStyle: String
    let styleOptions: [String]
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("ÂëΩÂêçÈ¢®Ê†º")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            HStack(spacing: 12) {
                ForEach(styleOptions, id: \.self) { option in
                    Button(action: { 
                        hideKeyboard()
                        selectedStyle = option 
                    }) {
                        Text(option)
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(selectedStyle == option ? .white : Color(hex: "#FF798C"))
                            .frame(maxWidth: .infinity)
                            .frame(height: 45)
                            .background(selectedStyle == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                            .cornerRadius(22.5)
                            .overlay(
                                RoundedRectangle(cornerRadius: 22.5)
                                    .stroke(Color(hex: "#FF798C"), lineWidth: 1)
                            )
                    }
                }
            }
        }
        .padding(.horizontal, 20)
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                       to: nil, from: nil, for: nil)
    }
}

// ÂØìÊÑèÈÅ∏ÊìáÂçÄÂüü
private struct MeaningSelectionView: View {
    @Binding var selectedMeaning: String
    let meaningOptions: [String]
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("ÊúüÊúõÂØìÊÑè")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 3), spacing: 12) {
                ForEach(meaningOptions, id: \.self) { option in
                    Button(action: { 
                        hideKeyboard()
                        selectedMeaning = option 
                    }) {
                        Text(option)
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(selectedMeaning == option ? .white : Color(hex: "#FF798C"))
                            .frame(maxWidth: .infinity)
                            .frame(height: 50)
                            .background(selectedMeaning == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                            .cornerRadius(25)
                            .overlay(
                                RoundedRectangle(cornerRadius: 25)
                                    .stroke(Color(hex: "#FF798C"), lineWidth: 1)
                            )
                    }
                }
            }
        }
        .padding(.horizontal, 20)
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                       to: nil, from: nil, for: nil)
    }
}

// È†êË¶ΩÂçÄÂüü
private struct PreviewSectionView: View {
    let selectedAxis: String
    let selectedElement: String
    let selectedStyle: String
    let selectedMeaning: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 15) {
            Text("ÈÅ∏ÊìáÈ†êË¶Ω")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            VStack(spacing: 12) {
                PreviewRow(title: "‰∏ªËª∏È°ûÂûã", value: selectedAxis)
                PreviewRow(title: "\(selectedAxis)ÂÖÉÁ¥†", value: selectedElement)
                PreviewRow(title: "ÂëΩÂêçÈ¢®Ê†º", value: selectedStyle)
                PreviewRow(title: "ÊúüÊúõÂØìÊÑè", value: selectedMeaning)
            }
            .padding(20)
            .background(Color.white.opacity(0.9))
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(Color(hex: "#FF798C"), lineWidth: 2)
            )
        }
        .padding(.horizontal, 20)
    }
}

// È†êË¶ΩË°å
private struct PreviewRow: View {
    let title: String
    let value: String
    
    var body: some View {
        HStack {
            Text(title)
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .frame(width: 80, alignment: .leading)
            
            Text(":")
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
            
            Text(value)
                .font(.custom("NotoSansTC-Black", size: 16))
                .foregroundColor(Color(hex: "#FF798C"))
                .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

// ‰∏ªËª∏Ë≥áÊñôÊ®°Âûã
struct MainAxisData: Hashable {
    let axis: String
    let element: String
    let style: String
    let meaning: String
}

struct FormView: View {
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int
    @Binding var isLoggedIn: Bool
    @ObservedObject var authViewModel: AuthViewModel
    @State private var fatherName = ""
    @State private var motherName = ""
    @State private var middleName = ""
    @State private var numberOfNames = 2
    @State private var isBorn = false
    @State private var birthDate = Date()
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var gender = "Êú™Áü•"
    @State private var surnameChoice = "ÂæûÁà∂Âßì"  // Êñ∞Â¢ûÔºöÂßìÊ∞èÈÅ∏Êìá
    @Environment(\.colorScheme) var colorScheme
    
    // 2. ‰øÆÊîπÂàùÂßãÂåñÊñπÊ≥ï‰ª•ÂåπÈÖçË™øÁî®
    init(navigationPath: Binding<NavigationPath>,
         selectedTab: Binding<Int>,
         isLoggedIn: Binding<Bool>,
         authViewModel: AuthViewModel) {
        self._navigationPath = navigationPath
        self._selectedTab = selectedTab
        self._isLoggedIn = isLoggedIn
        self.authViewModel = authViewModel
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Add tap gesture to the background
                Color.clear
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .contentShape(Rectangle())
                    .onTapGesture {
                        hideKeyboard()
                    }
                
                VStack(spacing: 0) {
                    ScrollView {
                        VStack(spacing: 15) {
                            FormHeaderView()
                            FormFieldsView(
                                fatherName: $fatherName,
                                motherName: $motherName,
                                middleName: $middleName,
                                numberOfNames: $numberOfNames,
                                gender: $gender,
                                isBorn: $isBorn,
                                birthDate: $birthDate,
                                surnameChoice: $surnameChoice
                            )
                        }
                        .padding(.bottom, 120) // ÁÇ∫Â∫ïÈÉ®ÊåâÈàïÁïôÂá∫Ë∂≥Â§†Á©∫Èñì
                    }
                    .scrollIndicators(.visible)
                    
                    BottomButtonView(action: validateAndProceed)
                }
            }
            .background(
                Image("background")
                    .resizable()
                    .scaledToFill()
                    .edgesIgnoringSafeArea(.all)
            )
            .navigationBarSetup(navigationPath: $navigationPath)
            .alert("ÊèêÁ§∫", isPresented: $showAlert) {
                Button("Á¢∫ÂÆö", role: .cancel) { }
            } message: {
                Text(alertMessage)
            }
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                      to: nil, from: nil, for: nil)
    }
    
    private func validateAndProceed() {
        // Validate all required fields
        if surnameChoice == "ÂæûÁà∂Âßì" && fatherName.isEmpty {
            alertMessage = "ÈÅ∏ÊìáÂæûÁà∂ÂßìÊôÇÔºåÁà∏Áà∏ÂßìÂêçÁÇ∫ÂøÖÂ°´"
            showAlert = true
        } else if surnameChoice == "ÂæûÊØçÂßì" && motherName.isEmpty {
            alertMessage = "ÈÅ∏ÊìáÂæûÊØçÂßìÊôÇÔºåÂ™ΩÂ™ΩÂßìÂêçÁÇ∫ÂøÖÂ°´"
            showAlert = true
        } else if fatherName.count > 3 {
            alertMessage = "Áà∏Áà∏ÂßìÂêç‰∏çËÉΩË∂ÖÈÅé‰∏âÂÄãÂ≠ó"
            showAlert = true
        } else if motherName.count > 3 {
            alertMessage = "Â™ΩÂ™ΩÂßìÂêç‰∏çËÉΩË∂ÖÈÅé‰∏âÂÄãÂ≠ó"
            showAlert = true
        } else if middleName.count > 1 {
            alertMessage = "‰∏≠ÈñìÂ≠ó‰∏çËÉΩË∂ÖÈÅé‰∏ÄÂÄãÂ≠ó"
            showAlert = true
        } else {
            let formData = FormData(fatherName: fatherName, motherName: motherName, middleName: middleName, numberOfNames: numberOfNames, isBorn: isBorn, birthDate: birthDate, gender: gender, surnameChoice: surnameChoice)
            withAnimation(nil) {
                navigationPath.append(formData)
            }
        }
    }
}

// Header View
private struct FormHeaderView: View {
    var body: some View {
        HStack(alignment: .top, spacing: 10) {
            Image("login_mascot")
                .resizable()
                .scaledToFit()
                .frame(width: 100, height: 100)
            
            VStack(alignment: .leading) {
                Text("ÈÄÅÁµ¶Â≠©Â≠êÁöÑÁ¨¨‰∏Ä‰ªΩÁ¶ÆÁâ©\nÂ∞±ÊòØÁÇ∫Â≠©Â≠êÂëΩÂêçÔºÅ")
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(.black)
                    .padding(12)
                    .background(Color.white)
                    .cornerRadius(15)
                    .overlay(
                        Triangle()
                            .fill(Color.white)
                            .frame(width: 20, height: 20)
                            .rotationEffect(.degrees(-90))
                            .offset(x: -15, y: 10)
                        , alignment: .topLeading
                    )
            }
        }
        .padding()
    }
}

// Form Fields View
private struct FormFieldsView: View {
    @Binding var fatherName: String
    @Binding var motherName: String
    @Binding var middleName: String
    @Binding var numberOfNames: Int
    @Binding var gender: String
    @Binding var isBorn: Bool
    @Binding var birthDate: Date
    @Binding var surnameChoice: String
    @State private var showMiddleNameAlert = false
    
    var body: some View {
        VStack(spacing: 15) {
            // ÂßìÊ∞èÈÅ∏ÊìáÔºàÂøÖÈÅ∏Ôºâ
            SurnameChoiceSelector(surnameChoice: $surnameChoice)
            
            // Áà∂ÊØçÂßìÂêçÊ¨Ñ‰Ωç
            VStack(alignment: .leading, spacing: 5) {
                Text("Áà∂ÊØçÂßìÂêç")
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.customText)
                    .padding(.leading, 5)
                
                HStack(spacing: 10) {
                CustomTextField(
                    placeholder: surnameChoice == "ÂæûÁà∂Âßì" ? "Áà∏Áà∏ÂßìÂêçÔºàÂøÖÂ°´Ôºâ" : "Áà∏Áà∏ÂßìÂêç", 
                    text: $fatherName
                )
                .overlay(
                    // ÂøÖÂ°´Ê®ôÁ§∫
                    surnameChoice == "ÂæûÁà∂Âßì" ? 
                    RoundedRectangle(cornerRadius: 25)
                        .stroke(Color.red.opacity(fatherName.isEmpty ? 0.5 : 0), lineWidth: 2) : nil
                )
                
                CustomTextField(
                    placeholder: surnameChoice == "ÂæûÊØçÂßì" ? "Â™ΩÂ™ΩÂßìÂêçÔºàÂøÖÂ°´Ôºâ" : "Â™ΩÂ™ΩÂßìÂêç", 
                    text: $motherName
                )
                .overlay(
                    // ÂøÖÂ°´Ê®ôÁ§∫
                    surnameChoice == "ÂæûÊØçÂßì" ? 
                    RoundedRectangle(cornerRadius: 25)
                        .stroke(Color.red.opacity(motherName.isEmpty ? 0.5 : 0), lineWidth: 2) : nil
                )
                }
            }
            
            NameCountSelector(numberOfNames: $numberOfNames)
            
            // ‰∏≠ÈñìÂ≠óÊ¨Ñ‰Ωç - Âè™Âú®ÈùûÂñÆÂêçÊôÇÈ°ØÁ§∫
            if numberOfNames != 1 {
            VStack(alignment: .leading, spacing: 5) {
                Text("‰∏≠ÈñìÂ≠ó")
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.customText)
                    .padding(.leading, 5)
                
                CustomTextField(
                        placeholder: "ÊåáÂÆö‰∏≠ÈñìÂ≠óÔºàÈÅ∏Â°´Ôºâ", 
                    text: $middleName
                )
                .onChange(of: numberOfNames) { newValue in
                    if newValue == 1 && !middleName.isEmpty {
                        showMiddleNameAlert = true
                        middleName = ""  // Ê∏ÖÁ©∫‰∏≠ÈñìÂ≠ó
                    }
                }
                .alert(isPresented: $showMiddleNameAlert) {
                    Alert(
                        title: Text("ÊèêÁ§∫"),
                        message: Text("ÂñÆÂêç‰∏çÂæóË®≠ÂÆö‰∏≠ÈñìÂ≠ó"),
                        dismissButton: .default(Text("Á¢∫ÂÆö"))
                    )
                }
            }
            }
            GenderSelector(gender: $gender)
            BirthInfoView(isBorn: $isBorn, birthDate: $birthDate)
        }
        .padding()
    }
}

// Name Count Selector
private struct NameCountSelector: View {
    @Binding var numberOfNames: Int
    
    var body: some View {
        VStack(alignment: .leading, spacing: 5) {
            Text("ÂñÆ/ÈõôÂêç")
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            HStack(spacing: 0) {
                ForEach([1, 2], id: \.self) { count in
                    Button(action: { 
                        hideKeyboard()
                        numberOfNames = count 
                    }) {
                        Text(count == 1 ? "ÂñÆÂêç" : "ÈõôÂêç")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(numberOfNames == count ? .white : Color(hex: "#FF798C"))
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .background(numberOfNames == count ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                    }
                }
            }
            .background(Color(hex: "#FFE5E9"))
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(Color(hex: "#FF798C"), lineWidth: 1)
            )
        }
    }
}

// Surname Choice Selector
private struct SurnameChoiceSelector: View {
    @Binding var surnameChoice: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 5) {
            Text("ÂßìÊ∞èÈÅ∏ÊìáÔºàÂøÖÈÅ∏Ôºâ")
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            HStack(spacing: 0) {
                ForEach(["ÂæûÁà∂Âßì", "ÂæûÊØçÂßì"], id: \.self) { option in
                    Button(action: { 
                        hideKeyboard()
                        surnameChoice = option 
                    }) {
                        Text(option)
                            .foregroundColor(surnameChoice == option ? .white : Color(hex: "#FF798C"))
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 10)
                            .background(surnameChoice == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                    }
                }
            }
            .background(Color(hex: "#FFE5E9"))
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(Color(hex: "#FF798C"), lineWidth: 1)
            )
        }
    }
}

// Gender Selector
private struct GenderSelector: View {
    @Binding var gender: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 5) {
            Text("ÊÄßÂà•")
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            HStack(spacing: 0) {
                ForEach(["Áî∑", "Â•≥", "Êú™Áü•"], id: \.self) { option in
                    Button(action: { 
                        hideKeyboard()
                        gender = option 
                    }) {
                        Text(option)
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(gender == option ? .white : Color(hex: "#FF798C"))
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .background(gender == option ? Color(hex: "#FF798C") : Color(hex: "#FFE5E9"))
                    }
                }
            }
            .background(Color(hex: "#FFE5E9"))
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(Color(hex: "#FF798C"), lineWidth: 1)
            )
        }
    }
}

// Birth Info View
private struct BirthInfoView: View {
    @Binding var isBorn: Bool
    @Binding var birthDate: Date
    
    var body: some View {
        VStack(alignment: .leading, spacing: 15) {
            VStack(alignment: .leading, spacing: 5) {
                Text("Âá∫ÁîüÁãÄÊÖã")
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.customText)
                    .padding(.leading, 5)
                
                Toggle("Êú™/Â∑≤Âá∫Áîü", isOn: $isBorn)
                    .padding()
                    .background(Color.white)
                    .foregroundColor(.black)
                    .cornerRadius(25)
                    .toggleStyle(CustomToggleStyle(onColor: Color(hex: "#FF798C")))
                    .onTapGesture {
                        hideKeyboard()
                    }
            }
            
            if isBorn {
                DatePicker(
                    "ÁîüÊó•/È†êÁî¢Êúü",
                    selection: $birthDate,
                    displayedComponents: [.date]
                )
                .datePickerStyle(.compact)
                .padding()
                .background(Color.white)
                .cornerRadius(25)
                .overlay(
                    RoundedRectangle(cornerRadius: 25)
                        .stroke(Color(hex: "#FF798C"), lineWidth: 1)
                )
                .onTapGesture {
                    hideKeyboard()
                }
            }
        }
    }
}

// Bottom Button View
private struct BottomButtonView: View {
    let action: () -> Void
    
    var body: some View {
        VStack {
            Button(action: {
                hideKeyboard()
                action()
            }) {
                Text("‰∏ã‰∏ÄÊ≠•")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color(hex: "#FF798C"))
                    .cornerRadius(25)
            }
            .padding(.horizontal)
            .padding(.bottom, 20)
        }
        .background(
            Color.white.opacity(0.95)
                .blur(radius: 10)
                .edgesIgnoringSafeArea(.bottom)
        )
        .ignoresSafeArea(.keyboard)
    }
}

// Navigation Bar Setup
extension View {
    func navigationBarSetup(navigationPath: Binding<NavigationPath>) -> some View {
        self
            .navigationBarTitle("Ë≥áÊñôÂ°´ÂØ´", displayMode: .inline)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        navigationPath.wrappedValue.removeLast()
                    }) {
                        Image(systemName: "chevron.left")
                            .foregroundColor(.white)
                    }
                }
                ToolbarItem(placement: .principal) {
                    Text("Ë≥áÊñôÂ°´ÂØ´")
                        .font(.custom("NotoSansTC-Black", size: 20))
                        .foregroundColor(.white)
                }
            }
            .toolbarBackground(.visible, for: .navigationBar)
            .toolbarBackground(Color.black, for: .navigationBar)
            .toolbarColorScheme(.dark, for: .navigationBar)
            .navigationBarBackButtonHidden(true)
            .navigationBarTitleDisplayMode(.inline)
            .overlay(
                Color.pink.frame(height: 5)
                    .edgesIgnoringSafeArea(.horizontal)
                    .offset(y: 0)
                , alignment: .top
            )
    }
}

struct FormData: Hashable {
    let fatherName: String
    let motherName: String
    let middleName: String
    let numberOfNames: Int
    let isBorn: Bool
    let birthDate: Date
    let gender: String
    let surnameChoice: String
}

struct DesignFocusData: Hashable {
    let selectedOptions: [String]
    let customDescription: String?
}

struct SpecialRequirementData: Hashable {
    let selectedRequirements: [String]
    let detailDescription: String?
}

// ‰∏≠ÈñìÈöéÊÆµÁöÑË≥áÊñôÁµêÊßãÔºåÂåÖÂê´ FormData Âíå DesignFocusData
struct FormWithDesignData: Hashable {
    let formData: FormData
    let designFocusData: DesignFocusData
}

struct CombinedFormData: Hashable {
    let formData: FormData
    let designFocusData: DesignFocusData
    let specialRequirementData: SpecialRequirementData? // Êñ∞Â¢ûÁâπÊÆäÈúÄÊ±ÇË≥áÊñô
}

struct DialogView: View {
    @Binding var navigationPath: NavigationPath
    @Binding var selectedTab: Int  // Êñ∞Â¢ûÈÄôË°å
    let formData: FormData
    let designFocusData: DesignFocusData
    let specialRequirementData: SpecialRequirementData?
    @State private var questions: [Question] = []
    @State private var currentQuestionIndex = 0
    @State private var answers: [String] = []
    @State private var isGeneratingName = false
    @State private var generatedName: String?
    @State private var nameAnalysis: [String: String]?
    @State private var wuxing: [String]?
    @Environment(\.colorScheme) var colorScheme
    @State private var errorMessage: String?
    // Add state variable
    @State private var shouldDismissOnTap = false
    
    private let usageManager = UsageManager.shared
    
    // Add a state to track if generation is in progress
    @State private var isGenerating = false
    
    // Ê∑ªÂä†Êñ∞ÁöÑ state ËÆäÊï∏
    @State private var showCharCountError = false
    @State private var generatedNameWithError: String = ""
    
    // ‰øÆÊîπÂàùÂßãÂåñÊñπÊ≥ï
    init(navigationPath: Binding<NavigationPath>,
         selectedTab: Binding<Int>,  // Êñ∞Â¢ûÈÄôË°å
         formData: FormData,
         designFocusData: DesignFocusData,
         specialRequirementData: SpecialRequirementData?) {
        self._navigationPath = navigationPath
        self._selectedTab = selectedTab  // Êñ∞Â¢ûÈÄôË°å
        self.formData = formData
        self.designFocusData = designFocusData
        self.specialRequirementData = specialRequirementData
    }
    
    var body: some View {
        ZStack {
            // Color(hex: "#FFF0F5") // Light pink background
            //     .edgesIgnoringSafeArea(.all)

            if isGeneratingName {
                // LoadingView()
                VStack {
                    ProgressView("ÁîüÊàêÊôÇÈñìÁ¥Ñ‰∏âÂçÅÁßí")
                        .scaleEffect(1.5)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let errorMessage = errorMessage {
                VStack {
                    Text("ÁîüÊàêÂêçÂ≠óÂ§±Êïó")
                        .font(.custom("NotoSansTC-Black", size: 24))
                        .foregroundColor(.red)
                        .padding()
                
                    Text(errorMessage)
                        .font(.custom("NotoSansTC-Regular", size: 18))
                        .foregroundColor(.customText)
                        .multilineTextAlignment(.center)
                        .padding()
                    
                    // Only show retry button if user has remaining uses
                    if usageManager.remainingUses > 0 {
                        Button("ÈáçË©¶") {
                            self.errorMessage = nil
                            generateName()  // This will deduct another point
                        }
                        .font(.custom("NotoSansTC-Regular", size: 18))
                        .foregroundColor(.white)
                        .padding()
                        .background(.customAccent)
                        .cornerRadius(10)
                        .onAppear { shouldDismissOnTap = false }
                    } else {
                        Text("ÊÇ®ÁöÑ‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆåÔºåË´ãËßÄÁúãÂª£ÂëäÁç≤ÂèñÊõ¥Â§öÊ¨°Êï∏„ÄÇ")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                            .padding()
                        
                        Button(action: {
                            navigationPath.removeLast(navigationPath.count)
                        }) {
                            Text("ÂõûÂà∞È¶ñÈ†Å")
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.white)
                                .padding(.horizontal, 20)
                                .padding(.vertical, 10)
                        }
                        .background(.customAccent)
                        .cornerRadius(10)
                        .padding(.top, 10)
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .contentShape(Rectangle())
                .onTapGesture {
                    if shouldDismissOnTap {
                        navigationPath.removeLast(navigationPath.count)
                    }
                }
            } else if let generatedName = generatedName, let nameAnalysis = nameAnalysis, let wuxing = wuxing {
                NameAnalysisView(
                    name: generatedName,
                    analysis: nameAnalysis,
                    wuxing: wuxing,
                    navigationPath: $navigationPath,
                    selectedTab: $selectedTab,  // ‰ΩøÁî®ÂÇ≥ÂÖ•ÁöÑ selectedTab
                    regenerateAction: generateName,
                    showButtons: true
                )
            } else {
                VStack(spacing: -10) {
                    if !questions.isEmpty {
                        VStack(spacing: 10) {
                            HStack(alignment: .center, spacing: 10) {
                                Image("main_mascot")
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: 120, height: 120)
                                    
                                // Question progress indicators
                                HStack(spacing: 8) {
                                    ForEach(0..<questions.count, id: \.self) { index in
                                        Button(action: {
                                            currentQuestionIndex = index
                                        }) {
                                            Text("\(index + 1)")
                                                .font(.custom("NotoSansTC-Black", size: 16))
                                                .foregroundColor(index == currentQuestionIndex ? .white : .customAccent)
                                                .frame(width: 30, height: 30)
                                                .background(
                                                    Circle()
                                                        .fill(index == currentQuestionIndex ? Color.customAccent : Color.white)
                                                )
                                                .overlay(
                                                    Circle()
                                                        .stroke(Color.customAccent, lineWidth: 1)
                                                )
                                        }
                                        .disabled(index > answers.count) // Âè™ËÉΩÈÅ∏ÊìáÂ∑≤ÂõûÁ≠îÈÅéÁöÑÈ°åÁõÆÊàñ‰∏ã‰∏ÄÈ°å
                                    }
                                }
                                .padding()
                                .background(Color.white.opacity(0.7))
                                .cornerRadius(10)

                                Spacer()
                            }

                            Text(questions[currentQuestionIndex].question)
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.customText)
                                .multilineTextAlignment(.leading)
                                .padding()
                                .background(Color.white.opacity(0.7))
                                .cornerRadius(10)
                        }
                        .padding()

                        Spacer()

                        // Choices
                        VStack(spacing: 15) {
                            ForEach(questions[currentQuestionIndex].choices, id: \.self) { choice in
                                Button(action: {
                                    handleAnswer(choice.text)
                                }) {
                                    Text(choice.text)
                                        .font(.custom("NotoSansTC-Black", size: 16))
                                        .foregroundColor(.customText)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                        .multilineTextAlignment(.leading)
                                        .padding()
                                        .background(
                                            answers.count > currentQuestionIndex && 
                                            answers[currentQuestionIndex] == choice.text ? 
                                                Color.customAccent.opacity(0.2) : Color.white
                                        )
                                        .cornerRadius(20)
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 20)
                                                .stroke(Color.customAccent, lineWidth: 1)
                                        )
                                }
                            }
                        }
                        .padding()

                        Spacer()
                        
                        // Navigation buttons
                        HStack {
                            if currentQuestionIndex > 0 {
                                Button("‰∏ä‰∏ÄÈ°å") {
                                    currentQuestionIndex -= 1
                                }
                                .buttonStyle(NavigationButtonStyle())
                            }
                            
                            Spacer()
                            
                            if answers.count == questions.count {
                                Button("ÂÆåÊàê") {
                                    generateName()
                                }
                                .buttonStyle(NavigationButtonStyle(isPrimary: true))
                            } else if currentQuestionIndex < questions.count - 1 {
                                Button("‰∏ã‰∏ÄÈ°å") {
                                    currentQuestionIndex += 1
                                }
                                .buttonStyle(NavigationButtonStyle())
                                .disabled(answers.count <= currentQuestionIndex)
                            }
                        }
                        .padding()
                    }
                    else {
                        VStack(spacing: 16) {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .font(.system(size: 40))
                                .foregroundColor(.orange)
                            
                            Text("ÁÑ°Ê≥ïËºâÂÖ•ÂïèÈ°å")
                                .font(.custom("NotoSansTC-Black", size: 20))
                                .foregroundColor(.customText)
                            
                            Text("Ë´ãÊ™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑öÂæåÈáçË©¶")
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        .padding()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }
                }
                .padding()
            }
        }
        .navigationBarTitle("ÂøÉÈùàÂ∞çË©±", displayMode: .inline)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                Button(action: {
                    navigationPath.removeLast()
                }) {
                    Image(systemName: "chevron.left")
                        .foregroundColor(.white)
                }
            }
            ToolbarItem(placement: .principal) {
                Text(isGeneratingName ? "ÁîüÊàêÂêçÂ≠ó‰∏≠" : (generatedName != nil ? "ÂêçÂ≠óÂàÜÊûê" : "ÂøÉÈùàÂ∞çË©±"))
                    .font(.custom("NotoSansTC-Black", size: 20))
                    .foregroundColor(.white)
            }
        }
        .toolbarBackground(.visible, for: .navigationBar)
        .toolbarBackground(Color.black, for: .navigationBar)
        .toolbarColorScheme(.dark, for: .navigationBar)
        .navigationBarBackButtonHidden(true)
        .navigationBarTitleDisplayMode(.inline)
        .overlay(
            Color.pink.frame(height: 5)
                .edgesIgnoringSafeArea(.horizontal)
                .offset(y: 0) // Adjust this value if needed to position the line correctly
            , alignment: .top
        )
        .onAppear(perform: loadQuestions)
        .background(
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
        )
        // Âú® body ‰∏≠ÈÅ©Áï∂‰ΩçÁΩÆÊ∑ªÂä†ÈåØË™§ÊèêÁ§∫Ë¶ñÁ™ó
        .alert("Â≠óÊï∏ÈåØË™§", isPresented: $showCharCountError) {
            Button("ÈáçÊñ∞ÁîüÊàê") {
                Task {
                    await generateName() // ÈáçÊñ∞ÁîüÊàêÂêçÂ≠ó
                }
            }
            Button("ÂèñÊ∂à", role: .cancel) {
                showCharCountError = false
            }
        } message: {
            let minLength = formData.numberOfNames + 1
            let maxLength = formData.numberOfNames + 2
            Text("ÁîüÊàêÁöÑÂêçÂ≠óÈï∑Â∫¶‰∏çÁ¨¶ÂêàÈ†êÊúü„ÄÇ\nÈ†êÊúüÈï∑Â∫¶Ôºö\(minLength)-\(maxLength) ÂÄãÂ≠ó\nÂØ¶ÈöõÈï∑Â∫¶Ôºö\(generatedNameWithError.count) ÂÄãÂ≠ó\n\nË¶ÅÈáçÊñ∞ÁîüÊàêÂóéÔºü")
        }
    }

    
    private func loadQuestions() {
        // Clear previous answers
        answers.removeAll()
        
        // Get questions from local cache
        questions = QuestionManager.shared.getRandomQuestions(5)
    }
    
    private func generateName() {
        // Add a guard to prevent multiple generations
        let monitor = PerformanceMonitor.shared
        monitor.reset()
        monitor.start("Total Generation Time")
        
        guard !isGenerating else { return }
        
        print("\n=== ÈñãÂßãÁîüÊàêÂêçÂ≠óÊµÅÁ®ã ===")
        monitor.start("Usage Check")
        print("üì± [Generate] ÈñãÂßãÁîüÊàêÂêçÂ≠óË´ãÊ±Ç")
        print("üìä [Uses] ÁîüÊàêÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")
        
        // Check remaining uses before generating
        if usageManager.remainingUses <= 0 {
            monitor.end("Usage Check")
            print("‚ùå [Generate] ‰ΩøÁî®Ê¨°Êï∏‰∏çË∂≥ÔºåÁÑ°Ê≥ïÁîüÊàê")
            errorMessage = "ÂæàÊä±Ê≠âÔºåÊÇ®ÁöÑÂÖçË≤ª‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆå„ÄÇ"
            return
        }
        monitor.end("Usage Check")
        
        // Set generating flag
        isGenerating = true
        
        // Deduct one use
        usageManager.remainingUses -= 1
        print("üìä [Uses] Êâ£Èô§‰∏ÄÊ¨°‰ΩøÁî®Ê©üÊúÉ")
        print("üìä [Uses] Áï∂ÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await usageManager.updateCloudData()
        }
        
        monitor.start("UI Update - Loading")
        isGeneratingName = true
        errorMessage = nil
        monitor.end("UI Update - Loading")

        // Prepare the prompt for the AI model
        monitor.start("Prompt Preparation")
        let prompt = preparePrompt()
        monitor.end("Prompt Preparation")

        // Call the OpenAI API to generate the name
        Task {
            do {
                print("ü§ñ [API] ÈñãÂßãË™øÁî® OpenAI API")
                monitor.start("API Call")
                print("üìù [Prompt] Ë™øÁî® OpenAI API ÁöÑ prompt: \(prompt)")
                let (name, analysis, wuxing) = try await callOpenAIAPI(with: prompt)
                monitor.end("API Call")
                print("‚úÖ [API] API Ë™øÁî®ÊàêÂäü")
                print("üìù [Result] ÁîüÊàêÁöÑÂêçÂ≠ó: \(name)")
                
                await MainActor.run {
                    monitor.start("UI Update - Results")
                    self.generatedName = name
                    self.nameAnalysis = analysis
                    self.wuxing = wuxing
                    self.isGeneratingName = false
                    self.isGenerating = false
                    monitor.end("UI Update - Results")
                    
                    print("‚úÖ [Generate] Â≠óÁîüÊàêÊµÅÁ®ãÂÆåÊàê")
                    monitor.end("Total Generation Time")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü ===\n")
                }
            } catch {
                await MainActor.run {
                    monitor.start("Error Handling")
                    self.isGeneratingName = false
                    self.isGenerating = false
                    // ‰ΩøÁî®Ë©≥Á¥∞ÁöÑÈåØË™§ÂàÜÈ°û
                    let detailedErrorMessage = self.categorizeError(error)
                    self.errorMessage = detailedErrorMessage
                    monitor.end("Error Handling")
                    
                    print("‚ùå [Generate] ÂêçÂ≠óÁîüÊàêÊµÅÁ®ãÂ§±Êïó")
                    monitor.end("Total Generation Time")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü ===\n")
                }
            }
        }
    }
    
    private func preparePrompt() -> String {
        let formData = """
        Áà∏Áà∏ÂßìÂêç: \(formData.fatherName)
        Â™ΩÂ™ΩÂßìÂêç: \(formData.motherName)
        ÂßìÊ∞èÈÅ∏Êìá: \(formData.surnameChoice)
        ÊåáÂÆö‰∏≠ÈñìÂ≠ó: \(formData.middleName)
        ÂñÆ/ÈõôÂêç: \(formData.numberOfNames == 1 ? "ÂñÆÂêç" : "ÈõôÂêç")
        ÊÄßÂà•: \(formData.gender)
        """
        
        let meaningString: String
        do {
            print("üìù [Meanings] ÈñãÂßãËôïÁêÜÂõûÁ≠îÊÑèÁæ©")
            meaningString = try answers.enumerated().map { index, answer in
                guard index < questions.count,
                      let selectedChoice = questions[index].choices.first(where: { $0.text == answer }) else {
                    throw NSError(domain: "MeaningMapping", code: 1, userInfo: [NSLocalizedDescriptionKey: "ÁÑ°Ê≥ïÊâæÂà∞Â∞çÊáâÁöÑÊÑèÁæ©"])
                }
                return """
                ÊúüË®±\(index + 1): \(selectedChoice.meaning)
                """
            }.joined(separator: "\n\n")
        } catch {
            print("Error mapping meanings: \(error)")
            meaningString = "Error processing meanings"
        }

        // ‰ΩøÁî® PromptManager Áç≤ÂèñÊ®°Êùø
        let template = PromptManager.shared.getNameGenerationPrompt()

        print("üîÑ [Prompts] ‰ΩøÁî® PromptManager Áç≤ÂèñÊ®°Êùø: \(template)")
        
        // Â∞áË≥áÊñôÂ°´ÂÖ•Ê®°Êùø
        return template
            .replacingOccurrences(of: "{{formData}}", with: formData)
            .replacingOccurrences(of: "{{meaningString}}", with: meaningString)
    }
    
    // MARK: - Êñ∞ÁâàÊèêÁ§∫Ë©ûÊ∫ñÂÇôÊñπÊ≥ï (ÈÅ©Áî®ÊñºÊñ∞workflow: Ë≥áÊñôÂ°´ÂØ´->Ë®≠Ë®à‰∏ªËª∏->ÁâπÊÆäÈúÄÊ±Ç->ÁîüÊàêÁµêÊûú)
    private func preparePromptv2(
        formData: FormData, 
        designFocusData: DesignFocusData, 
        specialRequirementData: SpecialRequirementData?
    ) -> String {
        
        // 1. Âü∫Êú¨Ë≥áÊñôÈÉ®ÂàÜ
        var formDataString = """
        Áà∏Áà∏ÂßìÂêç: \(formData.fatherName)
        Â™ΩÂ™ΩÂßìÂêç: \(formData.motherName)
        ÂßìÊ∞èÈÅ∏Êìá: \(formData.surnameChoice)
        """
        
        // Âè™ÊúâÈùûÁ©∫ÁöÑ‰∏≠ÈñìÂ≠óÊâçÂä†ÂÖ•
        if !formData.middleName.isEmpty {
            formDataString += "\nÊåáÂÆö‰∏≠ÈñìÂ≠ó: \(formData.middleName)"
        }
        
        formDataString += """
        
        ÂñÆ/ÈõôÂêç: \(formData.numberOfNames == 1 ? "ÂñÆÂêç" : "ÈõôÂêç")
        ÊÄßÂà•: \(formData.gender)
        """
        
        // 2. Ë®≠Ë®à‰∏ªËª∏ÈÉ®ÂàÜ
        var designFocusString = ""
        if !designFocusData.selectedOptions.isEmpty {
            designFocusString = """
            
            Ë®≠Ë®à‰∏ªËª∏:
            \(designFocusData.selectedOptions.map { "- \($0)" }.joined(separator: "\n"))
            """
        }
        
        // Â¶ÇÊûúÊúâËá™ÂÆöÁæ©ÊèèËø∞ÔºåÂâáÂä†ÂÖ•
        if let customDescription = designFocusData.customDescription, !customDescription.isEmpty {
            if designFocusString.isEmpty {
                designFocusString = "\nË®≠Ë®à‰∏ªËª∏:"
            }
            designFocusString += "\n- Ëá™ÂÆöÁæ©ÊèèËø∞: \(customDescription)"
        }
        
        // 3. ÁâπÊÆäÈúÄÊ±ÇÈÉ®ÂàÜ
        var specialRequirementString = ""
        if let specialRequirementData = specialRequirementData {
            if !specialRequirementData.selectedRequirements.isEmpty {
                specialRequirementString = """
                
                ÁâπÊÆäÈúÄÊ±Ç:
                \(specialRequirementData.selectedRequirements.map { "- \($0)" }.joined(separator: "\n"))
                """
            }
            
            // Â¶ÇÊûúÊúâË©≥Á¥∞ÊèèËø∞ÔºåÂâáÂä†ÂÖ•
            if let detailDescription = specialRequirementData.detailDescription, !detailDescription.isEmpty {
                if specialRequirementString.isEmpty {
                    specialRequirementString = "\nÁâπÊÆäÈúÄÊ±Ç:"
                }
                specialRequirementString += "\n- Ë©≥Á¥∞Ë™™Êòé: \(detailDescription)"
            }
        }
        
        // 4. ÁµÑÂêàÂÆåÊï¥ÁöÑË°®ÂñÆË≥áÊñô
        let completeFormData = formDataString + designFocusString + specialRequirementString
        
        // 5. ‰ΩøÁî®Â∞àÈñÄÁÇ∫Êñ∞workflowË®≠Ë®àÁöÑÊ®°Êùø
        let template = """
        Ë´ãÊ†πÊìö‰ª•‰∏ãË°®ÂñÆË≥áÊñôÁÇ∫Â¨∞ÂÖíÁîüÊàê‰∏≠ÊñáÂêçÂ≠óÔºö

        ÂëΩÂêçË¶ÅÊ±ÇÔºö
        1. ÂêçÂ≠óÁÇ∫ÂñÆÂêçÊàñÈõôÂêçÔºåÂãôÂøÖÁ¢∫‰øùËàáÂü∫Êú¨Ë≥áÊñô‰∏≠ÁöÑÂñÆÈõôÂêç‰∏ÄËá¥„ÄÇ
        2. Â¶ÇÊúâÊåáÂÆö‰∏≠ÈñìÂ≠óÔºåÈ†àÂåÖÂê´ÊñºÂêç‰∏≠„ÄÇ
        3. ÂêçÂ≠óÁ¨¶ÂêàÂ¨∞ÂÖíÊÄßÂà•„ÄÇ
        4. ÂÖ∏ÊïÖ‰æÜÊ∫êÊñºÂÖ∑È´îÂÖßÂÆπ‰∏çÂèØÂÉÖÂºïÁî®ÁØáÂêç„ÄÇ
        5. ÂÖ∏ÊïÖËàáÂêçÂ≠óÊúâÊòéÁ¢∫ËÅØÁπ´Ôºå‰∏¶Ë©≥Ëø∞ÂÖ∂Èóú‰øÇ„ÄÇ
        6. Ê†πÊìöË®≠Ë®à‰∏ªËª∏Êèê‰æõÂàÜÊûêÔºåË™™ÊòéÂêçÂ≠óÂ¶Ç‰ΩïÈ´îÁèæË®≠Ë®àÁêÜÂøµ„ÄÇ
        7. Ê†πÊìöÁâπÊÆäÈúÄÊ±ÇÊèê‰æõÂàÜÊûêÔºåË™™ÊòéÂêçÂ≠óÂ¶Ç‰ΩïÊªøË∂≥ÁâπÊÆäË¶ÅÊ±Ç„ÄÇ
        
        Ê≥®ÊÑè‰∫ãÈ†ÖÔºö
        1. Ë´ãÁ¢∫‰øùËº∏Âá∫Ê†ºÂºèÁ¨¶ÂêàJSONË¶èÁØÑ„ÄÇ
        2. ÊâÄÊúâÂ≠ó‰∏≤ÂÄº‰ΩøÁî®ÈõôÂºïËôüÔºå‰∏¶ÈÅ©Áï∂‰ΩøÁî®ËΩâÁæ©Â≠óÁ¨¶„ÄÇ
        3. Ë´ã‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÔºåÁ¶ÅÊ≠¢‰ΩøÁî®Á∞°È´î‰∏≠Êñá„ÄÇ

        Âü∫Êú¨Ë≥áÊñôÔºö{{formData}}
        """
        
        print("üîÑ [Prompts] ‰ΩøÁî®Êñ∞workflowÂ∞àÁî®Ê®°Êùøv2: \(template)")
        print("üìù [FormData] ÂÆåÊï¥Ë°®ÂñÆË≥áÊñôv2: \(completeFormData)")
        
        // 6. Â∞áË≥áÊñôÂ°´ÂÖ•Ê®°Êùø
        return template.replacingOccurrences(of: "{{formData}}", with: completeFormData)
    }
    
    // MARK: - Êñ∞ÁâàÂêçÂ≠óÁîüÊàêÊñπÊ≥ï (ÈÅ©Áî®ÊñºÊñ∞workflow)
    private func generateNamev2(
        formData: FormData,
        designFocusData: DesignFocusData, 
        specialRequirementData: SpecialRequirementData?
    ) {
        // Add a guard to prevent multiple generations
        let monitor = PerformanceMonitor.shared
        monitor.reset()
        monitor.start("Total Generation Time v2")
        
        guard !isGenerating else { return }
        
        print("\n=== ÈñãÂßãÁîüÊàêÂêçÂ≠óÊµÅÁ®ã v2 ===")
        monitor.start("Usage Check")
        print("üì± [Generate v2] ÈñãÂßãÁîüÊàêÂêçÂ≠óË´ãÊ±Ç")
        print("üìä [Uses] ÁîüÊàêÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")
        
        // Check remaining uses before generating
        if usageManager.remainingUses <= 0 {
            monitor.end("Usage Check")
            print("‚ùå [Generate v2] ‰ΩøÁî®Ê¨°Êï∏‰∏çË∂≥ÔºåÁÑ°Ê≥ïÁîüÊàê")
            errorMessage = "ÂæàÊä±Ê≠âÔºåÊÇ®ÁöÑÂÖçË≤ª‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆå„ÄÇ"
            return
        }
        monitor.end("Usage Check")
        
        // Set generating flag
        isGenerating = true
        
        // Deduct one use
        usageManager.remainingUses -= 1
        print("üìä [Uses] Êâ£Èô§‰∏ÄÊ¨°‰ΩøÁî®Ê©üÊúÉ")
        print("üìä [Uses] Áï∂ÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await usageManager.updateCloudData()
        }
        
        monitor.start("UI Update - Loading")
        isGeneratingName = true
        errorMessage = nil
        monitor.end("UI Update - Loading")

        // Prepare the prompt for the AI model using v2 method
        monitor.start("Prompt Preparation v2")
        let prompt = preparePromptv2(
            formData: formData,
            designFocusData: designFocusData,
            specialRequirementData: specialRequirementData
        )
        monitor.end("Prompt Preparation v2")

        // Call the OpenAI API to generate the name (reuse existing API call method)
        Task {
            do {
                print("ü§ñ [API v2] ÈñãÂßãË™øÁî® OpenAI API")
                monitor.start("API Call v2")
                print("üìù [Prompt v2] Ë™øÁî® OpenAI API ÁöÑ prompt: \(prompt)")
                let (name, analysis, wuxing) = try await callOpenAIAPIv2(
                    with: prompt, 
                    formData: formData
                )
                monitor.end("API Call v2")
                print("‚úÖ [API v2] API Ë™øÁî®ÊàêÂäü")
                print("üìù [Result v2] ÁîüÊàêÁöÑÂêçÂ≠ó: \(name)")
                
                await MainActor.run {
                    monitor.start("UI Update - Results v2")
                    self.generatedName = name
                    self.nameAnalysis = analysis
                    self.wuxing = wuxing
                    self.isGeneratingName = false
                    self.isGenerating = false
                    monitor.end("UI Update - Results v2")
                    
                    print("‚úÖ [Generate v2] ÂêçÂ≠óÁîüÊàêÊµÅÁ®ãÂÆåÊàê")
                    monitor.end("Total Generation Time v2")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü v2 ===\n")
                }
            } catch {
                await MainActor.run {
                    monitor.start("Error Handling v2")
                    self.isGeneratingName = false
                    self.isGenerating = false
                    // ‰ΩøÁî®Ë©≥Á¥∞ÁöÑÈåØË™§ÂàÜÈ°û
                    let detailedErrorMessage = self.categorizeError(error)
                    self.errorMessage = detailedErrorMessage
                    monitor.end("Error Handling v2")
                    
                    // Ë©≥Á¥∞ÁöÑÈåØË™§Êó•Ë™å
                    print("‚ùå [Generate v2] ÂêçÂ≠óÁîüÊàêÊµÅÁ®ãÂ§±Êïó")
                    print("üîç [Error Details] ÈåØË™§È°ûÂûã: \(type(of: error))")
                    print("üîç [Error Details] ÈåØË™§ÊèèËø∞: \(error.localizedDescription)")
                    if let nsError = error as NSError? {
                        print("üîç [Error Details] ÈåØË™§‰ª£Á¢º: \(nsError.code)")
                        print("üîç [Error Details] ÈåØË™§Âüü: \(nsError.domain)")
                        print("üîç [Error Details] Áî®Êà∂‰ø°ÊÅØ: \(nsError.userInfo)")
                    }
                    print("üîç [Error Details] Áî®Êà∂ÁúãÂà∞ÁöÑÈåØË™§Ë®äÊÅØ: \(detailedErrorMessage)")
                    monitor.end("Total Generation Time v2")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü v2 ===\n")
                }
            }
        }
    }

    // 1. È¶ñÂÖàÂÆöÁæ©ÊâÄÈúÄÁöÑ JSON Schema
    private func createNameGenerationSchema() -> JSONSchema {
        // ÊÉÖÂ¢ÉÂàÜÊûêÁöÑ Schema
        let situationalAnalysisSchema = JSONSchema(
            type: .object,
            properties: [
                "question": JSONSchema(type: .string),
                "answer": JSONSchema(type: .string),
                "analysis": JSONSchema(type: .string)
            ],
            required: ["question", "answer", "analysis"],
            additionalProperties: false
        )

        // ÂÖ∏ÊïÖÂàÜÊûêÁöÑ Schema
        let literaryAllusionSchema = JSONSchema(
            type: .object,
            properties: [
                "source": JSONSchema(type: .string),
                "original_text": JSONSchema(type: .string),
                "interpretation": JSONSchema(type: .string),
                "connection": JSONSchema(type: .string)
            ],
            required: ["source", "original_text", "interpretation", "connection"],
            additionalProperties: false
        )

        // ÂàÜÊûêÁöÑ Schema
        let analysisSchema = JSONSchema(
            type: .object,
            properties: [
                "character_meaning": JSONSchema(type: .string),
                "literary_allusion": literaryAllusionSchema,
                "situational_analysis": JSONSchema(
                    type: .object,
                    properties: [
                        "1": situationalAnalysisSchema,
                        "2": situationalAnalysisSchema,
                        "3": situationalAnalysisSchema,
                        "4": situationalAnalysisSchema,
                        "5": situationalAnalysisSchema
                    ],
                    required: ["1", "2", "3", "4", "5"],
                    additionalProperties: false
                )
            ],
            required: ["character_meaning", "literary_allusion", "situational_analysis"],
            additionalProperties: false
        )

        // ÂÆåÊï¥ÁöÑÂõûÊáâ Schema
        return JSONSchema(
            type: .object,
            properties: [
                "name": JSONSchema(type: .string),
                "analysis": analysisSchema
            ],
            required: ["name", "analysis"],
            additionalProperties: false
        )
    }

    // 2. ‰øÆÊîπ API Ë™øÁî®ÂáΩÊï∏
    private func callOpenAIAPI(with prompt: String) async throws -> (String, [String: String], [String]) {
        let monitor = PerformanceMonitor.shared
        
        monitor.start("API Setup")
        let apiKey = APIConfig.openAIKey
        let service = OpenAIServiceFactory.service(apiKey: apiKey)
        monitor.end("API Setup")

        // 1. ÂÆöÁæ©ÊÉÖÂ¢ÉÂàÜÊûêÁöÑ Schema
        let situationalAnalysisSchema = JSONSchema(
            type: .object,
            properties: [
                "question": JSONSchema(type: .string),
                "answer": JSONSchema(type: .string),
                "analysis": JSONSchema(type: .string)
            ],
            required: ["question", "answer", "analysis"],
            additionalProperties: false
        )

        // 2. ÂÆöÁæ©ÂÖ∏ÊïÖÂàÜÊûêÁöÑ Schema
        let literaryAllusionSchema = JSONSchema(
            type: .object,
            properties: [
                "source": JSONSchema(type: .string),
                "original_text": JSONSchema(type: .string),
                "interpretation": JSONSchema(type: .string),
                "connection": JSONSchema(type: .string)
            ],
            required: ["source", "original_text", "interpretation", "connection"],
            additionalProperties: false
        )

        // 3. ÂÆöÁæ©ÂàÜÊûêÁöÑ Schema
        let analysisSchema = JSONSchema(
            type: .object,
            properties: [
                "character_meaning": JSONSchema(type: .string),
                "literary_allusion": literaryAllusionSchema,
                "situational_analysis": JSONSchema(
                    type: .object,
                    properties: [
                        "1": situationalAnalysisSchema,
                        "2": situationalAnalysisSchema,
                        "3": situationalAnalysisSchema,
                        "4": situationalAnalysisSchema,
                        "5": situationalAnalysisSchema
                    ],
                    required: ["1", "2", "3", "4", "5"],
                    additionalProperties: false
                )
            ],
            required: ["character_meaning", "literary_allusion", "situational_analysis"],
            additionalProperties: false
        )

        // 4. ÂÆöÁæ©ÂõûÊáâÊ†ºÂºèÁöÑ Schema
        let responseFormatSchema = JSONSchemaResponseFormat(
            name: "name_generation",
            strict: true,
            schema: JSONSchema(
                type: .object,
                properties: [
                    "name": JSONSchema(type: .string),
                    "analysis": analysisSchema
                ],
                required: ["name", "analysis"],
                additionalProperties: false
            )
        )

        let messages: [ChatCompletionParameters.Message] = [
            .init(role: .system, content: .text(PromptManager.shared.getSystemPrompt())),
            .init(role: .user, content: .text(prompt))
        ]

        let parameters = ChatCompletionParameters(
            messages: messages,
            model: .gpt4omini,
            responseFormat: .jsonSchema(responseFormatSchema)
        )

        monitor.start("API Request Preparation")
        let completionObject = try await service.startChat(parameters: parameters)
        monitor.end("API Request Preparation")
        
        monitor.start("Response Processing")
        guard let jsonString = completionObject.choices.first?.message.content,
              let jsonData = jsonString.data(using: .utf8) else {
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Invalid AI response format",
                details: [
                    "prompt": prompt,
                    "response": completionObject.choices.first?.message.content ?? "No content"
                ]
            )
            throw NSError(domain: "OpenAIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response format"])
        }

        do {
            let jsonResult = try JSONDecoder().decode(NameGenerationResult.self, from: jsonData)
            
            // Áç≤Âèñ‰∫îË°åÂ±¨ÊÄß
            let elements = jsonResult.name.map { char in
                CharacterManager.shared.getElement(for: String(char))
            }
            
            // ÊßãÂª∫ÂàÜÊûêÂ≠óÂÖ∏
            let analysisDict: [String: String] = [
                "Â≠óÁæ©ÂàÜÊûê": jsonResult.analysis.character_meaning,
                "ÂÖ∏ÊïÖÂàÜÊûê": """
                    Âá∫ËôïÔºö\(jsonResult.analysis.literary_allusion.source)
                    ÂéüÊñáÔºö\(jsonResult.analysis.literary_allusion.original_text)
                    ÈáãÁæ©Ôºö\(jsonResult.analysis.literary_allusion.interpretation)
                    ÈÄ£ÁµêÔºö\(jsonResult.analysis.literary_allusion.connection)
                    """,
                "ÊÉÖÂ¢ÉÂàÜÊûê": Array(zip(questions, answers)).enumerated().map { index, qa in
                    let analysis = switch index {
                        case 0: jsonResult.analysis.situational_analysis.one.analysis
                        case 1: jsonResult.analysis.situational_analysis.two.analysis
                        case 2: jsonResult.analysis.situational_analysis.three.analysis
                        case 3: jsonResult.analysis.situational_analysis.four.analysis
                        case 4: jsonResult.analysis.situational_analysis.five.analysis
                        default: "ÂàÜÊûêË≥áÊñôÁº∫Â§±"
                    }
                    return "Q\(index + 1)Ôºö\(qa.0.question)\nAÔºö\(qa.1)\n‚Üí \(analysis)"
                }.joined(separator: "\n\n")
            ]


            monitor.end("Response Processing")
            
            // Add character count validation
            // Áî±ÊñºÁèæÂú®Ê≤íÊúâÂõ∫ÂÆöÂßìÊ∞èÔºåÂè™È©óË≠âÁîüÊàêÁöÑÂêçÂ≠óÁ∏ΩÈï∑Â∫¶ÊòØÂê¶ÂêàÁêÜ
            let expectedCharCount = formData.numberOfNames
            let actualCharCount = jsonResult.name.count
            
            // ÂêàÁêÜÁöÑÂêçÂ≠óÈï∑Â∫¶ÁØÑÂúçÔºöÂñÆÂêç 2-3 Â≠óÔºåÈõôÂêç 3-4 Â≠ó
            let minLength = formData.numberOfNames + 1  // Ëá≥Â∞ëÈúÄË¶ÅÂßìÊ∞è + ÊåáÂÆöÂ≠óÊï∏
            let maxLength = formData.numberOfNames + 2  // ÊúÄÂ§öÂßìÊ∞è 2 Â≠ó + ÊåáÂÆöÂ≠óÊï∏
            
            if actualCharCount < minLength || actualCharCount > maxLength {
                ErrorManager.shared.logError(
                    category: .aiResponseWrongCharacterCount,
                    message: "ÁîüÊàêÂêçÂ≠óÂ≠óÊï∏ÈåØË™§",
                    details: [
                        "expected_range": "\(minLength)-\(maxLength)",
                        "actual_count": "\(actualCharCount)",
                        "generated_name": jsonResult.name,
                        "father_name": formData.fatherName,
                        "mother_name": formData.motherName
                    ]
                )
                showCharCountError = true
                generatedNameWithError = jsonResult.name
                throw NameGenerationError.wrongCharacterCount(
                    expected: expectedCharCount,
                    actual: actualCharCount
                )
            }
            
            return (jsonResult.name, analysisDict, elements)
        } catch let decodingError as DecodingError {
            // JSON Ëß£ÊûêÈåØË™§
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Failed to decode AI response",
                details: [
                    "error": decodingError.localizedDescription,
                    "json": String(data: jsonData, encoding: .utf8) ?? "Invalid JSON"
                ]
            )
            throw decodingError
            
        } catch let networkError as URLError {
            // Á∂≤Ë∑ØÁõ∏ÈóúÈåØË™§
            let category: ErrorCategory = {
                switch networkError.code {
                case .timedOut:
                    return .apiCallTimeout
                case .notConnectedToInternet:
                    return .apiCallNetworkError
                default:
                    return .apiCallNetworkError
                }
            }()
            
            ErrorManager.shared.logError(
                category: category,
                message: "API network error",
                details: [
                    "error_code": "\(networkError.code.rawValue)",
                    "error_description": networkError.localizedDescription
                ]
            )
            throw networkError
            
        } catch {
            // ÂÖ∂‰ªñÊú™È†êÊúüÁöÑÈåØË™§
            ErrorManager.shared.logError(
                category: .unknown,
                message: "Unexpected error in AI response handling",
                details: [
                    "error": error.localizedDescription,
                    "prompt": prompt
                ]
            )
            throw error
        }
    }
    
    // MARK: - Êñ∞ÁâàAPIË™øÁî®ÊñπÊ≥ï (ÈÅ©Áî®ÊñºÊñ∞workflowÔºåÂÖºÂÆπv1ÁµêÊûúÊ®°Êùø)
    private func callOpenAIAPIv2(with prompt: String, formData: FormData) async throws -> (String, [String: String], [String]) {
        let monitor = PerformanceMonitor.shared
        
        monitor.start("API Setup v2")
        let apiKey = APIConfig.openAIKey
        let service = OpenAIServiceFactory.service(apiKey: apiKey)
        monitor.end("API Setup v2")

        // 1. ÂÆöÁæ©ÂÖ∏ÊïÖÂàÜÊûêÁöÑ Schema
        let literaryAllusionSchema = JSONSchema(
            type: .object,
            properties: [
                "source": JSONSchema(type: .string),
                "original_text": JSONSchema(type: .string),
                "interpretation": JSONSchema(type: .string),
                "connection": JSONSchema(type: .string)
            ],
            required: ["source", "original_text", "interpretation", "connection"],
            additionalProperties: false
        )

        // 2. ÂÆöÁæ©ÂàÜÊûêÁöÑ Schema (Á∞°ÂåñÁâàÔºå‰∏çÂåÖÂê´ÊÉÖÂ¢ÉÂàÜÊûê)
        let analysisSchema = JSONSchema(
            type: .object,
            properties: [
                "character_meaning": JSONSchema(type: .string),
                "literary_allusion": literaryAllusionSchema,
                "design_focus_analysis": JSONSchema(type: .string), // Êñ∞Â¢ûÔºöË®≠Ë®à‰∏ªËª∏ÂàÜÊûê
                "special_requirements_analysis": JSONSchema(type: .string) // Êñ∞Â¢ûÔºöÁâπÊÆäÈúÄÊ±ÇÂàÜÊûê
            ],
            required: ["character_meaning", "literary_allusion", "design_focus_analysis", "special_requirements_analysis"],
            additionalProperties: false
        )

        // 3. ÂÆöÁæ©ÂõûÊáâÊ†ºÂºèÁöÑ Schema
        let responseFormatSchema = JSONSchemaResponseFormat(
            name: "name_generation_v2",
            strict: true,
            schema: JSONSchema(
                type: .object,
                properties: [
                    "name": JSONSchema(type: .string),
                    "analysis": analysisSchema
                ],
                required: ["name", "analysis"],
                additionalProperties: false
            )
        )

        let messages: [ChatCompletionParameters.Message] = [
            .init(role: .system, content: .text(PromptManager.shared.getSystemPrompt())),
            .init(role: .user, content: .text(prompt))
        ]

        let parameters = ChatCompletionParameters(
            messages: messages,
            model: .gpt4omini,
            responseFormat: .jsonSchema(responseFormatSchema)
        )

        monitor.start("API Request Preparation v2")
        let completionObject = try await service.startChat(parameters: parameters)
        monitor.end("API Request Preparation v2")
        
        monitor.start("Response Processing v2")
        
        // üîç ÊâìÂç∞ÂÆåÊï¥ÁöÑÂéüÂßãAPIÂõûË¶Ü (DialogView)
        print("üì° [Raw API Response] ======== ÈñãÂßãÂéüÂßãAPIÂõûË¶Ü (DialogView) ========")
        print("üì° [Raw API Response] ÂÆåÊï¥completionObject: \(completionObject)")
        print("üì° [Raw API Response] choicesÊï∏Èáè: \(completionObject.choices.count)")
        
        if let firstChoice = completionObject.choices.first {
            print("üì° [Raw API Response] Á¨¨‰∏ÄÂÄãchoiceÁöÑmessage: \(firstChoice.message)")
            print("üì° [Raw API Response] message.role: \(firstChoice.message.role)")
            print("üì° [Raw API Response] message.content: \(firstChoice.message.content ?? "nil")")
        }
        
        guard let jsonString = completionObject.choices.first?.message.content,
              let jsonData = jsonString.data(using: .utf8) else {
            print("‚ùå [Raw API Response] ÁÑ°Ê≥ïÁç≤ÂèñÊúâÊïàÁöÑJSONÂõûÊáâ (DialogView)")
            print("üì° [Raw API Response] ======== ÁµêÊùüÂéüÂßãAPIÂõûË¶Ü (DialogView) ========")
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Invalid AI response format v2",
                details: [
                    "prompt": prompt,
                    "response": completionObject.choices.first?.message.content ?? "No content"
                ]
            )
            throw NSError(domain: "OpenAIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response format"])
        }
        
        print("üì° [Raw API Response] ÂéüÂßãJSONÂ≠ó‰∏≤: \(jsonString)")
        print("üì° [Raw API Response] JSONÂ≠ó‰∏≤Èï∑Â∫¶: \(jsonString.count)Â≠óÁ¨¶")
        print("üì° [Raw API Response] ======== ÁµêÊùüÂéüÂßãAPIÂõûË¶Ü (DialogView) ========")

        do {
            let jsonResult = try JSONDecoder().decode(NameGenerationResultv2.self, from: jsonData)
            
            // üîç Ë©≥Á¥∞ÁöÑAPIÂõûÂÇ≥ÁµêÊûúÊâìÂç∞
            print("‚úÖ [API Response] JSONËß£ÊûêÊàêÂäü (DialogView)")
            print("üìù [API Response] ÂéüÂßãJSONÊï∏Êìö: \(String(data: jsonData, encoding: .utf8) ?? "ÁÑ°Ê≥ïËÆÄÂèñ")")
            print("üìù [API Response] ÁîüÊàêÁöÑÂêçÂ≠ó: '\(jsonResult.name)'")
            print("üìù [API Response] ÂêçÂ≠óÂ≠óÊï∏: \(jsonResult.name.count)")
            print("üìù [API Response] ÂêçÂ≠óÁöÑÊØèÂÄãÂ≠óÁ¨¶: \(jsonResult.name.map { "'\($0)'" }.joined(separator: ", "))")
            print("üìù [API Response] Â≠óÁæ©ÂàÜÊûê: \(jsonResult.analysis.character_meaning)")
            print("üìù [API Response] ÂÖ∏ÊïÖ‰æÜÊ∫ê: \(jsonResult.analysis.literary_allusion.source)")
            print("üìù [API Response] ÂÖ∏ÊïÖÂéüÊñá: \(jsonResult.analysis.literary_allusion.original_text)")
            print("üìù [API Response] ÂÖ∏ÊïÖÈáãÁæ©: \(jsonResult.analysis.literary_allusion.interpretation)")
            print("üìù [API Response] ÂÖ∏ÊïÖÈÄ£Áµê: \(jsonResult.analysis.literary_allusion.connection)")
            print("üìù [API Response] Ë®≠Ë®à‰∏ªËª∏ÂàÜÊûê: \(jsonResult.analysis.design_focus_analysis)")
            print("üìù [API Response] ÁâπÊÆäÈúÄÊ±ÇÂàÜÊûê: \(jsonResult.analysis.special_requirements_analysis)")
            
            // Áç≤Âèñ‰∫îË°åÂ±¨ÊÄß
            let elements = jsonResult.name.map { char in
                CharacterManager.shared.getElement(for: String(char))
            }
            print("üìù [API Response] ‰∫îË°åÂ±¨ÊÄß: \(elements)")
            
            // ÊßãÂª∫ÂàÜÊûêÂ≠óÂÖ∏ (ÂÖºÂÆπv1Ê®°ÊùøÊ†ºÂºè)
            let analysisDict: [String: String] = [
                "Â≠óÁæ©ÂàÜÊûê": jsonResult.analysis.character_meaning,
                "ÂÖ∏ÊïÖÂàÜÊûê": """
                    Âá∫ËôïÔºö\(jsonResult.analysis.literary_allusion.source)
                    ÂéüÊñáÔºö\(jsonResult.analysis.literary_allusion.original_text)
                    ÈáãÁæ©Ôºö\(jsonResult.analysis.literary_allusion.interpretation)
                    ÈÄ£ÁµêÔºö\(jsonResult.analysis.literary_allusion.connection)
                    """,
                "Ë®≠Ë®à‰∏ªËª∏ÂàÜÊûê": jsonResult.analysis.design_focus_analysis,
                "ÁâπÊÆäÈúÄÊ±ÇÂàÜÊûê": jsonResult.analysis.special_requirements_analysis
            ]

            monitor.end("Response Processing v2")
            
            // üîç Ë©≥Á¥∞ÁöÑÂ≠óÊï∏Ê™¢Êü•ÈÇèËºØÊâìÂç∞
            let expectedCharCount = formData.numberOfNames
            let actualCharCount = jsonResult.name.count
            
            print("üîç [Character Count Check] ÈñãÂßãÂ≠óÊï∏Ê™¢Êü•...")
            print("üîç [Character Count Check] formData.numberOfNames: \(formData.numberOfNames)")
            print("üîç [Character Count Check] expectedCharCount: \(expectedCharCount)")
            print("üîç [Character Count Check] actualCharCount: \(actualCharCount)")
            print("üîç [Character Count Check] Áà∂Ë¶™ÂßìÂêç: '\(formData.fatherName)'")
            print("üîç [Character Count Check] ÊØçË¶™ÂßìÂêç: '\(formData.motherName)'")
            
            // ‰øÆÊ≠£Â≠óÊï∏Ê™¢Êü•ÈÇèËºØÔºöÊ†πÊìöÂñÆÂêç/ÈõôÂêçÊ≠£Á¢∫Ë®àÁÆóÊúüÊúõÁ∏ΩÂ≠óÊï∏
            let expectedTotalLength: Int
            if formData.numberOfNames == 1 {
                // ÂñÆÂêçÔºöÂßìÊ∞è(1-2Â≠ó) + Âêç(1Â≠ó) = 2-3Â≠ó
                expectedTotalLength = 2 // ÊúÄÂ∏∏Ë¶ãÁöÑÊÉÖÊ≥ÅÔºöÂñÆÂßì+ÂñÆÂêç
            } else {
                // ÈõôÂêçÔºöÂßìÊ∞è(1-2Â≠ó) + Âêç(2Â≠ó) = 3-4Â≠ó  
                expectedTotalLength = 3 // ÊúÄÂ∏∏Ë¶ãÁöÑÊÉÖÊ≥ÅÔºöÂñÆÂßì+ÈõôÂêç
            }
            
            // ÂÖÅË®±ÁöÑÂ≠óÊï∏ÁØÑÂúç
            let minLength = expectedTotalLength
            let maxLength = expectedTotalLength + 1 // ÂÖÅË®±Ë§áÂßìÁöÑÊÉÖÊ≥Å
            
            print("üîç [Character Count Check] ÊúüÊúõÁ∏ΩÈï∑Â∫¶: \(expectedTotalLength)")
            print("üîç [Character Count Check] ÂÖÅË®±ÁØÑÂúç: \(minLength)-\(maxLength)Â≠ó")
            print("üîç [Character Count Check] ÂØ¶ÈöõÈï∑Â∫¶: \(actualCharCount)Â≠ó")
            print("üîç [Character Count Check] Ê™¢Êü•ÁµêÊûú: \(actualCharCount >= minLength && actualCharCount <= maxLength ? "‚úÖ ÈÄöÈÅé" : "‚ùå ‰∏çÈÄöÈÅé")")
            
            if actualCharCount < minLength || actualCharCount > maxLength {
                ErrorManager.shared.logError(
                    category: .aiResponseWrongCharacterCount,
                    message: "ÁîüÊàêÂêçÂ≠óÂ≠óÊï∏ÈåØË™§ v2",
                    details: [
                        "expected_range": "\(minLength)-\(maxLength)",
                        "actual_count": "\(actualCharCount)",
                        "generated_name": jsonResult.name,
                        "father_name": formData.fatherName,
                        "mother_name": formData.motherName,
                        "number_of_names": "\(formData.numberOfNames)"
                    ]
                )
                print("‚ùå [Character Count Check] Â≠óÊï∏Ê™¢Êü•Â§±ÊïóÔºåÊããÂá∫ÈåØË™§")
                showCharCountError = true
                generatedNameWithError = jsonResult.name
                throw NameGenerationError.wrongCharacterCount(
                    expected: formData.numberOfNames, // ÂÇ≥ÈÅûÂØ¶ÈöõË¶ÅÊ±ÇÁöÑÂêçÂ≠óÂ≠óÊï∏
                    actual: actualCharCount - 1 // Ê∏õÂéªÂßìÊ∞èÂ≠óÊï∏ÔºåÂè™Ë®àÁÆóÂêçÂ≠óÈÉ®ÂàÜ
                )
            }
            
            print("‚úÖ [Character Count Check] Â≠óÊï∏Ê™¢Êü•ÈÄöÈÅé")
            return (jsonResult.name, analysisDict, elements)
            
        } catch let decodingError as DecodingError {
            // JSON Ëß£ÊûêÈåØË™§
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Failed to decode AI response v2",
                details: [
                    "error": decodingError.localizedDescription,
                    "json": String(data: jsonData, encoding: .utf8) ?? "Invalid JSON"
                ]
            )
            throw decodingError
            
        } catch let networkError as URLError {
            // Á∂≤Ë∑ØÁõ∏ÈóúÈåØË™§
            let category: ErrorCategory = {
                switch networkError.code {
                case .timedOut:
                    return .apiCallTimeout
                case .notConnectedToInternet:
                    return .apiCallNetworkError
                default:
                    return .apiCallNetworkError
                }
            }()
            
            ErrorManager.shared.logError(
                category: category,
                message: "API network error v2",
                details: [
                    "error_code": "\(networkError.code.rawValue)",
                    "error_description": networkError.localizedDescription
                ]
            )
            throw networkError
            
        } catch {
            // ÂÖ∂‰ªñÊú™È†êÊúüÁöÑÈåØË™§
            ErrorManager.shared.logError(
                category: .unknown,
                message: "Unexpected error in AI response handling v2",
                details: [
                    "error": error.localizedDescription,
                    "prompt": prompt
                ]
            )
            throw error
        }
    }
    
    private func handleAnswer(_ answer: String) {
        if answers.count > currentQuestionIndex {
            // Êõ¥Êñ∞ÁèæÊúâÁ≠îÊ°à
            answers[currentQuestionIndex] = answer
        } else {
            // Ê∑ªÂä†Êñ∞Á≠îÊ°à
            answers.append(answer)
        }
        
        // Â¶ÇÊûú‰∏çÊòØÊúÄÂæå‰∏ÄÈ°åÔºåËá™ÂãïÂâçÈÄ≤Âà∞‰∏ã‰∏ÄÈ°å
        if currentQuestionIndex < questions.count - 1 {
            currentQuestionIndex += 1
        }
    }
    
    // MARK: - ÈåØË™§ÂàÜÈ°ûÊñπÊ≥ï (DialogView)
    private func categorizeError(_ error: Error) -> String {
        print("üîç [Error Categorization] ÈñãÂßãÂàÜÊûêÈåØË™§... (DialogView)")
        
        // 1. Ê™¢Êü•ÊòØÂê¶ÊòØÁ∂≤Ë∑ØÁõ∏ÈóúÈåØË™§
        if let urlError = error as? URLError {
            print("üîç [Error Categorization] Á∂≤Ë∑ØÈåØË™§Ôºå‰ª£Á¢º: \(urlError.code.rawValue)")
            switch urlError.code {
            case .notConnectedToInternet:
                return "Á∂≤Ë∑ØÈÄ£Á∑öÂïèÈ°åÔºöË´ãÊ™¢Êü•ÊÇ®ÁöÑÁ∂≤Ë∑ØÈÄ£Á∑ö‰∏¶ÈáçË©¶„ÄÇ"
            case .timedOut:
                return "Ë´ãÊ±ÇÈÄæÊôÇÔºö‰º∫ÊúçÂô®ÂõûÊáâÊôÇÈñìÈÅéÈï∑ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
            case .cannotFindHost:
                return "‰º∫ÊúçÂô®ÈÄ£Á∑öÂïèÈ°åÔºöÁÑ°Ê≥ïÈÄ£Êé•Âà∞ÂëΩÂêçÊúçÂãôÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
            case .networkConnectionLost:
                return "Á∂≤Ë∑ØÈÄ£Á∑ö‰∏≠Êñ∑ÔºöË´ãÊ™¢Êü•Á∂≤Ë∑ØÁãÄÊÖã‰∏¶ÈáçË©¶„ÄÇ"
            default:
                return "Á∂≤Ë∑ØÈåØË™§Ôºö\(urlError.localizedDescription)ÔºàÈåØË™§‰ª£Á¢ºÔºö\(urlError.code.rawValue)Ôºâ"
            }
        }
        
        // 2. Ê™¢Êü•ÊòØÂê¶ÊòØJSONËß£ÊûêÈåØË™§
        if let decodingError = error as? DecodingError {
            print("üîç [Error Categorization] JSONËß£ÊûêÈåØË™§")
            switch decodingError {
            case .keyNotFound(let key, _):
                return "AIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöÁº∫Â∞ëÂøÖË¶ÅÁöÑÊ¨Ñ‰Ωç '\(key.stringValue)'ÔºåË´ãÈáçË©¶„ÄÇ"
            case .typeMismatch(let type, _):
                return "AIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöË≥áÊñôÈ°ûÂûã‰∏çÂåπÈÖç (\(type))ÔºåË´ãÈáçË©¶„ÄÇ"
            case .valueNotFound(let type, _):
                return "AIÂõûÊáâË≥áÊñôÊêçÂ£ûÔºöÊâæ‰∏çÂà∞È†êÊúüÁöÑ \(type) ÂÄºÔºåË´ãÈáçË©¶„ÄÇ"
            case .dataCorrupted(_):
                return "AIÂõûÊáâË≥áÊñôÊêçÂ£ûÔºöÊî∂Âà∞ÁöÑË≥áÊñôÁÑ°Ê≥ïËß£ÊûêÔºåË´ãÈáçË©¶„ÄÇ"
            @unknown default:
                return "AIÂõûÊáâËß£ÊûêÂ§±ÊïóÔºö\(decodingError.localizedDescription)"
            }
        }
        
        // 3. Ê™¢Êü•ÊòØÂê¶ÊòØÂêçÂ≠óÁîüÊàêÁõ∏ÈóúÈåØË™§
        if let nameError = error as? NameGenerationError {
            print("üîç [Error Categorization] ÂêçÂ≠óÁîüÊàêÈåØË™§")
            switch nameError {
            case .wrongCharacterCount(let expected, let actual):
                return "ÁîüÊàêÁöÑÂêçÂ≠óÂ≠óÊï∏‰∏çÁ¨¶ÂêàË¶ÅÊ±ÇÔºöÊúüÊúõ \(expected) Â≠óÔºåÂØ¶ÈöõÁîüÊàê \(actual) Â≠ó„ÄÇË´ãÈáçË©¶„ÄÇ"
            }
        }
        
        // 4. Ê™¢Êü•ÊòØÂê¶ÊòØNSError‰∏¶Êèê‰æõÊõ¥Ë©≥Á¥∞ÁöÑË®äÊÅØ
        if let nsError = error as NSError? {
            print("üîç [Error Categorization] NSErrorÔºåÂüü: \(nsError.domain)Ôºå‰ª£Á¢º: \(nsError.code)")
            
            // SwiftOpenAI.APIError ÁâπÂÆöËôïÁêÜ
            if nsError.domain == "SwiftOpenAI.APIError" {
                switch nsError.code {
                case 1:
                    // Âü∑Ë°å API ÈáëÈë∞Ë®∫Êñ∑
                    let diagnostic = self.diagnoseAPIKeyIssue()
                    return "OpenAI APIË´ãÊ±ÇÂ§±ÊïóÔºö\(diagnostic)"
                case 2:
                    return "OpenAI APIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöÊî∂Âà∞ÁöÑË≥áÊñôÊ†ºÂºè‰∏çÊ≠£Á¢∫ÔºåË´ãÈáçË©¶„ÄÇ"
                case 3:
                    return "OpenAI APIË™çË≠âÈåØË™§ÔºöAPIÈáëÈë∞ÂèØËÉΩÂ∑≤ÈÅéÊúüÊàñÁÑ°ÊïàÔºåË´ãÊ™¢Êü•APIÈáëÈë∞Ë®≠ÂÆö„ÄÇ"
                default:
                    return "OpenAI APIÈåØË™§Ôºö\(nsError.localizedDescription)ÔºàÈåØË™§‰ª£Á¢ºÔºö\(nsError.code)Ôºâ"
                }
            }
            
            // ‰∏ÄËà¨ OpenAI API Áõ∏ÈóúÈåØË™§
            if nsError.domain.contains("OpenAI") || nsError.domain.contains("API") {
                switch nsError.code {
                case 401:
                    return "APIË™çË≠âÂ§±ÊïóÔºöË´ãÊ™¢Êü•APIÈáëÈë∞ÊòØÂê¶Ê≠£Á¢∫Ë®≠ÂÆö„ÄÇ"
                case 429:
                    return "APIË´ãÊ±ÇÈÅéÊñºÈ†ªÁπÅÔºöË´ãÁ®çÂÄôÁâáÂàªÂÜçË©¶„ÄÇ"
                case 500...599:
                    return "‰º∫ÊúçÂô®ÂÖßÈÉ®ÈåØË™§ÔºöAIÊúçÂãôÊö´ÊôÇ‰∏çÂèØÁî®ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
                default:
                    return "APIÂëºÂè´Â§±ÊïóÔºö\(nsError.localizedDescription)ÔºàÈåØË™§‰ª£Á¢ºÔºö\(nsError.code)Ôºâ"
                }
            }
            
            // ÂÖ∂‰ªñNSError
            return "Á≥ªÁµ±ÈåØË™§Ôºö\(nsError.localizedDescription)ÔºàÂüüÔºö\(nsError.domain)Ôºå‰ª£Á¢ºÔºö\(nsError.code)Ôºâ"
        }
        
        // 5. Êú™Áü•ÈåØË™§
        print("üîç [Error Categorization] Êú™Áü•ÈåØË™§È°ûÂûã: \(type(of: error))")
        return "Êú™Áü•ÈåØË™§Ôºö\(error.localizedDescription)„ÄÇË´ãÈáçË©¶ÔºåÂ¶ÇÂïèÈ°åÊåÅÁ∫åÁôºÁîüÔºåË´ãËÅØÁπ´ÂÆ¢Êúç„ÄÇ"
    }
    
    // MARK: - APIÈáëÈë∞Ë®∫Êñ∑ÊñπÊ≥ï (DialogView)
    private func diagnoseAPIKeyIssue() -> String {
        print("üîç [API Diagnosis] ÈñãÂßãË®∫Êñ∑APIÈáëÈë∞ÂïèÈ°å...")
        
        // Ê™¢Êü• API ÈáëÈë∞Ê†ºÂºè
        do {
            let apiKey = APIConfig.openAIKey
            
            // Âü∫Êú¨Ê†ºÂºèÊ™¢Êü•
            if apiKey.isEmpty {
                return "APIÈáëÈë∞ÁÇ∫Á©∫„ÄÇË´ãÂú®Config.plist‰∏≠Ë®≠ÂÆöÊúâÊïàÁöÑOpenAI APIÈáëÈë∞„ÄÇ"
            }
            
            if !apiKey.hasPrefix("sk-") {
                return "APIÈáëÈë∞Ê†ºÂºèÈåØË™§„ÄÇOpenAI APIÈáëÈë∞Êáâ‰ª•'sk-'ÈñãÈ†≠„ÄÇË´ãÊ™¢Êü•Config.plist‰∏≠ÁöÑË®≠ÂÆö„ÄÇ"
            }
            
            if apiKey.count < 50 {
                return "APIÈáëÈë∞Èï∑Â∫¶‰∏çË∂≥„ÄÇË´ãÁ¢∫Ë™çConfig.plist‰∏≠ÁöÑAPIÈáëÈë∞ÊòØÂÆåÊï¥ÁöÑ„ÄÇ"
            }
            
            // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´ÁÑ°ÊïàÂ≠óÁ¨¶
            let allowedCharacters = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "-_"))
            if apiKey.rangeOfCharacter(from: allowedCharacters.inverted) != nil {
                return "APIÈáëÈë∞ÂåÖÂê´ÁÑ°ÊïàÂ≠óÁ¨¶„ÄÇË´ãÊ™¢Êü•Config.plist‰∏≠ÊòØÂê¶ÊúâÂ§öÈ§òÁöÑÁ©∫Ê†ºÊàñÁâπÊÆäÂ≠óÁ¨¶„ÄÇ"
            }
            
            print("üîç [API Diagnosis] APIÈáëÈë∞Ê†ºÂºèÊ™¢Êü•ÈÄöÈÅé")
            return "ÂèØËÉΩÊòØÁ∂≤Ë∑ØÈÄ£Á∑öÂïèÈ°åÊàñOpenAIÊúçÂãôÊö´ÊôÇ‰∏çÂèØÁî®„ÄÇË´ãÊ™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑öÂæåÈáçË©¶„ÄÇ"
            
        } catch {
            return "ÁÑ°Ê≥ïËÆÄÂèñAPIÈáëÈë∞ÈÖçÁΩÆ„ÄÇË´ãÁ¢∫Ë™çConfig.plistÊ™îÊ°àÂ≠òÂú®‰∏îÊ†ºÂºèÊ≠£Á¢∫„ÄÇ"
        }
    }
}

// Êõ¥Êñ∞ NameGenerationResult ÁµêÊßãÈ´î
struct NameGenerationResult: Codable {
    let name: String
    let analysis: Analysis
}

struct Analysis: Codable {
    let character_meaning: String
    let literary_allusion: LiteraryAllusion
    let situational_analysis: SituationalAnalysisMap
}

struct LiteraryAllusion: Codable {
    let source: String
    let original_text: String
    let interpretation: String
    let connection: String
}

struct SituationalAnalysis: Codable {
    let analysis: String  // Âè™ÈúÄË¶ÅÂàÜÊûêÈÉ®ÂàÜ
}

// New type to represent the object structure
struct SituationalAnalysisMap: Codable {
    let one: SituationalAnalysis
    let two: SituationalAnalysis
    let three: SituationalAnalysis
    let four: SituationalAnalysis
    let five: SituationalAnalysis
    
    private enum CodingKeys: String, CodingKey {
        case one = "1"
        case two = "2"
        case three = "3"
        case four = "4"
        case five = "5"
    }
}

// MARK: - v2ÁâàÊú¨ÁöÑÁµêÊßãÈ´î (ÈÅ©Áî®ÊñºÊñ∞workflow)
struct NameGenerationResultv2: Codable {
    let name: String
    let analysis: Analysisv2
}

struct Analysisv2: Codable {
    let character_meaning: String
    let literary_allusion: LiteraryAllusion // ÈáçÁî®ÁèæÊúâÁöÑLiteraryAllusionÁµêÊßãÈ´î
    let design_focus_analysis: String
    let special_requirements_analysis: String
}

// Add this struct at the end of the file
struct Config {
    static var openAIKey: String {
        get {
            guard let filePath = Bundle.main.path(forResource: "Config", ofType: "plist") else {
                fatalError("Couldn't find file 'Config.plist'.")
            }
            
            let plist = NSDictionary(contentsOfFile: filePath)
            
            guard let value = plist?.object(forKey: "OpenAI_API_Key") as? String else {
                fatalError("Couldn't find key 'OpenAI_API_Key' in 'Config.plist'.")
            }
            
            return value
        }
    }
}

struct FavoriteNameData: Codable {
    let name: String
    let analysis: [String: String]
    let wuxing: [String]
}

struct NameAnalysisView: View {
    let name: String
    let analysis: [String: String]
    let wuxing: [String]
    let regenerateAction: () -> Void
    @Binding var selectedTab: Int  // Êñ∞Â¢ûÈÄôË°å
    let showButtons: Bool
    @State private var isFavorite: Bool = false
    @Binding var navigationPath: NavigationPath
    @State private var showSaveFavoriteAlert = false
    @State private var showRegenerateAlert  = false
    @State private var showAccountLinkingOptions = false
    @Environment(\.colorScheme) var colorScheme
    @State private var isRegenerating = false
    @AppStorage("remainingUses") private var remainingUses = 3
    @State private var showInsufficientUsesAlert = false
    @StateObject private var interstitialAd = InterstitialAdViewModel()
    @State private var hasShownReviewRequest = false
    private let usageManager = UsageManager.shared
    @AppStorage("returnHomeCount") private var returnHomeCount = 0
    @State private var showTwoFactorAlert = false
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @EnvironmentObject var authViewModel: AuthViewModel
    
    @State private var showAccountLinkingSheet = false
    @State private var isUpgrading = false
    @State private var upgradeErrorMessage: String?
    @State private var showUpgradeError = false
    // add a boolean if the buttons below is shown
     
    // Âú® NameAnalysisView ÁµêÊßãÈ´îÂÖßÊ∑ªÂä†
    private enum SelectedButton {
        case favorite
        case regenerate
    }

    @State private var selectedButton: SelectedButton = .favorite
    
    // ‰øÆÊîπÂàùÂßãÂåñÊñπÊ≥ï
    init(name: String, 
         analysis: [String: String], 
         wuxing: [String], 
         navigationPath: Binding<NavigationPath>,
         selectedTab: Binding<Int>,  // Êñ∞Â¢ûÈÄôË°å
         regenerateAction: @escaping () -> Void,
         showButtons: Bool) {
        self.name = name
        self.analysis = analysis
        self.wuxing = wuxing
        self._navigationPath = navigationPath
        self._selectedTab = selectedTab  // Êñ∞Â¢ûÈÄôË°å
        self.regenerateAction = regenerateAction
        self.showButtons = showButtons
    }
    
    var body: some View {
        mainScrollView
            .background(Color.customBackground)
            .navigationBarTitle("ÂêçÂ≠óÂàÜÊûê", displayMode: .inline)
            .onAppear(perform: checkFavoriteStatus)
            .overlay(loadingOverlay)
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
    
    // Break down into smaller components
    private var mainScrollView: some View {
        ScrollView {
            VStack(spacing: 20) {
                nameCard
                    .padding(.horizontal)
                
                analysisSection
                    .padding(.horizontal)
                
                if showButtons {  // Changed from _showButtons to showButtons
                    actionButtons
                        .padding(.horizontal)
                        .padding(.bottom, GADAdSizeBanner.size.height + 20)
                }
            }
        }
        .overlay(
            Group {
                if showUpgradeError {
                    CustomAlertView(
                        title: "Á∂ÅÂÆöÂ§±Êïó",
                        message: upgradeErrorMessage ?? "",
                        isPresented: $showUpgradeError
                    )
                }
            }
        )
    }



        private var analysisSection: some View {
        VStack(spacing: 20) {
            characterAnalysisCard
                .frame(maxWidth: .infinity)
            literaryAllusionCard
                .frame(maxWidth: .infinity)
            designFocusAnalysisCard
                .frame(maxWidth: .infinity)
            specialRequirementsAnalysisCard
                .frame(maxWidth: .infinity)
        }
    }

    private var characterAnalysisCard: some View {
        AnalysisCard(title: "Â≠óÁæ©") {
            analysisContent(for: "Â≠óÁæ©ÂàÜÊûê")
                .frame(maxWidth: .infinity)
        }
    }

    private var literaryAllusionCard: some View {
        AnalysisCard(title: "ÂÖ∏ÊïÖ") {
            analysisContent(for: "ÂÖ∏ÊïÖÂàÜÊûê")
                .frame(maxWidth: .infinity)
        }
    }

    private var designFocusAnalysisCard: some View {
        AnalysisCard(title: "Ë®≠Ë®à‰∏ªËª∏") {
            analysisContent(for: "Ë®≠Ë®à‰∏ªËª∏ÂàÜÊûê")
                .frame(maxWidth: .infinity)
        }
    }
    
    private var specialRequirementsAnalysisCard: some View {
        AnalysisCard(title: "ÁâπÊÆäÈúÄÊ±Ç") {
            analysisContent(for: "ÁâπÊÆäÈúÄÊ±ÇÂàÜÊûê")
                .frame(maxWidth: .infinity)
        }
    }

    private func analysisContent(for key: String) -> some View {
        Group {
            if let analysisContent = analysis[key] {
                let lines = analysisContent.split(separator: "\n")
                ForEach(lines, id: \.self) { line in
                    Text(line)
                        .font(.custom("NotoSansTC-Regular", size: 20))
                        .foregroundColor(.customText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
            }
        }
    }



    private var loadingOverlay: some View {
        Group {
            if isRegenerating {
                VStack(spacing: 15) {
                    ProgressView("ÁîüÊàêÂêçÂ≠ó‰∏≠ÔºàÁ¥Ñ30ÁßíÔºâ...")
                        .scaleEffect(1.5)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.black.opacity(0.3))
            }
        }
    }

    private var nameCard: some View {
        VStack(spacing: 10) {
            Text("ÁÇ∫ÊÇ®ÁîüÊàêÁöÑÂêçÂ≠ó")
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customText)
            
            HStack(spacing: 20) {
                let nameCharacters = name.map { String($0) }
                
                // Display each character with its wuxing element
                ForEach(0..<nameCharacters.count, id: \.self) { index in
                    VStack {
                        Text(nameCharacters[index])
                            .font(.custom("NotoSansTC-Black", size: calculateFontSize(for: nameCharacters.count)))
                            .foregroundColor(.customText)
                        
                        // Add wuxing element icon and text
                        if index < wuxing.count {
                            HStack(spacing: 5) {
                                Image(systemName: wuxingIcon(for: wuxing[index]))
                                    .foregroundColor(wuxingColor(for: wuxing[index]))
                            }
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 15)
                            .fill(Color.customSecondary)
                            .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
                    )
                }
            }
        }
    }
    
    private func AnalysisCard<Content: View>(title: String, @ViewBuilder content: @escaping () -> Content) -> some View {
        VStack(alignment: .leading, spacing: 15) {
            Text(title)
                .font(.custom("NotoSansTC-Black", size: 22))
                .foregroundColor(.customText)
            
            content()
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 15)
                .fill(Color.customSecondary)
                .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
        )
    }
    
    private var actionButtons: some View {
        VStack(spacing: 15) {
            Button(action: {
                if Auth.auth().currentUser?.isAnonymous == true {
                    selectedButton = .favorite
                    showAccountLinkingSheet = true
                } else {
                    toggleFavorite()
                }
            }) {
                HStack {
                    Image(systemName: isFavorite ? "heart.fill" : "heart")
                    Text(isFavorite ? "Â∑≤Êî∂Ëóè" : "Êî∂Ëóè")
                }
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isFavorite ? Color.gray : Color.customAccent)
                .cornerRadius(10)
            }

            
            Button(action: {
                if Auth.auth().currentUser?.isAnonymous == true {
                    selectedButton = .regenerate
                    showAccountLinkingSheet = true
                } else {
                    if remainingUses > 0 {
                        regenerateName()
                    } else {
                        showInsufficientUsesAlert = true
                    }
                }
            }) {
                Text("ÈáçÊñ∞ÁîüÊàê")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(.customAccent)
                    .cornerRadius(10)
            }
            .alert(isPresented: $showInsufficientUsesAlert) {
                Alert(
                    title: Text("‰ΩøÁî®Ê¨°Êï∏‰∏çË∂≥"),
                    message: Text("ÂæàÊä±Ê≠âÔºåÊÇ®ÁöÑÂÖçË≤ª‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆå„ÄÇË´ãËßÄÁúãÂª£ÂëäÁç≤ÂèñÊõ¥Â§öÊ¨°Êï∏„ÄÇ"),
                    dismissButton: .default(Text("Á¢∫ÂÆö"))
                )
            }
            
            Button(action: {
                returnHomeCount += 1
                if returnHomeCount >= 3 {
                    interstitialAd.showAd()
                    returnHomeCount = 0  // ÈáçÁΩÆË®àÊï∏
                }
                
                // Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÂÆåÊàêÈõôÈáçÈ©óË≠â
                 if let user = Auth.auth().currentUser {
                    if user.isAnonymous {
                        // ÂåøÂêçÁî®Êà∂ÔºöË®≠ÁΩÆÊ®ôË®ò‰∏¶ÂàáÊèõÂà∞Ë®≠ÂÆöÈ†Å
                        UserDefaults.standard.set(true, forKey: "shouldShowAccountLinkingAlert")
                        navigationPath.removeLast(navigationPath.count)
                        selectedTab = 2  // ÂàáÊèõÂà∞Ë®≠ÂÆöÈ†Å
                    } else if !user.providerData.contains(where: { $0.providerID == "phone" }) {
                        // Â∑≤ÁôªÂÖ•‰ΩÜÊú™Á∂ÅÂÆöÊâãÊ©üÔºöË®≠ÁΩÆÈõôÈáçÈ©óË≠âÊèêÁ§∫
                        UserDefaults.standard.set(true, forKey: "shouldShowTwoFactorAlert")
                        navigationPath.removeLast(navigationPath.count)
                    } else {
                        // Ê≠£Â∏∏Áî®Êà∂ÔºöÁõ¥Êé•ËøîÂõûÈ¶ñÈ†Å
                        navigationPath.removeLast(navigationPath.count)
                    }
                }
            }) {
                Text("ËøîÂõûÈ¶ñÈ†Å")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.customAccent)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.customSecondary)
                    .cornerRadius(10)
            }
           
        }
        .sheet(isPresented: $showAccountLinkingSheet) {
            AccountLinkingSheet(
                isPresented: $showAccountLinkingSheet,
                isUpgrading: $isUpgrading,
                onGoogleLink: upgradeWithGoogle,
                onAppleLink: upgradeWithApple,
                message: selectedButton == .favorite ? "Á∂ÅÂÆöÂ∏≥Ëôü‰ª•‰øùÂ≠òÊÇ®ÂñúÊ≠°ÁöÑÂêçÂ≠ó" : "Á∂ÅÂÆöÂ∏≥Ëôü‰ª•Âø´ÈÄüÁî®Áõ∏ÂêåÊ¢ù‰ª∂ÁîüÊàêÊõ¥Â§öÂêçÂ≠ó"
            )
        }
    }
    
    private func toggleFavorite() {
        isFavorite.toggle()
        if isFavorite {
            saveFavorite()
        } else {
            removeFavorite()
        }
    }
    
    private func saveFavorite() {
        let favoriteData = FavoriteNameData(
            name: name,
            analysis: analysis,
            wuxing: wuxing
        )
        
        var favorites = (UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap { try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) ?? []
        favorites.append(favoriteData)
        
        if let encodedData = try? JSONEncoder().encode(favorites) {
            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
        }

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await usageManager.updateCloudData()
        }
    }
    
    private func removeFavorite() {
        guard var favorites = UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap({ try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) else {
            return
        }
        
        favorites.removeAll { $0.name == name }
        
        if let encodedData = try? JSONEncoder().encode(favorites) {
            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
        }

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
    Task {
            try? await usageManager.updateCloudData()
        }
    }
    
    private func checkFavoriteStatus() {
        guard let favorites = UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap({ try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) else {
            return
        }
        
        isFavorite = favorites.contains { $0.name == name }
    }

    private func wuxingIcon(for element: String) -> String {
        switch element {
        case "Èáë": return "circle.fill"
        case "Êú®": return "leaf.fill"
        case "Ê∞¥": return "drop.fill"
        case "ÁÅ´": return "flame.fill"
        case "Âúü": return "square.fill"
        default: return "questionmark.circle.fill"
        }
    }

    private func wuxingColor(for element: String) -> Color {
        switch element {
        case "Èáë": return .yellow
        case "Êú®": return .green
        case "Ê∞¥": return .blue
        case "ÁÅ´": return .red
        case "Âúü": return .orange
        default: return .gray
        }
    }

    private func regenerateName() {
        isRegenerating = true
        regenerateAction()
    }

    private func requestReview() {
        guard let scene = UIApplication.shared.connectedScenes.first(where: { $0.activationState == .foregroundActive }) as? UIWindowScene else { return }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            SKStoreReviewController.requestReview(in: scene)
        }
    }

    // Ê∑ªÂä†Á∂ÅÂÆöÊñπÊ≥ï
    private func upgradeWithGoogle() {
        self.isUpgrading = true
        
        guard let clientID = FirebaseApp.app()?.options.clientID else { 
            self.isUpgrading = false
            self.upgradeErrorMessage = "ÁÑ°Ê≥ïÁç≤Âèñ Google ÁôªÂÖ•Ë®≠ÂÆö"
            self.showAccountLinkingSheet = false
            self.showUpgradeError = true
            return 
        }
        
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.keyWindow ?? windowScene.windows.first,
              let rootViewController = window.rootViewController else {
            self.isUpgrading = false
            self.upgradeErrorMessage = "ÁÑ°Ê≥ïÂàùÂßãÂåñ Google ÁôªÂÖ•"
            self.showAccountLinkingSheet = false
            self.showUpgradeError = true
            return
        }
        
        GIDSignIn.sharedInstance.signIn(withPresenting: rootViewController) { result, error in                
            if let error = error {
                self.upgradeErrorMessage = "Google ÁôªÂÖ•Â§±ÊïóÔºö\(error.localizedDescription)"
                self.showUpgradeError = true
                self.showAccountLinkingSheet = false
                self.isUpgrading = false
                return
            }
            
            guard let user = result?.user,
                    let idToken = user.idToken?.tokenString else {
                self.upgradeErrorMessage = "ÁÑ°Ê≥ïÁç≤Âèñ Google Â∏≥ËôüË≥áË®ä"
                self.showUpgradeError = true
                self.showAccountLinkingSheet = false
                self.isUpgrading = false
                return
            }
            
            let credential = GoogleAuthProvider.credential(
                withIDToken: idToken,
                accessToken: user.accessToken.tokenString
            )
            
            // ÈÄ£ÁµêÂ∏≥Ëôü
            Auth.auth().currentUser?.link(with: credential) { [self] authResult, error in
                if let error = error as NSError? {
                    // ËôïÁêÜÁâπÂÆöÈåØË™§È°ûÂûã
                    let errorMessage: String
                    switch error.code {
                    case AuthErrorCode.emailAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.credentialAlreadyInUse.rawValue:
                        errorMessage = "Ê≠§ Google Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                    case AuthErrorCode.providerAlreadyLinked.rawValue:
                        errorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Google Â∏≥Ëôü"
                    default:
                        errorMessage = error.localizedDescription
                    }
                    print("‚ùå Á∂ÅÂÆöÂ§±Êïó: \(errorMessage)")
                    DispatchQueue.main.async {
                        self.isUpgrading = false
                        self.upgradeErrorMessage = errorMessage
                        self.showAccountLinkingSheet = false
                        self.showUpgradeError = true
                    }
                    return
                } else {
                    // ÊàêÂäüÈÄ£Áµê
                    self.showAccountLinkingSheet = false
                    
                    // Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñô
                    let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest()
                    changeRequest?.displayName = user.profile?.name
                    changeRequest?.photoURL = user.profile?.imageURL(withDimension: 200)
                    
                    changeRequest?.commitChanges { error in
                        if let error = error {
                            print("‚ùå Êõ¥Êñ∞Áî®Êà∂Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
                        } else {
                            print("‚úÖ Áî®Êà∂Ë≥áÊñôÊõ¥Êñ∞ÊàêÂäü")
                        }
                        
                        print("‚úÖ Â∏≥ËôüÂçáÁ¥öÊàêÂäü")
                        self.isUpgrading = false
                        // Ëß∏Áôº UI Êõ¥Êñ∞
                        self.handleSuccessfulUpgrade()
                    }
                }
            }
        }
    }
    
    private func upgradeWithApple() {
        self.isUpgrading = true
        appleSignInCoordinator = AppleSignInCoordinator()
        
        appleSignInCoordinator?.startSignInWithAppleFlow { [self] result in
            defer {
                DispatchQueue.main.async {
                    self.isUpgrading = false
                    self.showAccountLinkingSheet = false
                }
            }
                
            switch result {
            case .success(_):
                self.handleSuccessfulUpgrade()
                
            case .failure(let error):
                DispatchQueue.main.async {
                    if let authError = error as? NSError {
                        // Firebase Auth errors
                        switch authError.code {
                        case AuthErrorCode.emailAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Ë¢´‰ΩøÁî®ÔºåË´ã‰ΩøÁî®ÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.credentialAlreadyInUse.rawValue:
                            upgradeErrorMessage = "Ê≠§ Apple Â∏≥ËôüÂ∑≤Á∂ÅÂÆöÂÖ∂‰ªñÂ∏≥Ëôü"
                        case AuthErrorCode.providerAlreadyLinked.rawValue:
                            upgradeErrorMessage = "ÊÇ®Â∑≤Á∂ÅÂÆö Apple Â∏≥Ëôü"
                        case AuthErrorCode.invalidCredential.rawValue:
                            upgradeErrorMessage = "ÁÑ°ÊïàÁöÑÊÜëË≠â"
                        case AuthErrorCode.operationNotAllowed.rawValue:
                            upgradeErrorMessage = "Ê≠§Êìç‰Ωú‰∏çË¢´ÂÖÅË®±"
                        case AuthErrorCode.tooManyRequests.rawValue:
                            upgradeErrorMessage = "Ë´ãÊ±ÇÊ¨°Êï∏ÈÅéÂ§öÔºåË´ãÁ®çÂæåÂÜçË©¶"
                        case AuthErrorCode.networkError.rawValue:
                            upgradeErrorMessage = "Á∂≤Ë∑ØÈÄ£Á∑öÈåØË™§ÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÁãÄÊÖã"
                        case AuthErrorCode.userDisabled.rawValue:
                            upgradeErrorMessage = "Ê≠§Â∏≥ËôüÂ∑≤Ë¢´ÂÅúÁî®"
                        case AuthErrorCode.requiresRecentLogin.rawValue:
                            upgradeErrorMessage = "ÈúÄË¶ÅÈáçÊñ∞ÁôªÂÖ•ÊâçËÉΩÂü∑Ë°åÊ≠§Êìç‰Ωú"
                        default:
                            // Â¶ÇÊûúÊòØ Apple Sign In ÁöÑÈåØË™§
                            if let asError = error as? ASAuthorizationError {
                                switch asError.code {
                                case .canceled:
                                    upgradeErrorMessage = "‰ΩøÁî®ËÄÖÂèñÊ∂àÁ∂ÅÂÆö"
                                case .invalidResponse:
                                    upgradeErrorMessage = "‰º∫ÊúçÂô®ÂõûÊáâÁÑ°Êïà"
                                case .notHandled:
                                    upgradeErrorMessage = "ÁÑ°Ê≥ïËôïÁêÜÊ≠§Ë´ãÊ±Ç"
                                case .failed:
                                    upgradeErrorMessage = "Á∂ÅÂÆöÂ§±Êïó"
                                default:
                                    upgradeErrorMessage = error.localizedDescription
                                }
                            } else {
                                upgradeErrorMessage = error.localizedDescription
                            }
                        }
                        self.showUpgradeError = true
                    }
                }
            }
        }
    }
    
    private func linkAccount(with credential: AuthCredential) {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå ÁÑ°Ê≥ïÈÄ£ÁµêÂ∏≥ËôüÔºöÊú™ÊâæÂà∞Áï∂ÂâçÁî®Êà∂")
            return
        }
        
        user.link(with: credential) { authResult, error in
            DispatchQueue.main.async {
                self.isUpgrading = false
                
                if let error = error {
                    self.upgradeErrorMessage = error.localizedDescription
                    self.showUpgradeError = true
                    return
                }
                
                self.showAccountLinkingOptions = false
            }
        }
    }

    private func handleSuccessfulUpgrade() {
        showAccountLinkingSheet = false
        
        // ËΩâÁßªÂåøÂêçÁî®Êà∂ÁöÑ‰ΩøÁî®Ê¨°Êï∏
        UsageManager.shared.transferAnonymousUses()
        
        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await UsageManager.shared.updateCloudData()
        }
    }
}

struct CustomAlertView: View {
    let title: String
    let message: String
    @Binding var isPresented: Bool
     
    var body: some View {
        ZStack {
            Color.black.opacity(0.3)
                .edgesIgnoringSafeArea(.all)
                .onTapGesture {
                    withAnimation {
                        isPresented = false
                    }
                }
            
            VStack(spacing: 20) {
                Text(title)
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.customText)
                
                Text(message)
                    .font(.custom("NotoSansTC-Regular", size: 14))
                    .foregroundColor(.customText)
                    .multilineTextAlignment(.center)
                
                Button("Á¢∫ÂÆö") {
                    withAnimation {
                        isPresented = false
                    }
                }
                .buttonStyle(AlertButtonStyle(isPrimary: true))
            }
            .padding()
            .background(Color.customBackground)
            .cornerRadius(15)
            .shadow(radius: 10)
            .padding(30)
        }
    }
}

struct AlertButtonStyle: ButtonStyle {
    let isPrimary: Bool
    
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.custom("NotoSansTC-Regular", size: 16))
            .foregroundColor(isPrimary ? .white : .customAccent)
            .padding(.horizontal, 30)
            .padding(.vertical, 10)
            .background(isPrimary ? Color.customAccent : Color.clear)
            .cornerRadius(8)
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(Color.customAccent, lineWidth: isPrimary ? 0 : 1)
            )
    }
}

// Êñ∞Â¢û AccountLinkingSheet Ë¶ñÂúñ
struct AccountLinkingSheet: View {
    @Binding var isPresented: Bool
    @Binding var isUpgrading: Bool
    let onGoogleLink: () -> Void
    let onAppleLink: () -> Void
    let message: String  // Êñ∞Â¢ûÈÄôË°å
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text("Á∂ÅÂÆöÂ∏≥Ëôü")
                    .font(.custom("NotoSansTC-Black", size: 24))
                    .foregroundColor(.customText)
                    .padding(.top)
                
                Text(message)  // ‰ΩøÁî®ÂÇ≥ÂÖ•ÁöÑË®äÊÅØ
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                
                Button(action: onGoogleLink) {
                    HStack {
                        Image("GoogleLogo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 20, height: 20)
                        Text("‰ΩøÁî® Google Â∏≥ËôüÁ∂ÅÂÆö")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(Color.customAccent, lineWidth: 1)
                    )
                }
                .foregroundColor(.customText)
                .disabled(isUpgrading)
                
                Button(action: onAppleLink) {
                    HStack {
                        Image(systemName: "apple.logo")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 20, height: 20)
                        Text("‰ΩøÁî® Apple Â∏≥ËôüÁ∂ÅÂÆö")
                            .font(.custom("NotoSansTC-Regular", size: 16))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(25)
                    .overlay(
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(Color.customAccent, lineWidth: 1)
                    )
                }
                .foregroundColor(.customText)
                .disabled(isUpgrading)
                
                if isUpgrading {
                    ProgressView()
                        .scaleEffect(1.5)
                        .padding()
                }
                
                Spacer()
            }
            .padding()
            .navigationBarItems(trailing: Button("ÂèñÊ∂à") {
                isPresented = false
            })
            .background(Color.customBackground)
        }
    }
}

struct FavoritesListView: View {
    @State private var favorites: [FavoriteNameData] = []
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        ZStack {
            Color.customBackground
                .edgesIgnoringSafeArea(.all)
            
            if favorites.isEmpty {
                Text("ÁõÆÂâçÊ≤íÊúâÊî∂ËóèÁöÑÂêçÂ≠ó")
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(.customText)
            } else {
                List {
                    ForEach(favorites, id: \.name) { favorite in
                        NavigationLink(destination: NameAnalysisView(
                            name: favorite.name,
                            analysis: favorite.analysis,
                            wuxing: favorite.wuxing,
                            navigationPath: .constant(NavigationPath()),
                            selectedTab: .constant(0),
                            regenerateAction: {},
                            showButtons: false  // Changed from State<Bool> to Bool
                        )) {
                            VStack(alignment: .leading) {
                                HStack {
                                    Text(favorite.name)
                                        .font(.custom("NotoSansTC-Black", size: 24))
                                        .foregroundColor(.customText)
                                    
                                    Spacer()
                                    
                                    HStack(spacing: 5) {
                                        ForEach(favorite.wuxing, id: \.self) { element in
                                            Image(systemName: wuxingIcon(for: element))
                                                .foregroundColor(wuxingColor(for: element))
                                        }
                                    }
                                }
                                Text(favorite.analysis.map { "\($0.key): \($0.value)" }.joined(separator: "\n"))
                                    .font(.custom("NotoSansTC-Regular", size: 14))
                                    .foregroundColor(.customText)
                                    .lineLimit(2)
                            }
                            .padding(.vertical, 8)
                        }
                    }
                    .onDelete(perform: removeFavorite)
                }
                .listStyle(PlainListStyle())
                // Ê∑ªÂä†Â∫ïÈÉ®ÈñìË∑ùÔºå‰ΩøÂÖ∂‰∏çË¢´Âª£ÂëäÈÅÆÊìã
                .padding(.bottom, GADAdSizeBanner.size.height + 45)
            }
        }
        .onAppear(perform: loadFavorites)
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
    
    private func loadFavorites() {
        if let data = UserDefaults.standard.data(forKey: "FavoriteNames"),
           let decodedFavorites = try? JSONDecoder().decode([FavoriteNameData].self, from: data) {
            favorites = decodedFavorites
        }
    }
    
    private func removeFavorite(at offsets: IndexSet) {
        favorites.remove(atOffsets: offsets)
        if let encodedData = try? JSONEncoder().encode(favorites) {
            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
        }
    }

    private func wuxingIcon(for element: String) -> String {
        switch element {
        case "Èáë": return "circle.fill"
        case "Êú®": return "leaf.fill"
        case "Ê∞¥": return "drop.fill"
        case "ÁÅ´": return "flame.fill"
        case "Âúü": return "square.fill"
        default: return "questionmark.circle.fill"
        }
    }

    private func wuxingColor(for element: String) -> Color {
        switch element {
        case "Èáë": return .yellow
        case "Êú®": return .green
        case "Ê∞¥": return .blue
        case "ÁÅ´": return .red
        case "Âúü": return .orange
        default: return .gray
        }
    }
}


// SituationalQuestionView Â∑≤Ë¢´ÁßªÈô§ÔºåÂõ†ÁÇ∫Êñ∞workflow‰∏çÂÜç‰ΩøÁî®ÊÉÖÂ¢ÉÂàÜÊûê

// Add this extension for custom corner radius
extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(roundedRect: rect, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        return Path(path.cgPath)
    }
}

// Add this struct for the triangle shape
struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.closeSubpath()
        return path
    }
}

// Add this custom toggle style
struct CustomToggleStyle: ToggleStyle {
    var onColor: Color
    
    func makeBody(configuration: Configuration) -> some View {
        HStack {
            configuration.label
            Spacer()
            Rectangle()
                .foregroundColor(configuration.isOn ? onColor : Color.gray.opacity(0.3))
                .frame(width: 51, height: 31, alignment: .center)
                .overlay(
                    Circle()
                        .foregroundColor(.white)
                        .padding(.all, 3)
                        .offset(x: configuration.isOn ? 11 : -11, y: 0)
                        .animation(.linear(duration: 0.1), value: configuration.isOn)
                )
                .cornerRadius(20)
                .onTapGesture { configuration.isOn.toggle() }
        }
    }
}
// Â∞ÜCharacterÊâ©Â±ïÁßªÂà∞Êñá‰ª∂ÁöÑÂÖ®Â±ÄËåÉÂõ¥ÂÜÖ
extension Character {
    var isChineseCharacter: Bool {
        return String(self).range(of: "\\p{Han}", options: .regularExpression) != nil
    }
}

@MainActor
class RewardedViewModel: NSObject, ObservableObject, GADFullScreenContentDelegate {
    private let usageManager = UsageManager.shared
    private var rewardedAd: GADRewardedAd?
    @Published var isAdLoaded = false
    @Published var remainingCooldown: Int = 0
    private var isLoading = false
    private var lastLoadTime: Date?
    private let minimumLoadInterval: TimeInterval = 300
    private var cooldownTimer: Timer?
    private let lastAdTimestampKey = "LastRewardedAdTimestamp"
    private let cooldownDuration: TimeInterval = 300 // 5ÂàÜÈêòÂÜ∑ÂçªÊôÇÈñì
    
    override init() {
        super.init()
        Task { @MainActor in
            preloadNextAd()
            updateCooldownStatus() // ÂàùÂßãÂåñÊôÇÊõ¥Êñ∞ÁãÄÊÖã
        }
    }
    
    private func canLoadAd() -> Bool {
        let lastTimestamp = UserDefaults.standard.double(forKey: lastAdTimestampKey)
        let timeSinceLastAd = Date().timeIntervalSince1970 - lastTimestamp
        return timeSinceLastAd >= cooldownDuration
    }
    
    private func updateCooldownStatus() {
        let lastTimestamp = UserDefaults.standard.double(forKey: lastAdTimestampKey)
        let timeSinceLastAd = Date().timeIntervalSince1970 - lastTimestamp
        
        if timeSinceLastAd < cooldownDuration {
            remainingCooldown = Int(cooldownDuration - timeSinceLastAd)
            startCooldownTimer()
        } else {
            remainingCooldown = 0
            preloadNextAd()
        }
    }
    
    private func startCooldownTimer() {
        cooldownTimer?.invalidate()
        
        let timer = Timer(timeInterval: 1.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                guard let self = self else { return }
                
                let lastTimestamp = UserDefaults.standard.double(forKey: self.lastAdTimestampKey)
                let timeSinceLastAd = Date().timeIntervalSince1970 - lastTimestamp
                
                if timeSinceLastAd < self.cooldownDuration {
                    self.remainingCooldown = Int(self.cooldownDuration - timeSinceLastAd)
                } else {
                    self.remainingCooldown = 0
                    self.cooldownTimer?.invalidate()
                    self.cooldownTimer = nil
                    self.preloadNextAd()
                }
            }
        }
        
        RunLoop.main.add(timer, forMode: .common)
        cooldownTimer = timer
    }
    
    private func preloadNextAd() {
        guard !isLoading else {
            print("‚è≥ [AdLoad] Ê≠£Âú®ËºâÂÖ•‰∏≠ÔºåË∑≥ÈÅé")
            return 
        }
        guard canLoadAd() else {
            print("‚è≥ [AdLoad] Êú™ÈÅîËºâÂÖ•ÈñìÈöîÔºåÈñãÂßãË®àÊôÇ")
            startCooldownTimer()
            return
        }
        
        isLoading = true
        
        print("üì± [AdLoad] ÈñãÂßãËºâÂÖ•Âª£Âëä")
        Task {
            do {
                rewardedAd = try await GADRewardedAd.load(
                    withAdUnitID: "ca-app-pub-3940256099942544/1712485313",
                    // withAdUnitID: "ca-app-pub-3469743877050320/4233450598",
                    request: GADRequest())
                rewardedAd?.fullScreenContentDelegate = self
                
                await MainActor.run {
                    isAdLoaded = true
                    isLoading = false
                    lastLoadTime = Date()
                    print("‚úÖ [AdLoad] Âª£ÂëäËºâÂÖ•ÊàêÂäü")
                }
            } catch {
                await MainActor.run {
                    isAdLoaded = false
                    isLoading = false
                    print("‚ùå [AdLoad] Âª£ÂëäËºâÂÖ•Â§±Êïó: \(error.localizedDescription)")
                }
                
                try? await Task.sleep(nanoseconds: 3 * 1_000_000_000)
                if canLoadAd() {
                    await MainActor.run {
                        self.preloadNextAd()
                    }
                }
            }
        }
    }
    
    func showAd() {
        guard let rewardedAd = rewardedAd else {
            if canLoadAd() {
                preloadNextAd()
            }
            return
        }
        
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.keyWindow ?? windowScene.windows.first,
           let rootViewController = window.rootViewController {
            rewardedAd.present(fromRootViewController: rootViewController) { [weak self] in
                self?.usageManager.remainingUses += 3
                
                // Êõ¥Êñ∞ÊúÄÂæåËßÄÁúãÂª£ÂëäÁöÑÊôÇÈñìÊà≥Ë®ò
                UserDefaults.standard.set(Date().timeIntervalSince1970, forKey: self?.lastAdTimestampKey ?? "")
                
                Task {
                    try? await self?.usageManager.updateCloudData()
                }
            }
        }
    }
    
    // MARK: - GADFullScreenContentDelegate
    
    nonisolated func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        Task { @MainActor in
            isAdLoaded = false
            updateCooldownStatus() // Âª£ÂëäÈóúÈñâÊôÇÊõ¥Êñ∞ÁãÄÊÖã
        }
    }
    
    nonisolated func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        print("‚ùå [AdShow] Âª£ÂëäÂ±ïÁ§∫Â§±Êïó: \(error.localizedDescription)")
        Task { @MainActor in
            isAdLoaded = false
            if canLoadAd() {
                preloadNextAd()
            }
        }
    }
    
    deinit {
        cooldownTimer?.invalidate()
    }
}

class UsageManager: ObservableObject {
    static let shared = UsageManager()
    @Published var remainingUses: Int = 0
    private let db = Firestore.firestore()
    
    // Êñ∞Â¢û UserDefaults key
    private let anonymousUsesKey = "anonymousRemainingUses"
    
    // ÂàùÂßãÂåñÊôÇË®≠ÂÆöÂåøÂêçÁî®Êà∂ÁöÑÂàùÂßã‰ΩøÁî®Ê¨°Êï∏
    private func initializeAnonymousUses() {
        if UserDefaults.standard.object(forKey: anonymousUsesKey) == nil {
            UserDefaults.standard.set(3, forKey: anonymousUsesKey)
        }
    }
    
    // ‰øÆÊîπÂêåÊ≠•Ë≥áÊñôÊñπÊ≥ï
    func syncUserData() async throws {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå Êú™ÁôªÂÖ•ÔºåÁÑ°Ê≥ïÂêåÊ≠•Ë≥áÊñô")
            return
        }
        
        // Â¶ÇÊûúÊòØÂåøÂêçÁî®Êà∂Ôºå‰ΩøÁî®Êú¨Âú∞ÂÑ≤Â≠òÁöÑÊ¨°Êï∏
        if user.isAnonymous {
            initializeAnonymousUses()
            await MainActor.run {
                self.remainingUses = UserDefaults.standard.integer(forKey: anonymousUsesKey)
            }
            return
        }
        
        // ÈùûÂåøÂêçÁî®Êà∂ÔºåÂæû Firestore ËÆÄÂèñË≥áÊñô
        print("üîÑ ÈñãÂßãÂêåÊ≠•Áî®Êà∂Ë≥áÊñô")
        let userRef = db.collection("users").document(user.uid)
        
        do {
            let document = try await userRef.getDocument()
            
            if document.exists {
                print("‚úÖ ÊâæÂà∞ÁèæÊúâÁî®Êà∂Ë≥áÊñô")
                if let userData = try? document.data(as: UserData.self) {
                    await MainActor.run {
                        self.remainingUses = userData.remainingUses
                        if let encodedData = try? JSONEncoder().encode(userData.favorites) {
                            UserDefaults.standard.set(encodedData, forKey: "FavoriteNames")
                        }
                    }
                }
            } else {
                print("üìù ÂâµÂª∫Êñ∞Áî®Êà∂Ë≥áÊñô")
                let newUserData = UserData.createDefault()
                try await userRef.setData(from: newUserData)
                
                await MainActor.run {
                    self.remainingUses = newUserData.remainingUses
                }
            }
        } catch {
            print("‚ùå ÂêåÊ≠•Ë≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
            throw error
        }
    }
    
    // ‰øÆÊîπÊõ¥Êñ∞Èõ≤Á´ØË≥áÊñôÊñπÊ≥ï
    func updateCloudData() async throws {
        guard let user = Auth.auth().currentUser else {
            print("‚ùå Êú™ÁôªÂÖ•ÔºåÁÑ°Ê≥ïÊõ¥Êñ∞Ë≥áÊñô")
            return
        }
        
        // Â¶ÇÊûúÊòØÂåøÂêçÁî®Êà∂ÔºåÂè™Êõ¥Êñ∞Êú¨Âú∞ÂÑ≤Â≠ò
        if user.isAnonymous {
            UserDefaults.standard.set(remainingUses, forKey: anonymousUsesKey)
            return
        }
        
        print("üîÑ ÈñãÂßãÊõ¥Êñ∞Èõ≤Á´ØË≥áÊñô")
        
        let favorites = (UserDefaults.standard.data(forKey: "FavoriteNames")
            .flatMap { try? JSONDecoder().decode([FavoriteNameData].self, from: $0) }) ?? []
        
        let userData = UserData(
            remainingUses: remainingUses,
            favorites: favorites,
            lastSyncTime: Date()
        )
        
        do {
            try await db.collection("users").document(user.uid).setData(from: userData, merge: true)
            print("‚úÖ Èõ≤Á´ØË≥áÊñôÊõ¥Êñ∞ÊàêÂäü")
        } catch {
            print("‚ùå Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
            throw error
        }
    }
    
    // Êñ∞Â¢ûÊñπÊ≥ïÔºöËôïÁêÜÂ∏≥ËôüÁ∂ÅÂÆöÊôÇÁöÑ‰ΩøÁî®Ê¨°Êï∏ËΩâÁßª
    func transferAnonymousUses() {
        let anonymousUses = UserDefaults.standard.integer(forKey: anonymousUsesKey)
        remainingUses = anonymousUses
        // Ê∏ÖÈô§ÂåøÂêçÁî®Êà∂ÁöÑ‰ΩøÁî®Ê¨°Êï∏
        UserDefaults.standard.removeObject(forKey: anonymousUsesKey)
    }
}

// Add this new TabButton view
struct TabButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
        var body: some View {
        Button(action: action) {
            Text(title)
                .font(.custom("NotoSansTC-Black", size: 16))
                .foregroundColor(isSelected ? .white : .customText)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(isSelected ? Color.customAccent : Color.clear)
        }
        .cornerRadius(25)
    }
}

// Add new InterstitialAdViewModel class
class InterstitialAdViewModel: NSObject, ObservableObject, GADFullScreenContentDelegate {
    private var interstitialAd: GADInterstitialAd?
    private var isLoading = false
    
    override init() {
        super.init()
        loadAd()
    }
    
    private func loadAd() {
        guard !isLoading else { return }
        isLoading = true
        
        print("üì± [InterstitialAd] ÈñãÂßãËºâÂÖ•Âª£Âëä")
        Task {
            do {
                interstitialAd = try await GADInterstitialAd.load(
                    withAdUnitID: "ca-app-pub-3940256099942544/4411468910",
                    // withAdUnitID: "ca-app-pub-3469743877050320/9105399676",
                    request: GADRequest())
                interstitialAd?.fullScreenContentDelegate = self
                
                await MainActor.run {
                    isLoading = false
                    print("‚úÖ [InterstitialAd] Âª£ÂëäËºâÂÖ•ÊàêÂäü")
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    print("‚ùå [InterstitialAd] Âª£ÂëäËºâÂÖ•Â§±Êïó: \(error.localizedDescription)")
                }
                
                // Â¶ÇÊûúËºâÂÖ•Â§±ÊïóÔºåÁ≠âÂæÖÂæåÈáçË©¶
                try? await Task.sleep(nanoseconds: 3 * 1_000_000_000)
                loadAd()
            }
        }
    }
    
    func showAd() {
        guard let interstitialAd = interstitialAd else {
            print("‚ùå [InterstitialAd] Âª£ÂëäÊú™Ê∫ñÂÇôÂ•Ω")
            loadAd()
            return
        }
        
        print("üì± [InterstitialAd] ÈñãÂßãÂ±ïÁ§∫Âª£Âëä")
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.keyWindow ?? windowScene.windows.first,
           let rootViewController = window.rootViewController {
            interstitialAd.present(fromRootViewController: rootViewController)
        }
    }
    
    // MARK: - GADFullScreenContentDelegate
    
    nonisolated func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        print("üì± [InterstitialAd] Âª£ÂëäÈóúÈñâÔºåÈñãÂßãÈ†êËºâ‰∏ã‰∏ÄÂÄã")
        loadAd()
    }
    
    nonisolated func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        print("‚ùå [InterstitialAd] Âª£ÂëäÂ±ïÁ§∫Â§±Êïó: \(error.localizedDescription)")
        loadAd()
    }
}

class PerformanceMonitor {
    static let shared = PerformanceMonitor()
    private var startTimes: [String: CFAbsoluteTime] = [:]
    private var measurements: [(String, TimeInterval)] = []
    
    func start(_ name: String) {
        startTimes[name] = CFAbsoluteTimeGetCurrent()
    }
    
    func end(_ name: String) {
        guard let startTime = startTimes[name] else { return }
        let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
        measurements.append((name, timeElapsed))
        print("‚è±Ô∏è [Performance] \(name): \(String(format: "%.3f", timeElapsed))s")
    }
    
    func reset() {
        startTimes.removeAll()
        measurements.removeAll()
    }
    
    func printSummary() {
        print("\nüìä Performance Summary:")
        print("------------------------")
        for (name, time) in measurements {
            print("\(name.padding(toLength: 25, withPad: " ", startingAt: 0)): \(String(format: "%.3f", time))s")
        }
        print("------------------------\n")
    }
}

#Preview {
    ContentView()
}

struct CreateAccountView: View {
    @Environment(\.dismiss) var dismiss
    @Binding var isLoggedIn: Bool
    @ObservedObject var authViewModel: AuthViewModel
    @State private var email = ""
    @State private var password = ""
    @State private var confirmPassword = ""
    @State private var fullName = ""
    @State private var companyName = ""
    @State private var isSignUp = false
    @State private var showError = false
    @State private var errorMessage: String?
    @Environment(\.colorScheme) var colorScheme
    @State private var appleSignInCoordinator: AppleSignInCoordinator?
    @State private var isLoading: Bool = false
    
    let textColor = Color(hex: "#FF798C")
    
    var body: some View {
        ZStack {
            Image("background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 0) {
                // Pull Indicator
                RoundedRectangle(cornerRadius: 2.5)
                    .fill(Color.gray.opacity(0.5))
                    .frame(width: 40, height: 5)
                    .padding(.vertical, 10)
                
                ScrollView(showsIndicators: false) {
                    VStack(spacing: 20) {
                        // Move top padding into spacer for better layout
                        Spacer()
                            .frame(height: 30) // Reduced top spacing due to pull indicator
                        
                        Text("Âª∫Á´ãÊñ∞Â∏≥Ëôü")
                            .font(.custom("NotoSansTC-Black", size: 32))
                            .foregroundColor(textColor)
                        
                        VStack(spacing: 15) {
                            CustomTextField(placeholder: "ÂßìÂêç", text: $fullName)
                            CustomTextField(
                                placeholder: "ÈõªÂ≠êÈÉµ‰ª∂", 
                                text: $email,
                                keyboardType: .emailAddress,
                                autocapitalization: .never,
                                validation: { email in
                                    let emailRegex = #"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"#
                                    let emailPredicate = NSPredicate(format: "SELF MATCHES %@", emailRegex)
                                    return emailPredicate.evaluate(with: email)
                                },
                                errorMessage: "Ë´ãËº∏ÂÖ•ÊúâÊïàÁöÑÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄ"
                            )
                            CustomTextField(placeholder: "ÂØÜÁ¢º", text: $password, isSecure: true)
                            CustomTextField(placeholder: "Á¢∫Ë™çÂØÜÁ¢º", text: $confirmPassword, isSecure: true)
                        }
                        .padding(.horizontal)
                        
                        Button(action: createAccount) {
                            if isLoading {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            } else {
                                Text("Ë®ªÂÜä")
                                    .font(.custom("NotoSansTC-Black", size: 18))
                            }
                        }
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(textColor)
                        .cornerRadius(25)
                        .disabled(email.isEmpty || password.isEmpty || confirmPassword.isEmpty || isLoading)
                        
                        // Add bottom spacer for keyboard
                        Spacer()
                            .frame(height: 100)
                    }
                    .padding()
                }
                // Disable scroll view's automatic keyboard avoidance
                .ignoresSafeArea(.keyboard, edges: .bottom)
            }
            .ignoresSafeArea(.keyboard, edges: .bottom)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("ËøîÂõû") {
                        dismiss()
                    }
                }
            }
            .alert("ÈåØË™§", isPresented: $showError) {  // Êñ∞Â¢û @State private var showError = false
                Button("Á¢∫ÂÆö", role: .cancel) { }
            } message: {
                Text(errorMessage ?? "ÁôºÁîüÊú™Áü•ÈåØË™§")  // ‰øÆÊîπÁÇ∫‰ΩøÁî®ÂèØÈÅ∏ÂûãÂà•
            }
        }
    }
    
    // MARK: - CreateAccount Function
    private func createAccount() {
        guard !email.isEmpty, !password.isEmpty, !confirmPassword.isEmpty else {
            errorMessage = "Ë´ãÂ°´ÂØ´ÊâÄÊúâÂøÖÂ°´Ê¨Ñ‰Ωç"
            showError = true
            return
        }
        
        guard password == confirmPassword else {
            errorMessage = "ÂØÜÁ¢ºÁ¢∫Ë™ç‰∏ç‰∏ÄËá¥"
            showError = true
            return
        }
        
        guard password.count >= 6 else {
            errorMessage = "ÂØÜÁ¢ºËá≥Â∞ëÈúÄË¶Å6ÂÄãÂ≠óÁ¨¶"
            showError = true
            return
        }
        
        isLoading = true
        
        Task {
            do {
                let result = try await Auth.auth().createUser(withEmail: email, password: password)
                
                // Update user profile if needed
                let changeRequest = result.user.createProfileChangeRequest()
                if !fullName.isEmpty {
                    changeRequest.displayName = fullName
                }
                try await changeRequest.commitChanges()
                
                await MainActor.run {
                    isLoading = false
                    authViewModel.handleSuccessfulLogin()
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    errorMessage = error.localizedDescription
                    showError = true
                }
            }
        }
    }

    #if DEBUG
    @ObserveInjection var forceRedraw
    #endif
}

struct GIFImageView: UIViewRepresentable {
    private let gifName: String
    private let frame: CGRect
    private let onAnimationComplete: () -> Void
    private let isTransparent: Bool
    private let loopCount: Int
    
    init(_ name: String, 
         frame: CGRect, 
         isTransparent: Bool = false,
         loopCount: Int = 1,
         onAnimationComplete: @escaping () -> Void) {
        self.gifName = name
        self.frame = frame
        self.isTransparent = isTransparent
        self.loopCount = loopCount
        self.onAnimationComplete = onAnimationComplete
    }
    
    func makeUIView(context: Context) -> UIView {
        let view = UIView(frame: frame)
        view.backgroundColor = isTransparent ? .clear : .black
        
        // Load GIF
        if let path = Bundle.main.path(forResource: gifName, ofType: "gif") {
            let url = URL(fileURLWithPath: path)
            let gifImageView = UIImageView(gifURL: url, loopCount: loopCount)
            gifImageView.frame = CGRect(x: 0, y: 0, width: view.bounds.width, height: view.bounds.height) // Ë®≠ÂÆöÁÇ∫ËàáviewÁõ∏ÂêåÂ§ßÂ∞è‰ª•ÂÆåÂÖ®Â°´Êªø
            gifImageView.contentMode = .scaleAspectFill
            gifImageView.backgroundColor = isTransparent ? .clear : .black

            gifImageView.delegate = context.coordinator
            view.addSubview(gifImageView)
        }
        
        return view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(onAnimationComplete: onAnimationComplete)
    }
    
    class Coordinator: NSObject, SwiftyGifDelegate {
        private let onAnimationComplete: () -> Void
        
        init(onAnimationComplete: @escaping () -> Void) {
            self.onAnimationComplete = onAnimationComplete
            super.init()
        }
        
        func gifDidStop(sender: UIImageView) {
            onAnimationComplete()
        }
    }
}

struct SplashScreenView: View {
    @Binding var showSplash: Bool
    
    var body: some View {
        ZStack {
            Color.white
                .edgesIgnoringSafeArea(.all)
            
            GIFImageView("splash_animation", 
                        frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
                        isTransparent: false,
                        onAnimationComplete: {
                            // GIF Êí≠ÊîæÂÆåÊàêÂæåÁöÑÂõûË™ø
                            showSplash = false
                        })
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .edgesIgnoringSafeArea(.all)
        }
        .ignoresSafeArea()
    }
}

struct UserData: Codable {
    var remainingUses: Int
    var favorites: [FavoriteNameData]
    var lastSyncTime: Date
    
    static let defaultUses = 3
    
    static func createDefault() -> UserData {
        return UserData(
            remainingUses: defaultUses,
            favorites: [],
            lastSyncTime: Date()
        )
    }
}

// Êñ∞Â¢û‰∏ÄÂÄãÈÄöÁî®ÁöÑÂèØÈªûÊìäÊïàÊûú‰øÆÈ£æÂô®
struct PressableButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .opacity(configuration.isPressed ? 0.7 : 1.0) // ‰øùÁïôÈÄèÊòéÂ∫¶ËÆäÂåñ‰ΩÜÁßªÈô§ÂãïÁï´
            .animation(nil, value: configuration.isPressed) // Á¶ÅÁî®ÂãïÁï´
    }
}

struct LoadingView: View {
    var body: some View {
        ZStack {
            VStack(spacing: 20) {
                GIFImageView("loading_animation", 
                    frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
                    isTransparent: true,
                    loopCount: -1) {
                }
                .frame(maxWidth: .infinity) // ËÆìÂÆπÂô®‰ΩîÊìöÂÖ®ÂØ¨ÔºåÂØ¶ÁèæÊ∞¥Âπ≥ÁΩÆ‰∏≠
                
                Text("ÁîüÊàêÂêçÂ≠ó‰∏≠ÔºàÁ¥Ñ30ÁßíÔºâ...")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.black)
            }
        }
    }
}

struct SuccessPopupView: View {
    let uses: Int
    var onDismiss: () -> Void
    
    var body: some View {
        ZStack {
            // ÂçäÈÄèÊòéËÉåÊôØ
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
                .onTapGesture {
                    onDismiss()
                }
            
            // ÂΩàÂá∫Ë¶ñÁ™ó
            VStack(spacing: 24) { // Â¢ûÂä†Êï¥È´îÂûÇÁõ¥ÈñìË∑ù
                Image(systemName: "checkmark.circle.fill")
                    .resizable()
                    .frame(width: 60, height: 60)
                    .foregroundColor(.green)
                    .padding(.top, 32) // È†ÇÈÉ®Â¢ûÂä†ÈñìË∑ù
                
                VStack(spacing: 12) { // ÊñáÂ≠óÂçÄÂ°äÁöÑÂûÇÁõ¥ÈñìË∑ù
                    Text("Ë≥ºË≤∑ÊàêÂäüÔºÅ")
                        .font(.custom("NotoSansTC-Black", size: 24))
                        .foregroundColor(.customText)
                    
                    Text("Â∑≤Êñ∞Â¢û \(uses) Ê¨°‰ΩøÁî®Ê©üÊúÉ")
                        .font(.custom("NotoSansTC-Regular", size: 18))
                        .foregroundColor(.customText)
                }
                
                Button(action: onDismiss) {
                    Text("Á¢∫ÂÆö")
                        .font(.custom("NotoSansTC-Regular", size: 16))
                        .foregroundColor(.white)
                        .frame(width: 120) // Â¢ûÂä†ÊåâÈàïÂØ¨Â∫¶
                        .padding(.vertical, 14) // Â¢ûÂä†ÊåâÈàïÈ´òÂ∫¶
                        .background(Color.customAccent)
                        .cornerRadius(25)
                }
                .padding(.top, 8) // ÊåâÈàï‰∏äÊñπÈñìË∑ù
                .padding(.bottom, 32) // Â∫ïÈÉ®Â¢ûÂä†ÈñìË∑ù
            }
            .frame(width: 280) // Ë®≠ÂÆöÂõ∫ÂÆöÂØ¨Â∫¶
            .background(Color.white)
            .cornerRadius(20)
            .shadow(radius: 10)
            .padding(.horizontal, 40)
        }
        .transition(.opacity)
    }
}

// Êñ∞Â¢û‰∏ÄÂÄãËá™ÂÆöÁæ©ÊåâÈàïÊ®£Âºè
struct NavigationButtonStyle: ButtonStyle {
    var isPrimary: Bool = false
    
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.custom("NotoSansTC-Black", size: 16))
            .foregroundColor(isPrimary ? .white : .customAccent)
            .padding(.horizontal, 20)
            .padding(.vertical, 10)
            .background(
                isPrimary ? Color.customAccent : Color.white
            )
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(Color.customAccent, lineWidth: 1)
            )
            .opacity(configuration.isPressed ? 0.8 : 1.0)
    }
}

// Add hideKeyboard() as a global function
private func hideKeyboard() {
    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                  to: nil, from: nil, for: nil)
}

// Êñ∞Â¢û AppOpenAdManager È°ûÂà•
class AppOpenAdManager: NSObject, GADFullScreenContentDelegate {
    static let shared = AppOpenAdManager()
    
    private var appOpenAd: GADAppOpenAd?
    private var isLoadingAd = false
    private var isShowingAd = false
    private var loadTime: Date?
    
    private let fourHoursInSeconds = TimeInterval(3600 * 4)
    
    override init() {
        super.init()
        loadAd()
    }
    
    private func loadAd() {
        // Â¶ÇÊûúÊ≠£Âú®ËºâÂÖ•Âª£ÂëäÊàñÂ∑≤ÊúâÂèØÁî®Âª£ÂëäÔºåÂâá‰∏çËºâÂÖ•
        if isLoadingAd || isAdAvailable() {
            return
        }
        isLoadingAd = true
        
        print("üì± [AppOpenAd] ÈñãÂßãËºâÂÖ•Âª£Âëä")
        // Task {
        //     do {
        //         appOpenAd = try await GADAppOpenAd.load(
        //             withAdUnitID: "ca-app-pub-3469743877050320/7027134890",
        //             request: GADRequest())
        //         appOpenAd?.fullScreenContentDelegate = self
        //         loadTime = Date()
                
        //         await MainActor.run {
        //             isLoadingAd = false
        //             print("‚úÖ [AppOpenAd] Âª£ÂëäËºâÂÖ•ÊàêÂäü")
        //         }
        //     } catch {
        //         await MainActor.run {
        //             isLoadingAd = false
        //             print("‚ùå [AppOpenAd] Âª£ÂëäËºâÂÖ•Â§±Êïó: \(error.localizedDescription)")
        //         }
        //     }
        // }
    }
    
    func showAdIfAvailable() {
        // Â¶ÇÊûúÂª£ÂëäÊ≠£Âú®È°ØÁ§∫‰∏≠ÔºåÂâá‰∏çÈ°ØÁ§∫
        guard !isShowingAd else { return }
        
        // Â¶ÇÊûúÊ≤íÊúâÂèØÁî®Âª£ÂëäÔºåÂâáËºâÂÖ•Êñ∞Âª£Âëä
        if !isAdAvailable() {
            loadAd()
            return
        }
        
        if let ad = appOpenAd {
            isShowingAd = true
            print("üì± [AppOpenAd] ÈñãÂßãÂ±ïÁ§∫Âª£Âëä")
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.keyWindow ?? windowScene.windows.first,
           let rootViewController = window.rootViewController {
                ad.present(fromRootViewController: rootViewController)
            }
        }
    }
    
    private func wasLoadTimeLessThanFourHoursAgo() -> Bool {
        guard let loadTime = loadTime else { return false }
        return Date().timeIntervalSince(loadTime) < fourHoursInSeconds
    }
    
    private func isAdAvailable() -> Bool {
        return appOpenAd != nil && wasLoadTimeLessThanFourHoursAgo()
    }
    
    // MARK: - GADFullScreenContentDelegate
    
    nonisolated func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        appOpenAd = nil
        isShowingAd = false
        print("üì± [AppOpenAd] Âª£ÂëäÈóúÈñâÔºåÈñãÂßãÈ†êËºâ‰∏ã‰∏ÄÂÄã")
        loadAd()
    }
    
    nonisolated func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        appOpenAd = nil
        isShowingAd = false
        print("‚ùå [AppOpenAd] Âª£ÂëäÂ±ïÁ§∫Â§±Êïó: \(error.localizedDescription)")
        loadAd()
    }
    
    func adWillPresentFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        print("üì± [AppOpenAd] Âª£ÂëäÂ∞áË¶ÅÂ±ïÁ§∫")
    }
}

// ‰øÆÊîπ AppStateManager
class AppStateManager: ObservableObject {
    private let appOpenAdManager = AppOpenAdManager.shared
    private var lastBackgroundTime: Date?
    private let minimumBackgroundDuration: TimeInterval = 30
    
    init() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleAppBackground),
            name: UIApplication.didEnterBackgroundNotification,
            object: nil
        )
    }
    
    @objc private func handleAppBackground() {
        lastBackgroundTime = Date()
    }
    
    func handleAppForeground() {
        guard let lastBackground = lastBackgroundTime else { return }
        
        let timeInBackground = Date().timeIntervalSince(lastBackground)
        
        if timeInBackground >= minimumBackgroundDuration {
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
                self?.appOpenAdManager.showAdIfAvailable()
            }
        }
        
        lastBackgroundTime = nil
    }
}

// Add these extensions at the bottom of the file
extension String {
    static func randomNonceString(length: Int = 32) -> String {
        precondition(length > 0)
        let charset: [Character] =
        Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")
        var result = ""
        var remainingLength = length
        
        while remainingLength > 0 {
            let randoms: [UInt8] = (0 ..< 16).map { _ in
                var random: UInt8 = 0
                let errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random)
                if errorCode != errSecSuccess {
                    fatalError("Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)")
                }
                return random
            }
            
            randoms.forEach { random in
                if remainingLength == 0 {
                    return
                }
                
                if random < charset.count {
                    result.append(charset[Int(random)])
                    remainingLength -= 1
                }
            }
        }
        return result
    }
}

extension String {
    var sha256: String {
        let inputData = Data(self.utf8)
        let hashedData = SHA256.hash(data: inputData)
        let hashString = hashedData.compactMap {
            String(format: "%02x", $0)
        }.joined()
        
        return hashString
    }
}

// Âú®Ê™îÊ°àÈñãÈ†≠Êñ∞Â¢û QuestionManager È°ûÂà•
class QuestionManager: ObservableObject {
    static let shared = QuestionManager()
    @Published private(set) var questions: [Question] = []
    private let questionsCacheKey = "cachedQuestions"
    private let lastUpdateTimeKey = "questionsLastUpdateTime"
    private let updateInterval: TimeInterval = 24 * 60 * 60 // 24Â∞èÊôÇÊõ¥Êñ∞‰∏ÄÊ¨°
    
    private init() {
        loadCachedQuestions()
    }
    
    private func loadCachedQuestions() {
        if let data = UserDefaults.standard.data(forKey: questionsCacheKey),
           let cachedQuestions = try? JSONDecoder().decode([Question].self, from: data) {
            self.questions = cachedQuestions
        }
    }
    
    func updateQuestionsIfNeeded() async {
        // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
        let lastUpdate = UserDefaults.standard.double(forKey: lastUpdateTimeKey)
        let now = Date().timeIntervalSince1970
        
        guard now - lastUpdate > updateInterval else {
            print("‚úÖ [Questions] ÂïèÈ°åÂ∫´‰ªçÂú®ÊúâÊïàÊúüÂÖßÔºåÁÑ°ÈúÄÊõ¥Êñ∞")
            return
        }
        
        print("üîÑ [Questions] ÈñãÂßãÊõ¥Êñ∞ÂïèÈ°åÂ∫´")
        
        do {
            let db = Firestore.firestore()
            let snapshot = try await db.collection("questions").getDocuments()
            
            var newQuestions: [Question] = []
            
            for document in snapshot.documents {
                do {
                    if let questionsData = document.get("questions") as? [[String: Any]] {
                        for questionData in questionsData {
                            if let scenario = questionData["question"] as? String,
                               let choicesData = questionData["choices"] as? [String: [String: String]] {
                                
                                let choices: [Choice] = choicesData.values.compactMap { choiceDict -> Choice? in
                                    guard let text = choiceDict["text"],
                                          let meaning = choiceDict["meaning"] else {
                                        print("‚ö†Ô∏è [Questions] ÁÑ°ÊïàÁöÑÈÅ∏È†ÖË≥áÊñô: \(choiceDict)")
                                        return nil
                                    }
                                    return Choice(text: text, meaning: meaning)
                                }
                                
                                // Âè™ÊúâÁï∂ÈÅ∏È†Ö‰∏çÁÇ∫Á©∫ÊôÇÊâçÂä†ÂÖ•ÂïèÈ°å
                                if !choices.isEmpty {
                                    let question = Question(question: scenario, choices: choices)
                                    newQuestions.append(question)
                                } else {
                                    print("‚ö†Ô∏è [Questions] ÂïèÈ°åÊ≤íÊúâÊúâÊïàÈÅ∏È†ÖÔºåË∑≥ÈÅé: \(scenario)")
                                }
                            } else {
                                print("‚ö†Ô∏è [Questions] ÁÑ°ÊïàÁöÑÂïèÈ°åË≥áÊñôÁµêÊßã: \(questionData)")
                            }
                        }
                    } else {
                        print("‚ö†Ô∏è [Questions] Êñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á¢∫: \(document.documentID)")
                    }
                } catch {
                    print("‚ùå [Questions] ËôïÁêÜÊñá‰ª∂ÊôÇÁôºÁîüÈåØË™§: \(document.documentID), ÈåØË™§: \(error.localizedDescription)")
                    // Ë®òÈåÑÈåØË™§‰ΩÜÁπºÁ∫åËôïÁêÜÂÖ∂‰ªñÊñá‰ª∂
                    ErrorManager.shared.logError(
                        category: .aiResponseInvalidSchema,
                        message: "ËôïÁêÜÂïèÈ°åÊñá‰ª∂ÊôÇÁôºÁîüÈåØË™§",
                        details: [
                            "document_id": document.documentID,
                            "error": error.localizedDescription
                        ]
                    )
                }
            }
            
            // Êõ¥Êñ∞Âø´Âèñ
            if !newQuestions.isEmpty {
                do {
                    let encoder = JSONEncoder()
                    let encoded = try encoder.encode(newQuestions)
                    UserDefaults.standard.set(encoded, forKey: questionsCacheKey)
                    UserDefaults.standard.set(now, forKey: lastUpdateTimeKey)
                    
                    await MainActor.run {
                        self.questions = newQuestions
                    }
                    print("‚úÖ [Questions] ÂïèÈ°åÂ∫´Êõ¥Êñ∞ÊàêÂäüÔºåËºâÂÖ• \(newQuestions.count) ÂÄãÂïèÈ°å")
                } catch {
                    print("‚ùå [Questions] Á∑®Á¢ºÂïèÈ°åË≥áÊñôÂ§±Êïó: \(error.localizedDescription)")
                    ErrorManager.shared.logError(
                        category: .unknown,
                        message: "Á∑®Á¢ºÂïèÈ°åË≥áÊñôÂ§±Êïó",
                        details: ["error": error.localizedDescription]
                    )
                }
            } else {
                print("‚ö†Ô∏è [Questions] Ê≤íÊúâÁç≤ÂèñÂà∞‰ªª‰ΩïÊúâÊïàÂïèÈ°å")
            }
            
        } catch {
            print("‚ùå [Questions] Êõ¥Êñ∞ÂïèÈ°åÂ∫´Â§±Êïó: \(error.localizedDescription)")
            // Ë®òÈåÑË©≥Á¥∞ÈåØË™§‰ø°ÊÅØ
            ErrorManager.shared.logError(
                category: .apiCallNetworkError,
                message: "Firestore ÂïèÈ°åÂ∫´Êõ¥Êñ∞Â§±Êïó",
                details: [
                    "error": error.localizedDescription,
                    "error_type": String(describing: type(of: error))
                ]
            )
        }
    }
    
    func getRandomQuestions(_ count: Int) -> [Question] {
        return Array(questions.shuffled().prefix(count))
    }
}

// Add this helper function
private func calculateFontSize(for characterCount: Int) -> CGFloat {
    switch characterCount {
        case 2: return 48 // ÂÖ©ÂÄãÂ≠óÁ∂≠ÊåÅÂéüÂßãÂ§ßÂ∞è
        case 3: return 42 // ‰∏âÂÄãÂ≠óÁ®çÂæÆÁ∏ÆÂ∞è
        case 4: return 36 // ÂõõÂÄãÂ≠óÂÜçÁ∏ÆÂ∞è
        default: return 32 // ÂÖ∂‰ªñÊÉÖÊ≥Å‰ΩøÁî®ÊúÄÂ∞èÂ≠óÈ´î
    }
}

enum NameGenerationError: Error {
    case wrongCharacterCount(expected: Int, actual: Int)
}

// MARK: - DesignFocusView

struct DesignFocusView: View {
    @Binding var navigationPath: NavigationPath
    let formData: FormData
    @State private var selectedOptions: Set<String> = []
    @State private var customDescription: String = ""
    @State private var showHelpDialog = false
    @Environment(\.colorScheme) var colorScheme
    
    private let designOptions = [
        "Â∞çÂ≠©Â≠êÁöÑÊúüË®±ËàáÁ•ùÁ¶è",
        "Â≠©Â≠êËàáÁà∂ÊØçÁöÑÈÄ£Áµê",
        "ÂºïÁ∂ìÊìöÂÖ∏/Âêç‰∫∫ÂÖ∏ÊïÖ"
    ]
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background
                Image("background")
                    .resizable()
                    .scaledToFill()
                    .edgesIgnoringSafeArea(.all)
                
                // Main content
                VStack(spacing: 0) {
                    // Scrollable content
                    ScrollView {
                        VStack(spacing: 20) {
                            // Header section
                            headerSection
                            
                            // Design focus question
                            designFocusSection
                            
                            // Custom description section
                            customDescriptionSection

                            bottomButton
                        }
                        .padding(.horizontal, 20)
                        .padding(.bottom, 120) // Space for bottom button
                    }
                    
                    // Bottom button
                    
                }
            }
            .designFocusNavigationBarSetup(navigationPath: $navigationPath, title: "Ë®≠Ë®à‰∏ªËª∏")
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
        .sheet(isPresented: $showHelpDialog) {
            helpDialogView
        }
    }
    
    private var headerSection: some View {
        HStack(alignment: .top, spacing: 10) {
            Image("main_mascot")
                .resizable()
                .scaledToFit()
                .frame(width: 100, height: 100)
            
            VStack(alignment: .leading) {
                Text("ËÆìÊàëÂÄë‰∫ÜËß£ÊÇ®Â∏åÊúõÁöÑ\nÂêçÂ≠óË®≠Ë®àÊñπÂêë")
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(.black)
                    .padding(12)
                    .background(Color.white)
                    .cornerRadius(15)
                    .overlay(
                        DesignFocusTriangle()
                            .fill(Color.white)
                            .frame(width: 20, height: 20)
                            .rotationEffect(.degrees(-90))
                            .offset(x: -15, y: 10)
                        , alignment: .topLeading
                    )
            }
        }
        .padding(.top, 20)
    }
    
    private var designFocusSection: some View {
        VStack(alignment: .leading, spacing: 15) {
            HStack {
                Text("ÊÇ®ÊÉ≥Ë¶Å‰ª•‰ªÄÈ∫ºÊ®£ÁöÑ‰∏ªËª∏‰æÜË®≠Ë®àÂ≠©Â≠êÁöÑÂêçÂ≠óÔºü(ÂèØË§áÈÅ∏)")
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.customText)
                
                Spacer()
                
                // Help button
                Button(action: {
                    showHelpDialog = true
                }) {
                    Image(systemName: "questionmark.circle")
                        .font(.system(size: 20))
                        .foregroundColor(.customAccent)
                }
            }
            .padding(.leading, 5)
            
            // Design options
            VStack(spacing: 12) {
                ForEach(designOptions, id: \.self) { option in
                    Button(action: {
                        toggleOption(option)
                    }) {
                        HStack {
                            Image(systemName: selectedOptions.contains(option) ? "checkmark.square.fill" : "square")
                                .font(.system(size: 20))
                                .foregroundColor(selectedOptions.contains(option) ? .customAccent : .gray)
                            
                            Text(option)
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.customText)
                                .multilineTextAlignment(.leading)
                            
                            Spacer()
                        }
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 15)
                                .fill(selectedOptions.contains(option) ? Color.customAccent.opacity(0.1) : Color.white)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 15)
                                        .stroke(selectedOptions.contains(option) ? Color.customAccent : Color.gray.opacity(0.3), lineWidth: 1)
                                )
                        )
                    }
                }
            }
        }
    }
    
    private var customDescriptionSection: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Ë´ãÁõ°ÈáèË©≥Á¥∞ÊèèËø∞ÊÇ®ÊÉ≥Ë¶ÅÁöÑË®≠Ë®à‰∏ªËª∏")
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            Text("(ÈñãÊîæÂºèÂ°´ÂØ´ÔºåÈùûÂøÖÂ°´)")
                .font(.custom("NotoSansTC-Regular", size: 14))
                .foregroundColor(.gray)
                .padding(.leading, 5)
            
            ZStack(alignment: .topLeading) {
                RoundedRectangle(cornerRadius: 15)
                    .fill(Color.white)
                    .overlay(
                        RoundedRectangle(cornerRadius: 15)
                            .stroke(Color.customAccent, lineWidth: 1)
                    )
                    .frame(height: 120)
                
                if customDescription.isEmpty {
                    Text("‰æãÂ¶ÇÔºöÂ∏åÊúõÂ≠©Â≠êÂÖ∑ÊúâË¨ôËôõÁöÑÁæéÂæ∑„ÄÅÊú™‰æÜ‰∫ãÊ•≠ÊàêÂäü...")
                        .font(.custom("NotoSansTC-Regular", size: 14))
                        .foregroundColor(.gray)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 12)
                }
                
                TextEditor(text: $customDescription)
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(Color.clear)
                    .scrollContentBackground(.hidden)
            }
        }
    }
    
    private var bottomButton: some View {
        VStack {
            Button(action: {
                hideKeyboard()
                proceedToNext()
            }) {
                Text("‰∏ã‰∏ÄÊ≠•")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(selectedOptions.isEmpty ? Color.gray : Color(hex: "#FF798C"))
                    .cornerRadius(25)
            }
            .disabled(selectedOptions.isEmpty)
            .padding(.horizontal)
            .padding(.bottom, 20)
        }
        .background(
            Color.white.opacity(0.95)
                .blur(radius: 10)
                .edgesIgnoringSafeArea(.bottom)
        )
        .ignoresSafeArea(.keyboard)
    }
    
    private var helpDialogView: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 20) {
                Text("Ë®≠Ë®à‰∏ªËª∏Ë™™Êòé")
                    .font(.custom("NotoSansTC-Black", size: 24))
                    .foregroundColor(.customText)
                    .padding(.bottom, 10)
                
                ScrollView {
                    VStack(alignment: .leading, spacing: 15) {
                        exampleSection(
                            title: "1. Â∞çÂ≠©Â≠êÁöÑÊúüË®±ËàáÁ•ùÁ¶è",
                            description: "Â∏åÊúõÂ≠©Â≠êÂÖ∑ÊúâË¨ôËôõÁöÑÁæéÂæ∑„ÄÅÊú™‰æÜ‰∫ãÊ•≠ÊàêÂäü„ÄÅÁï∂ÈÜ´Áîü...Á≠â„ÄÇ"
                        )
                        
                        exampleSection(
                            title: "2. Â≠©Â≠êËàáÁà∂ÊØçÁöÑÈÄ£Áµê",
                            description: "Â≠©Â≠êÂæûÁà∂ÂßìÔºåÊØçË¶™ÂßìÁæÖÔºåÂèñÂ≠©Â≠ê‰∏≠ÈñìÂêç„ÄåÁ∂≠„ÄçÔºåÂ∞áÊØçË¶™ÂßìÊ∞è‰∏ÄÈÉ®ÂàÜÊîæÂà∞Â≠©Â≠êÁöÑÂêçÂ≠ó‰∏≠ÔºåÂä†Âº∑ËàáÊØçÂÆ∂ÁöÑÈÄ£Áµê„ÄÇ"
                        )
                        
                        exampleSection(
                            title: "3. ÂºïÁ∂ìÊìöÂÖ∏/Âêç‰∫∫ÂÖ∏ÊïÖ",
                            description: "Âèñ„ÄåÂæ∑È¶®„Äç‰∫åÂ≠óÂØìÊÑè‰∏ñÁïåÈõñÂ¶ÇÈôãÂÆ§‰∏ÄËà¨‰∏çÂ†™Ôºå‰ΩÜÈ°òËÉΩÂõ†Â≠©Â≠êÁöÑÈ´òÂ∞öÂìÅÂæ∑‰ªçËä≥È¶ô‰∏ÄÈöÖ„ÄÇÂè¶Â§ñÔºå‰πüÂ∏åÊúõÂ≠©Â≠êÂÄãÊÄßÈñãÊúóÔºåÂ¶ÇÈªéÊòéËà¨Â∏∂Áµ¶Áà∂ÊØçÂ∏åÊúõÔºåÂ∞á„ÄåÈ¶®„ÄçÂ≠óÊîπÁÇ∫ÂêåÈü≥Â≠ó„ÄåÊòï„ÄçÔºåÊúÄÂæåÂëΩÂêçÁÇ∫„ÄêÂæ∑Êòï„Äë"
                        )
                    }
                }
                
                Spacer()
            }
            .padding()
            .navigationTitle("Ë®≠Ë®à‰∏ªËª∏ÁØÑ‰æã")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarItems(
                trailing: Button("ÈóúÈñâ") {
                    showHelpDialog = false
                }
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customAccent)
            )
        }
    }
    
    private func exampleSection(title: String, description: String) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customAccent)
            
            Text(description)
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
        }
    }
    
    private func toggleOption(_ option: String) {
        if selectedOptions.contains(option) {
            selectedOptions.remove(option)
        } else {
            selectedOptions.insert(option)
        }
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                      to: nil, from: nil, for: nil)
    }
    
    private func proceedToNext() {
        // Create design focus data
        let designFocusData = DesignFocusData(
            selectedOptions: Array(selectedOptions),
            customDescription: customDescription.isEmpty ? nil : customDescription
        )
        
        // Combine form data and design focus data
        let formWithDesignData = FormWithDesignData(
            formData: formData,
            designFocusData: designFocusData
        )
        
        // Navigate to Special Requirements view
        navigationPath.append(formWithDesignData)
    }
}

// Helper struct for Triangle shape (speech bubble) - renamed to avoid conflicts
struct DesignFocusTriangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.midX, y: rect.minY))
        return path
    }
}

// Extension for navigation bar setup (specific to DesignFocusView)
private extension View {
    func designFocusNavigationBarSetup(navigationPath: Binding<NavigationPath>, title: String) -> some View {
        self
            .navigationBarTitle(title, displayMode: .inline)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        navigationPath.wrappedValue.removeLast()
                    }) {
                        Image(systemName: "chevron.left")
                            .foregroundColor(.white)
                    }
                }
                ToolbarItem(placement: .principal) {
                    Text(title)
                        .font(.custom("NotoSansTC-Black", size: 20))
                        .foregroundColor(.white)
                }
            }
            .toolbarBackground(.visible, for: .navigationBar)
            .toolbarBackground(Color.black, for: .navigationBar)
            .toolbarColorScheme(.dark, for: .navigationBar)
            .navigationBarBackButtonHidden(true)
            .navigationBarTitleDisplayMode(.inline)
            .overlay(
                Color.pink.frame(height: 5)
                    .edgesIgnoringSafeArea(.horizontal)
                    .offset(y: 0)
                , alignment: .top
            )
    }
}

// MARK: - SpecialRequirementView

struct SpecialRequirementView: View {
    @Binding var navigationPath: NavigationPath
    let formWithDesignData: FormWithDesignData
    @Binding var selectedTab: Int
    @State private var selectedRequirements: Set<String> = []
    @State private var detailDescription: String = ""
    @State private var showHelpDialog = false
    @Environment(\.colorScheme) var colorScheme
    
    // ÂêçÂ≠óÂàÜÊûêÁµêÊûúÁöÑÁãÄÊÖã
    @State private var generatedName: String?
    @State private var nameAnalysis: [String: String]?
    @State private var wuxing: [String]?
    
    // Êñ∞Â¢ûÁîüÊàêÁõ∏ÈóúÁöÑÁãÄÊÖãËÆäÊï∏
    @State private var isGeneratingName = false
    @State private var isGenerating = false
    @State private var errorMessage: String?
    @State private var showCharCountError = false
    @State private var generatedNameWithError: String = ""
    
    // ‰ΩøÁî®ÁÆ°ÁêÜÂô®
    private let usageManager = UsageManager.shared
    
    private let requirementOptions = [
        "Â≠óÈü≥",
        "Â≠óÂΩ¢", 
        "ÂÅèÊóÅÈÉ®È¶ñ",
        "Á≠ÜÂäÉ"
    ]
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background
                Image("background")
                    .resizable()
                    .scaledToFill()
                    .edgesIgnoringSafeArea(.all)
                
                // Main content
                if let generatedName = generatedName, let nameAnalysis = nameAnalysis, let wuxing = wuxing {
                    // Result view - Áõ¥Êé•È°ØÁ§∫ÁµêÊûúÈ†ÅÈù¢
                    NameAnalysisView(
                        name: generatedName,
                        analysis: nameAnalysis,
                        wuxing: wuxing,
                        navigationPath: $navigationPath,
                        selectedTab: $selectedTab,
                        regenerateAction: {
                            // ÈáçÊñ∞ÁîüÊàêÊôÇÂõûÂà∞Ë°®ÂñÆ
                            self.generatedName = nil
                            self.nameAnalysis = nil
                            self.wuxing = nil
                        },
                        showButtons: true
                    )
                } else if isGeneratingName {
                    // Loading view - È°ØÁ§∫ÁîüÊàêÁ≠âÂæÖÈ†ÅÈù¢ÔºàÂèÉËÄÉ DialogView Ê®£ÂºèÔºâ
                    VStack {
                        ProgressView("ÁîüÊàêÊôÇÈñìÁ¥Ñ‰∏âÂçÅÁßí")
                            .scaleEffect(1.5)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if let errorMessage = errorMessage {
                    // Error view - ÈåØË™§È°ØÁ§∫È†ÅÈù¢ÔºàÂèÉËÄÉ DialogView Ê®£ÂºèÔºâ
                    VStack {
                        Text("ÁîüÊàêÂêçÂ≠óÂ§±Êïó")
                            .font(.custom("NotoSansTC-Black", size: 24))
                            .foregroundColor(.red)
                            .padding()
                    
                        Text(errorMessage)
                            .font(.custom("NotoSansTC-Regular", size: 18))
                            .foregroundColor(.customText)
                            .multilineTextAlignment(.center)
                            .padding()
                        
                        // Only show retry button if user has remaining uses
                        if usageManager.remainingUses > 0 {
                            Button("ÈáçË©¶") {
                                self.errorMessage = nil
                                // ÈáçÊñ∞ÈñãÂßãÁîüÊàêÊµÅÁ®ã
                                let specialRequirementData = SpecialRequirementData(
                                    selectedRequirements: Array(selectedRequirements),
                                    detailDescription: detailDescription.isEmpty ? nil : detailDescription
                                )
                                generateNamev2(
                                    formData: formWithDesignData.formData,
                                    designFocusData: formWithDesignData.designFocusData,
                                    specialRequirementData: specialRequirementData
                                )
                            }
                            .font(.custom("NotoSansTC-Regular", size: 18))
                            .foregroundColor(.white)
                            .padding()
                            .background(.customAccent)
                            .cornerRadius(10)
                        } else {
                            Text("ÊÇ®ÁöÑ‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆåÔºåË´ãÂçáÁ¥öÊúÉÂì°ÊàñÊòéÂ§©ÂÜç‰æÜÔºÅ")
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.customText)
                                .multilineTextAlignment(.center)
                                .padding()
                            
                            Button("ËøîÂõûÈ¶ñÈ†Å") {
                                navigationPath.removeLast(navigationPath.count)
                                selectedTab = 0
                            }
                            .font(.custom("NotoSansTC-Regular", size: 18))
                            .foregroundColor(.white)
                            .padding()
                            .background(.gray)
                            .cornerRadius(10)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    // Form view - È°ØÁ§∫ÁâπÊÆäÈúÄÊ±ÇË°®ÂñÆ
                    VStack(spacing: 0) {
                        // Scrollable content
                        ScrollView {
                            VStack(spacing: 20) {
                                // Header section
                                headerSection
                                
                                // Special requirements question
                                specialRequirementSection
                                
                                // Detail description section
                                detailDescriptionSection
                                
                                // Bottom button
                                bottomButton
                            }
                            .padding(.horizontal, 20)
                            .padding(.bottom, 120) // Space for bottom button
                        }
                    }
                }
            }
            .designFocusNavigationBarSetup(navigationPath: $navigationPath, title: "ÁâπÊÆäÈúÄÊ±Ç")
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
        .sheet(isPresented: $showHelpDialog) {
            helpDialogView
        }
    }
    
    private var headerSection: some View {
        HStack(alignment: .top, spacing: 10) {
            Image("main_mascot")
                .resizable()
                .scaledToFit()
                .frame(width: 100, height: 100)
            
            VStack(alignment: .leading) {
                Text("ËÆìÊàëÂÄë‰∫ÜËß£ÊÇ®Â∞çÂ≠©Â≠ê\nÂêçÂ≠óÁöÑÁâπÊÆäÈúÄÊ±Ç")
                    .font(.custom("NotoSansTC-Regular", size: 18))
                    .foregroundColor(.black)
                    .padding(12)
                    .background(Color.white)
                    .cornerRadius(15)
                    .overlay(
                        DesignFocusTriangle()
                            .fill(Color.white)
                            .frame(width: 20, height: 20)
                            .rotationEffect(.degrees(-90))
                            .offset(x: -15, y: 10)
                        , alignment: .topLeading
                    )
            }
        }
        .padding(.top, 20)
    }
    
    private var specialRequirementSection: some View {
        VStack(alignment: .leading, spacing: 15) {
            HStack {
                Text("ÊÇ®ÊòØÂê¶Â∞çÊñºÂ≠©Â≠êÁöÑÂêçÂ≠óÊúâÁâπÊÆäÁöÑÈúÄÊ±ÇÔºü(ÂèØË§áÈÅ∏)")
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .foregroundColor(.customText)
                
                Spacer()
                
                // Help button
                Button(action: {
                    showHelpDialog = true
                }) {
                    Image(systemName: "questionmark.circle")
                        .font(.system(size: 20))
                        .foregroundColor(.customAccent)
                }
            }
            .padding(.leading, 5)
            
            // Requirement options
            VStack(spacing: 12) {
                ForEach(requirementOptions, id: \.self) { option in
                    Button(action: {
                        toggleRequirement(option)
                    }) {
                        HStack {
                            Image(systemName: selectedRequirements.contains(option) ? "checkmark.square.fill" : "square")
                                .font(.system(size: 20))
                                .foregroundColor(selectedRequirements.contains(option) ? .customAccent : .gray)
                            
                            Text(option)
                                .font(.custom("NotoSansTC-Regular", size: 16))
                                .foregroundColor(.customText)
                                .multilineTextAlignment(.leading)
                            
                            Spacer()
                        }
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 15)
                                .fill(selectedRequirements.contains(option) ? Color.customAccent.opacity(0.1) : Color.white)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 15)
                                        .stroke(selectedRequirements.contains(option) ? Color.customAccent : Color.gray.opacity(0.3), lineWidth: 1)
                                )
                        )
                    }
                }
            }
        }
    }
    
    private var detailDescriptionSection: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Ë´ãÁõ°ÈáèË©≥Á¥∞ÊèèËø∞ÊÇ®ÁöÑÁâπÊÆäÈúÄÊ±Ç")
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding(.leading, 5)
            
            Text("(ÈñãÊîæÂºèÂ°´ÂØ´Ê°ÜÔºåÈùûÂøÖÂ°´)")
                .font(.custom("NotoSansTC-Regular", size: 14))
                .foregroundColor(.gray)
                .padding(.leading, 5)
            
            ZStack(alignment: .topLeading) {
                RoundedRectangle(cornerRadius: 15)
                    .fill(Color.white)
                    .overlay(
                        RoundedRectangle(cornerRadius: 15)
                            .stroke(Color.customAccent, lineWidth: 1)
                    )
                    .frame(height: 120)
                
                if detailDescription.isEmpty {
                    Text("‰æãÂ¶ÇÔºöÂ∏åÊúõ‰∏≠ÈñìÂ≠óÊúâ„Äå„Ñã/N„ÄçÁöÑÈü≥Ôºå‰∏¶‰∏îÊòØ‰∫åËÅ≤ÔºõÂ∏åÊúõËÉΩÂåÖÂê´‰∏ÄÂÄãÊâìÂãæÁöÑÂ≠ó(‰∫Ö)...")
                        .font(.custom("NotoSansTC-Regular", size: 14))
                        .foregroundColor(.gray)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 12)
                }
                
                TextEditor(text: $detailDescription)
                    .font(.custom("NotoSansTC-Regular", size: 16))
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(Color.clear)
                    .scrollContentBackground(.hidden)
            }
        }
    }
    
    private var bottomButton: some View {
        VStack {
            Button(action: {
                hideKeyboard()
                proceedToNext()
            }) {
                Text("ÈñãÂßãÂëΩÂêç")
                    .font(.custom("NotoSansTC-Black", size: 18))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color(hex: "#FF798C"))
                    .cornerRadius(25)
            }
            .padding(.horizontal)
            .padding(.bottom, 20)
        }
        .background(
            Color.white.opacity(0.95)
                .blur(radius: 10)
                .edgesIgnoringSafeArea(.bottom)
        )
        .ignoresSafeArea(.keyboard)
    }
    
    private var helpDialogView: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 20) {
                Text("ÁâπÊÆäÈúÄÊ±ÇË™™Êòé")
                    .font(.custom("NotoSansTC-Black", size: 24))
                    .foregroundColor(.customText)
                    .padding(.bottom, 10)
                
                ScrollView {
                    VStack(alignment: .leading, spacing: 15) {
                        exampleSection(
                            title: "1. Â≠óÈü≥",
                            description: "Â∏åÊúõ‰∏≠ÈñìÂ≠óÊúâ„Äå„Ñã/N„ÄçÁöÑÈü≥Ôºå‰∏¶‰∏îÊòØ‰∫åËÅ≤"
                        )
                        
                        exampleSection(
                            title: "2. Â≠óÂΩ¢",
                            description: "Â∏åÊúõËÉΩÂåÖÂê´‰∏ÄÂÄãÊâìÂãæÁöÑÂ≠ó(‰∫Ö)ÔºåÂ¶ÇÔºö„Äå‰∏Å„Äç„ÄåÂØß„Äç"
                        )
                        
                        exampleSection(
                            title: "3. ÂÅèÊóÅÈÉ®È¶ñ",
                            description: "Â∏åÊúõÊúâ„ÄåÊú®„ÄçÂ≠óÊóÅÔºåÂ¶ÇÔºö„ÄåÊ™∏„Äç"
                        )
                        
                        exampleSection(
                            title: "4. Á≠ÜÂäÉ",
                            description: "Â∏åÊúõ‰∏çË¶ÅË∂ÖÈÅé10ÂäÉorÂ∏åÊúõ‰ªãÊñº10~15ÂäÉ‰πãÈñì"
                        )
                    }
                }
                
                Spacer()
            }
            .padding()
            .navigationTitle("ÁâπÊÆäÈúÄÊ±ÇÁØÑ‰æã")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarItems(
                trailing: Button("ÈóúÈñâ") {
                    showHelpDialog = false
                }
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customAccent)
            )
        }
    }
    
    private func exampleSection(title: String, description: String) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.custom("NotoSansTC-Black", size: 18))
                .foregroundColor(.customAccent)
            
            Text(description)
                .font(.custom("NotoSansTC-Regular", size: 16))
                .foregroundColor(.customText)
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
        }
    }
    
    private func toggleRequirement(_ requirement: String) {
        if selectedRequirements.contains(requirement) {
            selectedRequirements.remove(requirement)
        } else {
            selectedRequirements.insert(requirement)
        }
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                      to: nil, from: nil, for: nil)
    }
    
    private func proceedToNext() {
        // ÂâµÂª∫ÁâπÊÆäÈúÄÊ±ÇË≥áÊñô
        let specialRequirementData = SpecialRequirementData(
            selectedRequirements: Array(selectedRequirements),
            detailDescription: detailDescription.isEmpty ? nil : detailDescription
        )
        
        // Ë™øÁî® generateNamev2 ÊñπÊ≥ïÁîüÊàêÂêçÂ≠ó
        generateNamev2(
            formData: formWithDesignData.formData,
            designFocusData: formWithDesignData.designFocusData,
            specialRequirementData: specialRequirementData
        )
    }
    
    // MARK: - ÂêçÂ≠óÁîüÊàêv2ÊñπÊ≥ï (ÈÅ©Áî®ÊñºSpecialRequirementView)
    private func generateNamev2(
        formData: FormData,
        designFocusData: DesignFocusData, 
        specialRequirementData: SpecialRequirementData?
    ) {
        // Add a guard to prevent multiple generations
        let monitor = PerformanceMonitor.shared
        monitor.reset()
        monitor.start("Total Generation Time v2")
        
        guard !isGenerating else { return }
        
        print("\n=== ÈñãÂßãÁîüÊàêÂêçÂ≠óÊµÅÁ®ã v2 (SpecialRequirementView) ===")
        monitor.start("Usage Check")
        print("üì± [Generate v2] ÈñãÂßãÁîüÊàêÂêçÂ≠óË´ãÊ±Ç")
        print("üìä [Uses] ÁîüÊàêÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")
        
        // Check remaining uses before generating
        if usageManager.remainingUses <= 0 {
            monitor.end("Usage Check")
            print("‚ùå [Generate v2] ‰ΩøÁî®Ê¨°Êï∏‰∏çË∂≥ÔºåÁÑ°Ê≥ïÁîüÊàê")
            errorMessage = "ÂæàÊä±Ê≠âÔºåÊÇ®ÁöÑÂÖçË≤ª‰ΩøÁî®Ê¨°Êï∏Â∑≤Áî®ÂÆå„ÄÇ"
            return
        }
        monitor.end("Usage Check")
        
        // Set generating flag
        isGenerating = true
        
        // Deduct one use
        usageManager.remainingUses -= 1
        print("üìä [Uses] Êâ£Èô§‰∏ÄÊ¨°‰ΩøÁî®Ê©üÊúÉ")
        print("üìä [Uses] Áï∂ÂâçÂâ©È§òÊ¨°Êï∏: \(usageManager.remainingUses)")

        // Êõ¥Êñ∞Èõ≤Á´ØË≥áÊñô
        Task {
            try? await usageManager.updateCloudData()
        }
        
        monitor.start("UI Update - Loading")
        isGeneratingName = true
        errorMessage = nil
        monitor.end("UI Update - Loading")

        // Prepare the prompt for the AI model using v2 method
        monitor.start("Prompt Preparation v2")
        let prompt = preparePromptv2(
            formData: formData,
            designFocusData: designFocusData,
            specialRequirementData: specialRequirementData
        )
        monitor.end("Prompt Preparation v2")

        // Call the OpenAI API to generate the name
        Task {
            do {
                print("ü§ñ [API v2] ÈñãÂßãË™øÁî® OpenAI API")
                monitor.start("API Call v2")
                print("üìù [Prompt v2] Ë™øÁî® OpenAI API ÁöÑ prompt: \(prompt)")
                let (name, analysis, wuxing) = try await callOpenAIAPIv2(
                    with: prompt, 
                    formData: formData
                )
                monitor.end("API Call v2")
                print("‚úÖ [API v2] API Ë™øÁî®ÊàêÂäü")
                print("üìù [Result v2] ÁîüÊàêÁöÑÂêçÂ≠ó: \(name)")
                
                await MainActor.run {
                    monitor.start("UI Update - Results v2")
                    self.generatedName = name
                    self.nameAnalysis = analysis
                    self.wuxing = wuxing
                    self.isGeneratingName = false
                    self.isGenerating = false
                    monitor.end("UI Update - Results v2")
                    
                    print("‚úÖ [Generate v2] ÂêçÂ≠óÁîüÊàêÊµÅÁ®ãÂÆåÊàê")
                    monitor.end("Total Generation Time v2")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü v2 ===\n")
                }
            } catch {
                await MainActor.run {
                    monitor.start("Error Handling v2")
                    self.isGeneratingName = false
                    self.isGenerating = false
                    // ‰ΩøÁî®Ë©≥Á¥∞ÁöÑÈåØË™§ÂàÜÈ°û
                    let detailedErrorMessage = self.categorizeError(error)
                    self.errorMessage = detailedErrorMessage
                    monitor.end("Error Handling v2")
                    
                    // Ë©≥Á¥∞ÁöÑÈåØË™§Êó•Ë™å
                    print("‚ùå [Generate v2] ÂêçÂ≠óÁîüÊàêÊµÅÁ®ãÂ§±Êïó")
                    print("üîç [Error Details] ÈåØË™§È°ûÂûã: \(type(of: error))")
                    print("üîç [Error Details] ÈåØË™§ÊèèËø∞: \(error.localizedDescription)")
                    if let nsError = error as NSError? {
                        print("üîç [Error Details] ÈåØË™§‰ª£Á¢º: \(nsError.code)")
                        print("üîç [Error Details] ÈåØË™§Âüü: \(nsError.domain)")
                        print("üîç [Error Details] Áî®Êà∂‰ø°ÊÅØ: \(nsError.userInfo)")
                    }
                    print("üîç [Error Details] Áî®Êà∂ÁúãÂà∞ÁöÑÈåØË™§Ë®äÊÅØ: \(detailedErrorMessage)")
                    monitor.end("Total Generation Time v2")
                    monitor.printSummary()
                    print("=== ÁîüÊàêÂêçÂ≠óÊµÅÁ®ãÁµêÊùü v2 ===\n")
                }
            }
        }
    }
    
    // MARK: - Êñ∞ÁâàÊèêÁ§∫Ë©ûÊ∫ñÂÇôÊñπÊ≥ï (ÈÅ©Áî®ÊñºÊñ∞workflow: Ë≥áÊñôÂ°´ÂØ´->Ë®≠Ë®à‰∏ªËª∏->ÁâπÊÆäÈúÄÊ±Ç->ÁîüÊàêÁµêÊûú)
    private func preparePromptv2(
        formData: FormData, 
        designFocusData: DesignFocusData, 
        specialRequirementData: SpecialRequirementData?
    ) -> String {
        
        // 1. Âü∫Êú¨Ë≥áÊñôÈÉ®ÂàÜ
        var formDataString = """
        Áà∏Áà∏ÂßìÂêç: \(formData.fatherName)
        Â™ΩÂ™ΩÂßìÂêç: \(formData.motherName)
        ÂßìÊ∞èÈÅ∏Êìá: \(formData.surnameChoice)
        """
        
        // Âè™ÊúâÈùûÁ©∫ÁöÑ‰∏≠ÈñìÂ≠óÊâçÂä†ÂÖ•
        if !formData.middleName.isEmpty {
            formDataString += "\nÊåáÂÆö‰∏≠ÈñìÂ≠ó: \(formData.middleName)"
        }
        
        formDataString += """
        
        ÂñÆ/ÈõôÂêç: \(formData.numberOfNames == 1 ? "ÂñÆÂêç" : "ÈõôÂêç")
        ÊÄßÂà•: \(formData.gender)
        """
        
        // 2. Ë®≠Ë®à‰∏ªËª∏ÈÉ®ÂàÜ
        var designFocusString = ""
        if !designFocusData.selectedOptions.isEmpty {
            designFocusString = """
            
            Ë®≠Ë®à‰∏ªËª∏:
            \(designFocusData.selectedOptions.map { "- \($0)" }.joined(separator: "\n"))
            """
        }
        
        // Â¶ÇÊûúÊúâËá™ÂÆöÁæ©ÊèèËø∞ÔºåÂâáÂä†ÂÖ•
        if let customDescription = designFocusData.customDescription, !customDescription.isEmpty {
            if designFocusString.isEmpty {
                designFocusString = "\nË®≠Ë®à‰∏ªËª∏:"
            }
            designFocusString += "\n- Ëá™ÂÆöÁæ©ÊèèËø∞: \(customDescription)"
        }
        
        // 3. ÁâπÊÆäÈúÄÊ±ÇÈÉ®ÂàÜ
        var specialRequirementString = ""
        if let specialRequirementData = specialRequirementData {
            if !specialRequirementData.selectedRequirements.isEmpty {
                specialRequirementString = """
                
                ÁâπÊÆäÈúÄÊ±Ç:
                \(specialRequirementData.selectedRequirements.map { "- \($0)" }.joined(separator: "\n"))
                """
            }
            
            // Â¶ÇÊûúÊúâË©≥Á¥∞ÊèèËø∞ÔºåÂâáÂä†ÂÖ•
            if let detailDescription = specialRequirementData.detailDescription, !detailDescription.isEmpty {
                if specialRequirementString.isEmpty {
                    specialRequirementString = "\nÁâπÊÆäÈúÄÊ±Ç:"
                }
                specialRequirementString += "\n- Ë©≥Á¥∞Ë™™Êòé: \(detailDescription)"
            }
        }
        
        // 4. ÁµÑÂêàÂÆåÊï¥ÁöÑË°®ÂñÆË≥áÊñô
        let completeFormData = formDataString + designFocusString + specialRequirementString
        
        // 5. ‰ΩøÁî®Â∞àÈñÄÁÇ∫Êñ∞workflowË®≠Ë®àÁöÑÊ®°Êùø
        let template = """
        Ë´ãÊ†πÊìö‰ª•‰∏ãË°®ÂñÆË≥áÊñôÁÇ∫Â¨∞ÂÖíÁîüÊàê‰∏≠ÊñáÂêçÂ≠óÔºö

        ÂëΩÂêçË¶ÅÊ±ÇÔºö
        1. ÂêçÂ≠óÁÇ∫ÂñÆÂêçÊàñÈõôÂêçÔºåÂãôÂøÖÁ¢∫‰øùËàáÂü∫Êú¨Ë≥áÊñô‰∏≠ÁöÑÂñÆÈõôÂêç‰∏ÄËá¥„ÄÇ
        2. Â¶ÇÊúâÊåáÂÆö‰∏≠ÈñìÂ≠óÔºåÈ†àÂåÖÂê´ÊñºÂêç‰∏≠„ÄÇ
        3. ÂêçÂ≠óÁ¨¶ÂêàÂ¨∞ÂÖíÊÄßÂà•„ÄÇ
        4. ÂÖ∏ÊïÖ‰æÜÊ∫êÊñºÂÖ∑È´îÂÖßÂÆπ‰∏çÂèØÂÉÖÂºïÁî®ÁØáÂêç„ÄÇ
        5. ÂÖ∏ÊïÖËàáÂêçÂ≠óÊúâÊòéÁ¢∫ËÅØÁπ´Ôºå‰∏¶Ë©≥Ëø∞ÂÖ∂Èóú‰øÇ„ÄÇ
        6. Ê†πÊìöË®≠Ë®à‰∏ªËª∏Êèê‰æõÂàÜÊûêÔºåË™™ÊòéÂêçÂ≠óÂ¶Ç‰ΩïÈ´îÁèæË®≠Ë®àÁêÜÂøµ„ÄÇ
        7. Ê†πÊìöÁâπÊÆäÈúÄÊ±ÇÊèê‰æõÂàÜÊûêÔºåË™™ÊòéÂêçÂ≠óÂ¶Ç‰ΩïÊªøË∂≥ÁâπÊÆäË¶ÅÊ±Ç„ÄÇ
        
        Ê≥®ÊÑè‰∫ãÈ†ÖÔºö
        1. Ë´ãÁ¢∫‰øùËº∏Âá∫Ê†ºÂºèÁ¨¶ÂêàJSONË¶èÁØÑ„ÄÇ
        2. ÊâÄÊúâÂ≠ó‰∏≤ÂÄº‰ΩøÁî®ÈõôÂºïËôüÔºå‰∏¶ÈÅ©Áï∂‰ΩøÁî®ËΩâÁæ©Â≠óÁ¨¶„ÄÇ
        3. Ë´ã‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÔºåÁ¶ÅÊ≠¢‰ΩøÁî®Á∞°È´î‰∏≠Êñá„ÄÇ

        Âü∫Êú¨Ë≥áÊñôÔºö{{formData}}
        """
        
        print("üîÑ [Prompts] ‰ΩøÁî®Êñ∞workflowÂ∞àÁî®Ê®°Êùøv2: \(template)")
        print("üìù [FormData] ÂÆåÊï¥Ë°®ÂñÆË≥áÊñôv2: \(completeFormData)")
        
        // 6. Â∞áË≥áÊñôÂ°´ÂÖ•Ê®°Êùø
        return template.replacingOccurrences(of: "{{formData}}", with: completeFormData)
    }
    
    // MARK: - Êñ∞ÁâàAPIË™øÁî®ÊñπÊ≥ï (ÈÅ©Áî®ÊñºÊñ∞workflowÔºåÂÖºÂÆπv1ÁµêÊûúÊ®°Êùø)
    private func callOpenAIAPIv2(with prompt: String, formData: FormData) async throws -> (String, [String: String], [String]) {
        let monitor = PerformanceMonitor.shared
        
        monitor.start("API Setup v2")
        let apiKey = APIConfig.openAIKey
        let service = OpenAIServiceFactory.service(apiKey: apiKey)
        monitor.end("API Setup v2")

        // 1. ÂÆöÁæ©ÂÖ∏ÊïÖÂàÜÊûêÁöÑ Schema
        let literaryAllusionSchema = JSONSchema(
            type: .object,
            properties: [
                "source": JSONSchema(type: .string),
                "original_text": JSONSchema(type: .string),
                "interpretation": JSONSchema(type: .string),
                "connection": JSONSchema(type: .string)
            ],
            required: ["source", "original_text", "interpretation", "connection"],
            additionalProperties: false
        )

        // 2. ÂÆöÁæ©ÂàÜÊûêÁöÑ Schema (Á∞°ÂåñÁâàÔºå‰∏çÂåÖÂê´ÊÉÖÂ¢ÉÂàÜÊûê)
        let analysisSchema = JSONSchema(
            type: .object,
            properties: [
                "character_meaning": JSONSchema(type: .string),
                "literary_allusion": literaryAllusionSchema,
                "design_focus_analysis": JSONSchema(type: .string), // Êñ∞Â¢ûÔºöË®≠Ë®à‰∏ªËª∏ÂàÜÊûê
                "special_requirements_analysis": JSONSchema(type: .string) // Êñ∞Â¢ûÔºöÁâπÊÆäÈúÄÊ±ÇÂàÜÊûê
            ],
            required: ["character_meaning", "literary_allusion", "design_focus_analysis", "special_requirements_analysis"],
            additionalProperties: false
        )

        // 3. ÂÆöÁæ©ÂõûÊáâÊ†ºÂºèÁöÑ Schema
        let responseFormatSchema = JSONSchemaResponseFormat(
            name: "name_generation_v2",
            strict: true,
            schema: JSONSchema(
                type: .object,
                properties: [
                    "name": JSONSchema(type: .string),
                    "analysis": analysisSchema
                ],
                required: ["name", "analysis"],
                additionalProperties: false
            )
        )

        let messages: [ChatCompletionParameters.Message] = [
            .init(role: .system, content: .text(PromptManager.shared.getSystemPrompt())),
            .init(role: .user, content: .text(prompt))
        ]

        let parameters = ChatCompletionParameters(
            messages: messages,
            model: .gpt4omini,
            responseFormat: .jsonSchema(responseFormatSchema)
        )

        monitor.start("API Request Preparation v2")
        let completionObject = try await service.startChat(parameters: parameters)
        monitor.end("API Request Preparation v2")
        
        monitor.start("Response Processing v2")
        
        guard let jsonString = completionObject.choices.first?.message.content,
              let jsonData = jsonString.data(using: .utf8) else {
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Invalid AI response format v2 (SpecialRequirementView)",
                details: [
                    "prompt": prompt,
                    "response": completionObject.choices.first?.message.content ?? "No content"
                ]
            )
            throw NSError(domain: "OpenAIError", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response format"])
        }
        
        do {
            let jsonResult = try JSONDecoder().decode(NameGenerationResultv2.self, from: jsonData)
            
            // Áç≤Âèñ‰∫îË°åÂ±¨ÊÄß
            let elements = jsonResult.name.map { char in
                CharacterManager.shared.getElement(for: String(char))
            }
            
            // ÊßãÂª∫ÂàÜÊûêÂ≠óÂÖ∏ (ÂÖºÂÆπv1Ê®°ÊùøÊ†ºÂºè)
            let analysisDict: [String: String] = [
                "Â≠óÁæ©ÂàÜÊûê": jsonResult.analysis.character_meaning,
                "ÂÖ∏ÊïÖÂàÜÊûê": """
                    Âá∫ËôïÔºö\(jsonResult.analysis.literary_allusion.source)
                    ÂéüÊñáÔºö\(jsonResult.analysis.literary_allusion.original_text)
                    ÈáãÁæ©Ôºö\(jsonResult.analysis.literary_allusion.interpretation)
                    ÈÄ£ÁµêÔºö\(jsonResult.analysis.literary_allusion.connection)
                    """,
                "Ë®≠Ë®à‰∏ªËª∏ÂàÜÊûê": jsonResult.analysis.design_focus_analysis,
                "ÁâπÊÆäÈúÄÊ±ÇÂàÜÊûê": jsonResult.analysis.special_requirements_analysis
            ]

            monitor.end("Response Processing v2")
            
            // Add character count validation
            let expectedCharCount = formData.numberOfNames
            let actualCharCount = jsonResult.name.count
            
            // ÂêàÁêÜÁöÑÂêçÂ≠óÈï∑Â∫¶ÁØÑÂúçÔºöÂñÆÂêç 2-3 Â≠óÔºåÈõôÂêç 3-4 Â≠ó
            let minLength = formData.numberOfNames + 1  // Ëá≥Â∞ëÈúÄË¶ÅÂßìÊ∞è + ÊåáÂÆöÂ≠óÊï∏
            let maxLength = formData.numberOfNames + 2  // ÊúÄÂ§öÂßìÊ∞è 2 Â≠ó + ÊåáÂÆöÂ≠óÊï∏
            
            if actualCharCount < minLength || actualCharCount > maxLength {
                ErrorManager.shared.logError(
                    category: .aiResponseWrongCharacterCount,
                    message: "ÁîüÊàêÂêçÂ≠óÂ≠óÊï∏ÈåØË™§ v2 (SpecialRequirementView)",
                    details: [
                        "expected_range": "\(minLength)-\(maxLength)",
                        "actual_count": "\(actualCharCount)",
                        "generated_name": jsonResult.name,
                        "father_name": formData.fatherName,
                        "mother_name": formData.motherName
                    ]
                )
                showCharCountError = true
                generatedNameWithError = jsonResult.name
                throw NameGenerationError.wrongCharacterCount(
                    expected: expectedCharCount,
                    actual: actualCharCount
                )
            }
            
            return (jsonResult.name, analysisDict, elements)
            
        } catch let decodingError as DecodingError {
            ErrorManager.shared.logError(
                category: .aiResponseMalformedJSON,
                message: "Failed to decode AI response v2 (SpecialRequirementView)",
                details: [
                    "error": decodingError.localizedDescription,
                    "json": String(data: jsonData, encoding: .utf8) ?? "Invalid JSON"
                ]
            )
            throw decodingError
        } catch {
            ErrorManager.shared.logError(
                category: .unknown,
                message: "Unexpected error in AI response handling v2 (SpecialRequirementView)",
                details: [
                    "error": error.localizedDescription,
                    "prompt": prompt
                ]
            )
            throw error
        }
    }
    
    // MARK: - APIÈáëÈë∞Ë®∫Êñ∑ÊñπÊ≥ï
    private func diagnoseAPIKeyIssue() -> String {
        print("üîç [API Diagnosis] ÈñãÂßãË®∫Êñ∑APIÈáëÈë∞ÂïèÈ°å...")
        
        // Ê™¢Êü• API ÈáëÈë∞Ê†ºÂºè
        let apiKey = APIConfig.openAIKey
        if apiKey.isEmpty {
            return "APIÈáëÈë∞Êú™Ë®≠ÂÆöÔºöË´ãÊ™¢Êü•ÊáâÁî®Á®ãÂºèË®≠ÂÆö„ÄÇ"
        }
        
        if !apiKey.hasPrefix("sk-") {
            return "APIÈáëÈë∞Ê†ºÂºèÈåØË™§ÔºöOpenAI APIÈáëÈë∞ÊáâË©≤‰ª• 'sk-' ÈñãÈ†≠„ÄÇ"
        }
        
        if apiKey.count < 40 {
            return "APIÈáëÈë∞Èï∑Â∫¶Áï∞Â∏∏ÔºöOpenAI APIÈáëÈë∞Èï∑Â∫¶ÊáâË©≤Ë∂ÖÈÅé40ÂÄãÂ≠óÁ¨¶„ÄÇ"
        }
        
        return "APIÈáëÈë∞Ê†ºÂºèÊ≠£Á¢∫Ôºå‰ΩÜÂèØËÉΩÂ∑≤ÈÅéÊúüÊàñÁÑ°Êïà„ÄÇË´ãÊ™¢Êü•OpenAIÂ∏≥Êà∂‰∏≠ÁöÑAPIÈáëÈë∞ÁãÄÊÖã„ÄÇ"
    }
    
    // MARK: - ÈåØË™§ÂàÜÈ°ûÊñπÊ≥ï
    private func categorizeError(_ error: Error) -> String {
        print("üîç [Error Categorization] ÈñãÂßãÂàÜÊûêÈåØË™§...")
        
        // 1. Ê™¢Êü•ÊòØÂê¶ÊòØÁ∂≤Ë∑ØÁõ∏ÈóúÈåØË™§
        if let urlError = error as? URLError {
            print("üîç [Error Categorization] Á∂≤Ë∑ØÈåØË™§Ôºå‰ª£Á¢º: \(urlError.code.rawValue)")
            switch urlError.code {
            case .notConnectedToInternet:
                return "Á∂≤Ë∑ØÈÄ£Á∑öÂïèÈ°åÔºöË´ãÊ™¢Êü•ÊÇ®ÁöÑÁ∂≤Ë∑ØÈÄ£Á∑ö‰∏¶ÈáçË©¶„ÄÇ"
            case .timedOut:
                return "Ë´ãÊ±ÇÈÄæÊôÇÔºö‰º∫ÊúçÂô®ÂõûÊáâÊôÇÈñìÈÅéÈï∑ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
            case .cannotFindHost:
                return "‰º∫ÊúçÂô®ÈÄ£Á∑öÂïèÈ°åÔºöÁÑ°Ê≥ïÈÄ£Êé•Âà∞ÂëΩÂêçÊúçÂãôÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
            case .networkConnectionLost:
                return "Á∂≤Ë∑ØÈÄ£Á∑ö‰∏≠Êñ∑ÔºöË´ãÊ™¢Êü•Á∂≤Ë∑ØÁãÄÊÖã‰∏¶ÈáçË©¶„ÄÇ"
            default:
                return "Á∂≤Ë∑ØÈåØË™§Ôºö\(urlError.localizedDescription)ÔºàÈåØË™§‰ª£Á¢ºÔºö\(urlError.code.rawValue)Ôºâ"
            }
        }
        
        // 2. Ê™¢Êü•ÊòØÂê¶ÊòØJSONËß£ÊûêÈåØË™§
        if let decodingError = error as? DecodingError {
            print("üîç [Error Categorization] JSONËß£ÊûêÈåØË™§")
            switch decodingError {
            case .keyNotFound(let key, _):
                return "AIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöÁº∫Â∞ëÂøÖË¶ÅÁöÑÊ¨Ñ‰Ωç '\(key.stringValue)'ÔºåË´ãÈáçË©¶„ÄÇ"
            case .typeMismatch(let type, _):
                return "AIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöË≥áÊñôÈ°ûÂûã‰∏çÂåπÈÖç (\(type))ÔºåË´ãÈáçË©¶„ÄÇ"
            case .valueNotFound(let type, _):
                return "AIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöÊâæ‰∏çÂà∞È†êÊúüÁöÑ \(type) ÂÄºÔºåË´ãÈáçË©¶„ÄÇ"
            case .dataCorrupted(_):
                return "AIÂõûÊáâË≥áÊñôÊêçÂ£ûÔºöÊî∂Âà∞ÁöÑË≥áÊñôÁÑ°Ê≥ïËß£ÊûêÔºåË´ãÈáçË©¶„ÄÇ"
            @unknown default:
                return "AIÂõûÊáâËß£ÊûêÂ§±ÊïóÔºö\(decodingError.localizedDescription)"
            }
        }
        
        // 3. Ê™¢Êü•ÊòØÂê¶ÊòØÂêçÂ≠óÁîüÊàêÁõ∏ÈóúÈåØË™§
        if let nameError = error as? NameGenerationError {
            print("üîç [Error Categorization] ÂêçÂ≠óÁîüÊàêÈåØË™§")
            switch nameError {
            case .wrongCharacterCount(let expected, let actual):
                return "ÁîüÊàêÁöÑÂêçÂ≠óÂ≠óÊï∏‰∏çÁ¨¶ÂêàË¶ÅÊ±ÇÔºöÊúüÊúõ \(expected) Â≠óÔºåÂØ¶ÈöõÁîüÊàê \(actual) Â≠ó„ÄÇË´ãÈáçË©¶„ÄÇ"
            }
        }
        
        // 4. Ê™¢Êü•ÊòØÂê¶ÊòØNSError‰∏¶Êèê‰æõÊõ¥Ë©≥Á¥∞ÁöÑË®äÊÅØ
        if let nsError = error as NSError? {
            print("üîç [Error Categorization] NSErrorÔºåÂüü: \(nsError.domain)Ôºå‰ª£Á¢º: \(nsError.code)")
            
            // SwiftOpenAI.APIError ÁâπÂÆöËôïÁêÜ
            if nsError.domain == "SwiftOpenAI.APIError" {
                switch nsError.code {
                case 1:
                    // Âü∑Ë°å API ÈáëÈë∞Ë®∫Êñ∑
                    let diagnostic = self.diagnoseAPIKeyIssue()
                    return "OpenAI APIË´ãÊ±ÇÂ§±ÊïóÔºö\(diagnostic)"
                case 2:
                    return "OpenAI APIÂõûÊáâÊ†ºÂºèÈåØË™§ÔºöÊî∂Âà∞ÁöÑË≥áÊñôÊ†ºÂºè‰∏çÊ≠£Á¢∫ÔºåË´ãÈáçË©¶„ÄÇ"
                case 3:
                    return "OpenAI APIË™çË≠âÈåØË™§ÔºöAPIÈáëÈë∞ÂèØËÉΩÂ∑≤ÈÅéÊúüÊàñÁÑ°ÊïàÔºåË´ãÊ™¢Êü•APIÈáëÈë∞Ë®≠ÂÆö„ÄÇ"
                default:
                    return "OpenAI APIÈåØË™§Ôºö\(nsError.localizedDescription)ÔºàÈåØË™§‰ª£Á¢ºÔºö\(nsError.code)Ôºâ"
                }
            }
            
            // ‰∏ÄËà¨ OpenAI API Áõ∏ÈóúÈåØË™§
            if nsError.domain.contains("OpenAI") || nsError.domain.contains("API") {
                switch nsError.code {
                case 401:
                    return "APIË™çË≠âÂ§±ÊïóÔºöË´ãÊ™¢Êü•APIÈáëÈë∞ÊòØÂê¶Ê≠£Á¢∫Ë®≠ÂÆö„ÄÇ"
                case 429:
                    return "APIË´ãÊ±ÇÈÅéÊñºÈ†ªÁπÅÔºöË´ãÁ®çÂÄôÁâáÂàªÂÜçË©¶„ÄÇ"
                case 500...599:
                    return "‰º∫ÊúçÂô®ÂÖßÈÉ®ÈåØË™§ÔºöAIÊúçÂãôÊö´ÊôÇ‰∏çÂèØÁî®ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ"
                default:
                    return "APIÂëºÂè´Â§±ÊïóÔºö\(nsError.localizedDescription)ÔºàÈåØË™§‰ª£Á¢ºÔºö\(nsError.code)Ôºâ"
                }
            }
            
            // ÂÖ∂‰ªñNSError
            return "Á≥ªÁµ±ÈåØË™§Ôºö\(nsError.localizedDescription)ÔºàÂüüÔºö\(nsError.domain)Ôºå‰ª£Á¢ºÔºö\(nsError.code)Ôºâ"
        }
        
        // 5. Êú™Áü•ÈåØË™§
        print("üîç [Error Categorization] Êú™Áü•ÈåØË™§È°ûÂûã: \(type(of: error))")
        return "Êú™Áü•ÈåØË™§Ôºö\(error.localizedDescription)„ÄÇË´ãÈáçË©¶ÔºåÂ¶ÇÂïèÈ°åÊåÅÁ∫åÁôºÁîüÔºåË´ãËÅØÁπ´ÂÆ¢Êúç„ÄÇ"
    }
}

